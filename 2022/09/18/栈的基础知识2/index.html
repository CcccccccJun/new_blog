<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>栈的基础知识2 | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>栈的基础知识2</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-09-18T13:54:27.000Z" id="date"> 2022-09-18</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2022-09-25T07:38:54.952Z" id="updated"> 2022-09-25</time></div></span><br><span>文章总字数: <div class="control">1.3k</div></span><br><span>预计阅读时间: <div class="control">4 分钟</div></span></div></div><hr><div id="post-content"><p>想了想还是专门列一个板块来详讲虚拟内存和栈的详细结构，刚好自己这块的了解也是一知半解的，顺便扫盲一下</p>
<h2 id="cpu缓存"><a href="#cpu缓存" class="headerlink" title="cpu缓存"></a>cpu缓存</h2><p>从这个问题开始入手整个知识点体系吧</p>
<p><strong>通常情况下</strong>，我们可以用<strong>cache</strong>的大小来区分一个cpu的性能</p>
<p>cache是什么？cache指的是cpu的三级缓存，L1，L2，L3</p>
<p>由于cpu的运算能力远远大于数据传输</p>
<p>所以cpu在接下来的操作会用到的数据就会存放到他自己的缓存中</p>
<p>防止产生传输速度跟不上运算速度的问题</p>
<p>L1缓存中采用的是静态随机访问存储器(RAM)，其还有一种动态RAM</p>
<p>二者区别在于，静态RAM集成度更低，体积更大，价格更为高昂，但是性能强于动态RAM</p>
<p>L2和L32缓存便是采用动态RAM</p>
<p>并且 从L1到L3 三个缓存区的大小逐渐增大</p>
<p>但是仍然出现缓存区域不够的问题怎么办？扩大cache显然是最有效的办法，但是其成本过高</p>
<p>所以出现了内存条，即我们台式装机中所熟知的，内存条也一并归类于RAM</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>我们刚刚讲到，内存不够用时一般时扩大RAM，但是成本高，这里就出现了虚拟内存的用法</p>
<p>其本质是借用硬盘的一部分<strong>破碎的</strong>空间来使应用程序以为自己拥有了一块连续的内存地址</p>
<p>部分wiki过于学术，不好理解，这里摘取我个人觉得写的易懂有趣的一段描述</p>
<p>原文：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1612277">虚拟内存详解 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://imgloc.com/i/28IQ0"><img src="https://s1.328888.xyz/2022/09/20/28IQ0.png" alt="28IQ0.png"></a></p>
<p>这里我们了解一下，32位操作系统的电脑可以寻址到2^32(<strong>即寻址0~0xFFFFFFFF（4G）的地址空间</strong>)</p>
<p>但是假如你的电脑只有256m的物理内存(即0x~0x0FFFFFFF)</p>
<p>这时候虚拟内存映射到物理内存超出了物理内存地址的范围</p>
<p>那么这还如何调用？</p>
<p>这里得引入页，页桢，页号等概念</p>
<p>我们首先得知道，虚拟内存分成各个相同大小的页，而物理内存也是分为和前者大小相同的页桢</p>
<p>这就意味着，虚拟内存页数量&gt;物理内存页桢</p>
<p>那么计算机是怎么处理这个问题的？</p>
<p><strong>页面失效（page fault）功能</strong>:<strong>他挑选出一个使用最少的页桢，把他放入硬盘，并且使页放入这个空位，修改其映射，使得每个页都有机会被调用到</strong></p>
<p>我们这时候可以再说回计算机是如何寻址虚拟内存地址和物理内存地址的问题</p>
<p>我们仍然要提前了解偏移量和页号的概念</p>
<p>页号就是类似于铭牌，对应的映射到一个页桢</p>
<p>而偏移量就是页(页桢)的大小</p>
<p>这里比如操作系统想要访问一个页号为4的虚拟地址，他就会去该页号对应的页桢号(比如说是8)，如果页不在内存中，就利用页面失效功能，调入页，否则就把<strong>页帧号和偏移量传给MMU（CPU的内存管理单元）组成一个物理上真正存在的地址，接着就是访问物理内存中的数据了</strong></p>
<p><strong>MMU</strong>：<strong>分页内存管理单元</strong>,它是一种负责处理（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟内存到物理内存地址的转化(即虚拟内存管理)</p>
<p>接下提一嘴，linux的内存地址空间是4gb，所以每个页的大小为1024*4&#x3D;4mb 转化为16进制则是0x1000</p>
<p>这里就是我们在计算基址偏移的时候，之所以每个函数的后三位都是固定的(同一个libc版本下)</p>
<p>因为同一libc版本下的函数偏移量都是固定的</p>
<p>由于基址的后三位恒为000，所以最终函数的真实地址的后三位也是固定的</p>
<h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>内存一共分为五个区块 bss段 test段 stack段 heap段 data段</p>
<p><strong>全局静态区(bss)<strong>：存储未被初始化的</strong>全局变量</strong>，和data段一样都属于静态分配(可以理解为一开始要多少就给多少)，在编译阶段就确定了大小，不释放</p>
<p><strong>常量区(data)</strong>: 存储已被初始化的<strong>全局变量</strong>、常量</p>
<p>**栈空间(stack)**：主要用于函数调用时存储临时变量的，这部分的内存是自动分配，自动释放的</p>
<p><strong>堆空间(heap)</strong>: 主要用于动态分配，C语言中malloc和free操作堆内存(栈的学习结束后，我们就将迎来堆)</p>
<p><strong>代码区(text)</strong>:  存储程序的二进制指令，即程序编译后的二进制代码</p>
<p>全局变量：未初始化即int a;初始化即int a &#x3D; 1;</p>
<p><a target="_blank" rel="noopener" href="https://imgloc.com/i/28iN7"><img src="https://s1.328888.xyz/2022/09/20/28iN7.webp" alt="28iN7.webp"></a></p>
<p>我们先前讲到的栈，就是介于堆和栈中的一块空间</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/09/19/pwn1-sctf-2016/">← Next pwn1_sctf_2016</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/09/18/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-fmt/">HUBUCTF-新生赛-fmt Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>ChenBlog</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E7%BC%93%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">cpu缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">3.</span> <span class="toc-text">内存分区</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>