<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>基础知识1 | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>基础知识1</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-09-16T04:46:22.000Z" id="date"> 2022-09-16</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-11-18T14:59:20.306Z" id="updated"> 2022-11-18</time></div></span><br><span>Word Count: <div class="control">2.5k</div></span><br><span>Read Time: <div class="control">8 min</div></span></div></div><hr><div id="post-content"><p>本文用于简单介绍部分基础知识，详细请自行了解</p>
<p>并且为最初版的缘故，彼此之间并没有递进的关系，属于是我什么时候学到了就塞进来，所以此篇在学习时可以跳过，偶尔进来看看扩展知识点</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>缓冲区又称为缓存，它是<strong>内存空间</strong>的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来<em>缓冲输入或输出的数据</em>，这部分预留的空间就叫做缓冲区。</p>
<p>缓冲区的作用是什么？我们为什么不能直接进行硬盘和计算机之间的交互？</p>
<p>当我们在从硬盘中读入数据时，我们先把硬盘中的数据放入缓冲区，计算机再去缓冲区中读取数据，缓冲区中的数据被读取完了以后，缓冲区再去硬盘中读取数据</p>
<p>这样可以减少硬盘的读取次数，提高使用寿命</p>
<p>再加上计算机在缓冲区中的读取速度远远大于读取硬盘中的数据，运行效率也得到提升</p>
<p><a target="_blank" rel="noopener" href="https://imgloc.com/i/cXGQS"><img src="https://s1.328888.xyz/2022/09/16/cXGQS.webp" alt="cXGQS.webp"></a></p>
<p>做个直观的比喻</p>
<p>你掉落了100根牙签在地上，没有缓冲区的情况是</p>
<p>你弯腰捡完一根牙签就起身把他放回桌子上，接下来继续重复流程</p>
<p>而有了缓冲区以后，你弯腰捡完牙签，你会先把他放在手上，等手中的牙签数量足够多的时候，你才会起身放回桌面</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机通过软件模拟的具有完整功能的，能够运行在一个与物理机或和其他虚拟机环境隔绝的计算机系统</p>
<p>在物理机中能实现的系统操作在虚拟机中都能够实现</p>
<p>虚拟机的硬盘和内存容量需要从物理机中借用一部分</p>
<p>常常用来搭建linux操作系统</p>
<h2 id="c语言文件描述符"><a href="#c语言文件描述符" class="headerlink" title="c语言文件描述符"></a>c语言文件描述符</h2><p>Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符是<strong>内核</strong>为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 <strong>I&#x2F;O 操作</strong>相关的系统调用都需要通过文件描述符。</p>
<p>我们可以通过open函数系统调用得到一个指向该文件的描述符</p>
<p>这里我懒，借用<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108744787">文件描述符了解一下 - 知乎 (zhihu.com)</a>的实验数据，感兴趣的可以自己看</p>
<p>我们会发现文件描述符是一个非0正数</p>
<p>标准输入：0</p>
<p>标准输出：1</p>
<p>标准错误：2</p>
<p>这三个文件描述符默认情况下是开启的</p>
<p>文件描述符遵守着这样一个原则(非专业性原则，别盲目信服，有错误欢迎指出)</p>
<p><strong>open函数总是返回最低的未打开的描述符</strong></p>
<p>此时如果我们open一个文件，这个文件的文件描述符就是3</p>
<p>说了这么多，我们拿一题例题来直观感受</p>
<p><a target="_blank" rel="noopener" href="https://imgloc.com/i/cYbfK"><img src="https://s1.328888.xyz/2022/09/16/cYbfK.png" alt="cYbfK.png"></a></p>
<p>13行的close函数关闭了文件描述符1(标准输出)</p>
<p>而后又打开了文件flag.txt，此时flag.txt对应的文件描述符本应该是3</p>
<p>但是由于此时1被关闭了，多出了一个空余，根据原则，将优先返回最小的文件描述符，所以此时flag.txt对应的文件描述符就应该是1</p>
<p>read和write的用法这里不做解释了，适当培养自主查找资料并且理解的能力</p>
<h2 id="直接调用call-system和system的区别"><a href="#直接调用call-system和system的区别" class="headerlink" title="直接调用call system和system的区别"></a>直接调用call system和system的区别</h2><p>我们在构造payload时，有时会遇到溢出长度不够的情况</p>
<p><a target="_blank" rel="noopener" href="https://imgloc.com/i/cdZNB"><img src="https://s1.328888.xyz/2022/09/16/cdZNB.png" alt="cdZNB.png"></a></p>
<p>例如这题中(32位)，读入的数据长度为40个字节，而v1距离ebp28个字节，这里存在栈溢出</p>
<p>但是当我们想构造payload时我们会发现，按照正常的调用system时</p>
<p>payload &#x3D; cyclic(28)+cyclic(4)+p32(system_addr)+p32(0xabcdabc)+p32(binsh_addr)</p>
<p>我们发现payload的实际长度已经超过了可以读入的字节数</p>
<p>不妨从为什么system函数地址和参数要隔一个垃圾数据的原理来入手</p>
<p>我们这样编写payload的目的是调用system(‘&#x2F;bin&#x2F;sh’)</p>
<p>接下来用图像演示payload输入后的栈状况，利于理解</p>
<p><a target="_blank" rel="noopener" href="https://imgloc.com/i/oEU5s"><img src="https://s1.328888.xyz/2022/09/16/oEU5s.png" alt="oEU5s.png"></a></p>
<p>这里注意箭头指向，从下到上为由高地址向低地址，所以要注意buf是我们可以用来填充栈的变量</p>
<p>ret addr是我们要用来自由跳转的返回地址</p>
<p>所以我们构造的payload的cyclic（32）就会覆盖buf和ebp的空间</p>
<p>ret addr相当于ret system_addr</p>
<p>此时，由于system自己的汇编代码，他被弹出到eip后，会在原来栈的位置留下caller’s ebp</p>
<p>如下图</p>
<p><a target="_blank" rel="noopener" href="https://imgloc.com/i/oEeVN"><img src="https://s1.328888.xyz/2022/09/16/oEeVN.png" alt="oEeVN.png"></a></p>
<p>根据调用协议，system会去寻找低于他的ebp的两个字长处的数据作为他的参数，所以binsh_addr处的字符串&#x2F;bin&#x2F;sh就成为了system的参数</p>
<p>而体现给我们的就是，system_addr和参数间需要隔着一个垃圾数据</p>
<p>但是为什么调用call system就不需要中间这个垃圾数据呢？</p>
<p>我们对于call指令进行详解一下</p>
<p>call指令：</p>
<p>第一步：先将call指令的下一条指令的CS和IP入栈（当然如果是段间转移就要将CS和IP入栈，如果是段内转移就只要将IP入栈）</p>
<p>第二步：就是操作与call对应的jmp指令</p>
<p>所有的call指令都是可以用上面的两步来确定的，这是个通用的法则。</p>
<p>所以call system后是不会跳转到下一个地址，因为他没有ret</p>
<p>所以函数地址和参数地址之间并不需要一个垃圾数据作为返回地址</p>
<p>这样就节省了一个垃圾数据的字长</p>
<h2 id="栈对齐"><a href="#栈对齐" class="headerlink" title="栈对齐"></a>栈对齐</h2><p>首先我们得知道为什么要进行栈对齐，以及栈对齐是个什么原理</p>
<p>栈对齐旨在尽可能在少的内存访问周期内读取数据(听不懂没关系，记结论也是一种美德)</p>
<p>即<strong>栈顶指针必须是16字节的整数倍</strong></p>
<p>所以我们通常用ROPgaget来获取ret的地址</p>
<p>借助ret来进行栈对齐</p>
<p>ret怎么进行栈对齐？</p>
<p><strong>ps:以下为本人推论，可信度不高</strong></p>
<p>我们知道，ret的作用是弹出栈顶的一个字长到ip寄存器中</p>
<p>对于64位操作系统，一个字长就是8字节</p>
<p>如果此时栈顶指针末尾数字为8(即差一个字长，8字节才能为16字节整数倍)</p>
<p>这时候我们在<strong>返回地址处</strong>(这里不好理解，不过经过我自己的实验，在栈溢出中，不能放在垃圾数据前或中，不能放在栈顶，不能破坏payload原有结构，比如payload&#x3D;cyclic(xx)+p64(rid_addr)+p64(data_addr)中，如果ret放在rid_addr和data_addr就会破坏其原有的向rdi中传入参数的目的)</p>
<p>总结一下，如果有时候exp明明都对了，但就是pwn不成功，有可能是栈没有对齐导致的，可以gdb看一下栈顶地址，或者直接找对位置放个ret_addr</p>
<h2 id="python3中的byte型和str型"><a href="#python3中的byte型和str型" class="headerlink" title="python3中的byte型和str型"></a>python3中的byte型和str型</h2><p>首先我们要知道为什么要有byte型</p>
<p>在计算机发展初期，由于英文只有26个字母，相对比较容易做编译工作</p>
<p>所以早期的字符编码规范时ascii码</p>
<p>但是计算机发展普及后，多个国家的文字如何编译就成了问题</p>
<p>于是UTF-8编码应运而生，它规定<strong>英文字母系列用1个字节表示，汉字用3个字节表示</strong>等等</p>
<p>它兼容<code>ASCII</code>，可以解码早期的文档。</p>
<p>以汉字<strong>中文</strong>作为例子</p>
<p>byte：<strong>b’\xe4\xb8\xad\xe6\x96\x87’</strong></p>
<p>str：**’中文’**</p>
<p>byte型的作用是用来传输和存储数据，即str型的<strong>中文</strong>在传输时将encoude成byte型，需要使用时再decode成str型</p>
<p>那既然str型的数据在传输和存储的过程中，python会自动将我们的数据编码解码</p>
<p>那byte型的数据用意何在？</p>
<p>使用byte型实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式</p>
<p>并且由于python明确规范了byte型和str型，这二者就不能混用</p>
<h2 id="python中单双引号区别"><a href="#python中单双引号区别" class="headerlink" title="python中单双引号区别"></a>python中单双引号区别</h2><p>“”和’’都是为了用来定义一个字符串类型的数据</p>
<p>二者其实本质上没有区别</p>
<p>当我们需要定义一个需要引号的字符串时，这二者就可以用来这样表示：</p>
<p><strong>“我需要一个’引号’来表示我的字符串”</strong></p>
<h2 id="strlen绕过"><a href="#strlen绕过" class="headerlink" title="strlen绕过"></a>strlen绕过</h2><p>我们首先得了解，一段字符串是以’\0’来标记结尾的</p>
<p>即当strlen识别到\0时就会停止判断当前字符串的长度，那我们要绕过strlen就可以通过构造字符串时将其开头以\0填充</p>
<h2 id="可见字符串shellcode"><a href="#可见字符串shellcode" class="headerlink" title="可见字符串shellcode"></a>可见字符串shellcode</h2><p>有些题目虽然也是考查shellcode</p>
<p>但是其会对输入的字节进行if判定 需要有一个范围才能输入成功</p>
<p>所以这时候就用到了可见字符串shellcode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 64位 纯ascii字符shellcode</span><br><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br><span class="line">————————————————</span><br><span class="line"># 32位 纯ascii字符shellcode</span><br><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</span><br></pre></td></tr></table></figure>

<h2 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h2><p>sandbox </p>
<p>在ctf比赛中，pwn题中的沙盒一般都会限制execve的系统调用，这样一来one_gadget和system调用都不好使，只能采取open&#x2F;read&#x2F;write的组合方式来读取flag</p>
<p>标志性函数是prctl和seccomp</p>
<p>查询二进制文件限制的函数指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./filename</span><br></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/09/17/ROP/">← Next ROP</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/09/15/32%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/">栈溢出 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>ChenBlog</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.</span> <span class="toc-text">缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">c语言文件描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8call-system%E5%92%8Csystem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">直接调用call system和system的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%AF%B9%E9%BD%90"><span class="toc-number">5.</span> <span class="toc-text">栈对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python3%E4%B8%AD%E7%9A%84byte%E5%9E%8B%E5%92%8Cstr%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">python3中的byte型和str型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E4%B8%AD%E5%8D%95%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">python中单双引号区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strlen%E7%BB%95%E8%BF%87"><span class="toc-number">8.</span> <span class="toc-text">strlen绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6%E4%B8%B2shellcode"><span class="toc-number">9.</span> <span class="toc-text">可见字符串shellcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%9B%92"><span class="toc-number">10.</span> <span class="toc-text">沙盒</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>