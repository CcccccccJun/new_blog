<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>小林图解网络笔记 | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>小林图解网络笔记</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-12-18T04:40:54.000Z" id="date"> 2022-12-18</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-02-08T07:42:17.488Z" id="updated"> 2023-02-08</time></div></span><br><span>Word Count: <div class="control">2.2k</div></span><br><span>Read Time: <div class="control">7 min</div></span></div></div><hr><div id="post-content"><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文如标题所说 是小林图解网络的笔记 所以内容大部分都是我复制粘贴于原文的 只是我个人绝对有必要记住 重要的内容</p>
<p>如果想要了解网络基础 建议看原文</p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/">https://xiaolincoding.com/network/</a></p>
<h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>TCP&#x2F;IP网络模型的存在是因为为了跨设备进程通信 但是设备存在多样性 所以为了兼容 推出一套通用的网络协议</p>
<p>协议分层: 应用层 传输层 网络层 网络接口层</p>
<p>每层各司其职 在网络层中</p>
<p>使用ip地址来区分设备 分为网络号和主机号 网络号用来标识属于哪个子网 主机号标识具体主机</p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><p>浏览器是如何实现打开一个网页 和服务器进行交互的？</p>
<p>1.解析URL后 生成http请求消息</p>
<p>2.通过DNS服务器来查询对应域名的ip地址</p>
<p>3.http的传输工作是交给操作系统中的协议栈</p>
<p>浏览器通过socker库来委托协议栈工作  协议栈上半部分有两块协议 分别为TCP和UDP</p>
<p>TCP比UDP多很多特性 为了能够保证数据包传输到对方 而UDP只保证发送数据包 但是传输效率高</p>
<p>协议栈的下半部分是IP协议控制的 将数据分成一块块的网络包</p>
<p>物理硬件网卡就是负责完成实际的手法操作 而IP下面的网卡驱动程序就是控制网卡硬件</p>
<p>其中IP还包括两个协议 ICMP 和 ARP</p>
<p>ARP用于根据ip地址查询相应的以太网mac地址</p>
<p>ICMP用于报错和控制信息的报告</p>
<p>HTTP默认端口是80 HTTPS默认端口号是443</p>
<p>清楚一点 TCP传输数据还是通过IP来 TCP这是一种传输协议</p>
<p>目标地址和子网掩码都是0.0.0.0的话 是默认网关 如果其他的所有条目都不能匹配的话 就会自动匹配默认网关</p>
<p>4.生成了IP头部后 还需要加上MAC头部 MAC头部是在同一以太网中通过广播和缓存来获取对应路由器的MAC地址</p>
<p>5.通过网卡来将数字信号转化为电信号 因为网络包实际上存放在内存中的一串二进制数字信息 没有办法直接发送给对方 </p>
<p>6.交换机根据MAC地址查找 将信号发送到相应的端口</p>
<p>如果没有找到对应的端口 就将包发送到所有端口</p>
<p>还有一种MAC地址称为广播地址 交换机会将这个包发送到除了源端口以外的所有端口</p>
<ul>
<li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li>
<li>IP 地址中的 <code>255.255.255.255</code></li>
</ul>
<p>7.经过交换机后来到路由器</p>
<p>8.服务器接收到了数据包 开始拆快递 一层一层进行核验 然后解析出来是HTTP相应报文 就交给浏览器去渲染页面</p>
<h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><p>为了解决不同设备之间的通信 以及在网络互联中的兼容性问题 国际标准化组织制定了开放式系统互联通信参考模型 即OSI网络模型</p>
<p>一共有七层 分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层</p>
<ul>
<li>应用层，负责给应用程序提供统一的接口；</li>
<li>表示层，负责把数据转换成兼容另一个系统能识别的格式；</li>
<li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li>
<li>传输层，负责端到端的数据传输；</li>
<li>网络层，负责数据的路由、转发、分片；</li>
<li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</li>
<li>物理层，负责在物理网络中传输数据帧；</li>
</ul>
<p>但是由于其过于复杂  且仅仅只是概念上的提出 没有具体的实施方案 实际上使用多的是TCP|IP 模型 Linux系统正是按照这套模型实施网络协议栈的</p>
<p>网络协议栈是指网络中各层协议的总和，其形象的反映了一个网络中数据传输的过程：由上层协议到底层协议，再由底层协议到上层协议</p>
<p>TCP|IP网络模型一共有四层 分别是应用 传输 网络 网络接口层</p>
<ul>
<li>应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;</li>
<li>传输层，负责端到端的通信，比如 TCP、UDP 等；</li>
<li>网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；</li>
<li>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/63e349f24757feff33015e89.png">在以太网中 规定了最大传输单元MTU 为1500字节 也就是说单个IP包大小最多为1500字节</p>
<p>当网络包超过了MTU 那就需要分片 如果MTU越小 需要的分包越多 那么网络吞吐能力越差 反之</p>
<p>下图是Linux网络协议栈的流程 </p>
<p><img src="https://pic.imgdb.cn/item/63e34ad34757feff3302eb2c.webp"></p>
<p>LVS补充: LVS主要用于多服务器的负载均衡。它工作在网络层，可以实现高性能，高可用的服务器集群技术。</p>
<p>它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。</p>
<p>它易用，配置非常简单，且有多种负载均衡的方法。它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。</p>
<p>另外可扩展性也非常好</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_28903391/article/details/116891051">linux中的lvs的作用,LVS是什么及作用？ - osc_ozlday8e的个人空间 - OSCHINA - 中文开源技术交流社区…_皮小只的博客-CSDN博客</a></p>
<p>从上图的的网络协议栈，你可以看到：</p>
<ul>
<li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li>
<li>Socket 层的下面就是传输层、网络层和网络接口层；</li>
<li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li>
</ul>
<p>当网卡接收到了一个网络包后 通过DMA技术将网络包写入到对应的内存地址 也就是Ring Buffer 接着告诉操作系统这个网络包已经抵达</p>
<p>DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输</p>
<p>每当网卡接收到一个网络包 就会触发中断告诉操作系统已经接收到了网络包</p>
<p>但是如果网络包的数量非常多 就会频繁触发中断 导致cpu一直处理中断 影响其他进程的执行</p>
<p>所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong></p>
<p>它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p>
<p>因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数</p>
<p>发送网络包的话 会从用户态进入内核态 内核会申请一个内核态的sk_buff 内存 用用户发送的数据拷贝到sk_buff 内存 并将其传输到发送缓存区</p>
<p>接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</p>
<p>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong> ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</p>
<p>为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 <code>data</code> 的指针</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/12/18/gyctf-2020-borrowstack/">← Next gyctf_2020_borrowstack</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/12/16/others-babystack/">others_babystack Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307062245113.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>Dr.chen</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1"><span class="toc-number">2.</span> <span class="toc-text">2.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2"><span class="toc-number">3.</span> <span class="toc-text">2.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3"><span class="toc-number">4.</span> <span class="toc-text">2.3</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>