<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>LargebinAttack | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>LargebinAttack</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-03-04T14:08:12.000Z" id="date"> 2023-03-04</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-03-08T12:21:12.035Z" id="updated"> 2023-03-08</time></div></span><br><span>Word Count: <div class="control">2.8k</div></span><br><span>Read Time: <div class="control">11 min</div></span></div></div><hr><div id="post-content"><h2 id="Largebin介绍"><a href="#Largebin介绍" class="headerlink" title="Largebin介绍"></a>Largebin介绍</h2><p>Largebin用来收容超过0x400大小以上的chunk(64位) 其是一个双向链表<br>一共可以容纳63个chunk 和fastbin等不同的是 其对于链表对应存储chunk的大小没有明确规定 而是一个范围<br>一共分为6组<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303061950411.png" alt="image.png"><br>这里的差值(以字节为单位)是一个什么意思呢  比如在组别1中 现在释放三个chunk到largebin中 chunkA的大小是0x400 chunkB的大小是0x410 chunkC的大小是0x450<br>此时由于chunkC和chunkA的差值大于了64字节 所以chunkA和chunkB是位于同一组中 chunkC是另外一组<br>这在largebin这个双向链表中是一个什么情形呢 我们知道 largebin相对于unsortedbin多出来两个域 一个fd_nextsize 一个bk_nextsize<br>这两个域和fd和bk的域差距在哪里呢?<br>在largebin中 不同组的排列是根据从大到小来的 方便其遍历<br>fd_nextsize指向的是比当前组别小的组中最大的组<br>bk_nextsize指向的是比当前组别大的组中最小的组<br>而fd和bk则是用来指向组内的chunk<br>这么说可能不太好理解 用一张图来演示一下<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303062026756.png" alt="image.png"><br>size最大的chunk的bk_nextsize指向最小的chunk<br>size最小的chunk的fd_nextsize指向最大的chunk<br>并且相同大小的chunk只有链表头的fd_nextsize和bk_nextsize才有值 其余为0</p>
<h2 id="Largebin中chunk的插入取出机制"><a href="#Largebin中chunk的插入取出机制" class="headerlink" title="Largebin中chunk的插入取出机制"></a>Largebin中chunk的插入取出机制</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>来看看glibc源码是如何逐步使得chunk插入到largebin链表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (size))        <span class="comment">//如果是smallbin的大小就放到smallbin</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = smallbin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span>                                                    <span class="comment">//如果是largebin的大小，那么：</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = largebin_index (size);<span class="comment">//根据size获取对应的largebin索引</span></span><br><span class="line">             bck = bin_at (av, victim_index);         <span class="comment">//获取largebin表头</span></span><br><span class="line">             fwd = bck-&gt;fd;                                             <span class="comment">//获取对应索引largebin的第一个chunk（循环链表的head-&gt;next）</span></span><br><span class="line"> </span><br><span class="line">             <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">             <span class="keyword">if</span> (fwd != bck)                                            <span class="comment">//当第一个不等于最后一个（即当前的largebin不空）</span></span><br><span class="line">               &#123;</span><br><span class="line">                 <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                 size |= PREV_INUSE;</span><br><span class="line">                 <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                 assert (chunk_main_arena (bck-&gt;bk));    <span class="comment">//是否在main_arena?（主线程）</span></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">             &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))<span class="comment">//bck-&gt;bk储存的是当前索引的largebin中大小最小的chunk，如果我们要插入的chunk比这个大小还小，那么就要插入largebin的尾部。</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = bck;                                    <span class="comment">//fwd此时为largebin表头</span></span><br><span class="line">                     bck = bck-&gt;bk;                            <span class="comment">//bck设置为largebin中最后一个的chunk</span></span><br><span class="line"> </span><br><span class="line">                     victim-&gt;fd_nextsize = fwd-&gt;fd;<span class="comment">//由于我们要插入的在末尾，比他小的就是循环回去的第一个chunk</span></span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<span class="comment">//比他大的就是之前的最小的那个</span></span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//原来链表的第一个chunk的bk指向此时新插入的最后一个chunk</span></span><br><span class="line">                     fwd-&gt;fd-&gt;bk_nextsize =</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line"> </span><br><span class="line">                 <span class="comment">// 如果不是插入尾部，那么我们要找到这个chunk应该插入的位置</span></span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     assert (chunk_main_arena (fwd));</span><br><span class="line">                     <span class="comment">//使用这个while循环尝试从链表头部开始遍历，直到找到一个比victim大或等于的chunk退出while</span></span><br><span class="line">                     <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                       &#123;</span><br><span class="line">                         fwd = fwd-&gt;fd_nextsize;            <span class="comment">//取下一个</span></span><br><span class="line">                                                 assert (chunk_main_arena (fwd));<span class="comment">//检查分配区</span></span><br><span class="line">                       &#125;</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//如果找到了跟他想等的</span></span><br><span class="line">                     <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">                                             == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                       <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                       fwd = fwd-&gt;fd;<span class="comment">//直接将victim插入他的后面（通过fd），不修改nextsize指针。</span></span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//如果大小不一样(即此时fwd是相邻的大于victim的chunk)</span></span><br><span class="line">                     <span class="comment">//需要构造nextsize双向链表，构造新节点,victim作为堆头</span></span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                       &#123;</span><br><span class="line">                         <span class="comment">//比victim小的指向fwd</span></span><br><span class="line">                         <span class="comment">//比victim大的指向fwd的bk_nextsize（比fwd大的那个）</span></span><br><span class="line">                         <span class="comment">//相当于插入了fwd与fwd-&gt;bk_nextsize之间</span></span><br><span class="line">                         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line"> </span><br><span class="line">                         <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<span class="comment">//检查size链完整性</span></span><br><span class="line">                           malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                         <span class="comment">//对应的去改fwd的相关指针成链</span></span><br><span class="line">                         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                         <span class="comment">//插入完成</span></span><br><span class="line">                       &#125;</span><br><span class="line"> </span><br><span class="line">                     bck = fwd-&gt;bk;</span><br><span class="line">                     <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//此时victim为唯一的chunk，也要做循环链表</span></span><br><span class="line">           &#125;</span><br><span class="line">                   <span class="comment">//放到对应的 bin 中，构成 bk&lt;--&gt;victim&lt;--&gt;fwd。</span></span><br><span class="line">         mark_bin (av, victim_index);    <span class="comment">//标识bitmap</span></span><br><span class="line">         victim-&gt;bk = bck;</span><br><span class="line">         victim-&gt;fd = fwd;</span><br><span class="line">         fwd-&gt;bk = victim;</span><br><span class="line">         bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>上述的源码注释来源自</p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-262424.htm#msg_header_h3_4">原创]Largebin attack总结-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p>以下是我自己对于这个过程的理解</p>
<p>1.释放一个chunk后 首先对其大小进行判断 区分到smallbin或者是largebin 这里不讨论smallbin的情况</p>
<p>2.根据当前chunk的size 来索引对应的index 并且获得两个位于链表中chunk的指针 fwd指向链表头 也就是最大的chunk</p>
<p>bck指向最小的chunk</p>
<p>3.对于fwd和bck进行判断 如果二者相等 那么此时链表中就为空 直接将chunk放置为链表头 如果二者不相同 那么链表不为空 分为两种情况 如果chunk的size不是当前链表中最小的 从链表头开始 根据fd_nextsize指针来从大到小依次对比链表中原有的chunk大小和要插入的chunk大小 如果没有找到 那么就在对应合适的位置将当前chunk置为对应的链表头 其fd_nextsize和bk_nextsize各自指向对应的链表 如果找到了 就接入对应链表中 fd_nextsize和bk_nextsize为0 </p>
<p>4.如果当前chunk的size是当前链表中最小的 那么就直接放置到链表末尾 如果作为链表头 fd_nextsize指向最大的chunk的链表头 构成一个循环 bk_nextsize指向比当前链表更大一点的链表 如果链表尾的大小与要插入的chunk大小一致 那么就接在对应链表中</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>接下来我们来调试一番                 </p>
<p>调试环境  </p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081908421.png" alt="image-20230308190814310">                                            </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<p>chunk1用来防止chunk0释放以后和top chunk合并 </p>
<p>此时chunk0释放以后优先进入unsortedbin</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081909563.png" alt="image-20230308190941528"></p>
<p>要使得重新分配unsortedbin中的chunk 就需要我们申请一个超过unsortedbin中所有chunk大小的堆块 这样就会把unsortedbin中所有的chunk分配到largebin或者smallbin中</p>
<p>否则则将大小足够分配申请的chunk的free chunk分配出所需要的大小 其余unsortedbin中的chunk各自检验大小放入到largebin中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x490</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x460</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081921911.png" alt="image-20230308192148869"></p>
<p>接着我们来看看双链表结构大概是一个什么样子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x490</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x550</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<p>申请三个大小足够放入到largebin的chunk 并且为了防止物理相邻合并用0x10大小的chunk隔开 最后申请一个大chunk将unsortedbin的chunk分配到largebin中 此时预期这三个chunk应该各自成为链表头</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081929027.png" alt="image-20230308192948996"></p>
<p>此时我们在原来的基础上再多申请一个0x450大小的chunk 不出意外应该是分配到0x440链表后</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081934374.png" alt="image-20230308193401341"></p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081934744.png" alt="image-20230308193409699"></p>
<p>可以看到只有位于链表头的chunk的fd_nextsize和bk_nextsize才有值</p>
<p>具体的利用手法等下来讲吧 更进一步的调试可以自己尝试</p>
<h3 id="取出"><a href="#取出" class="headerlink" title="取出"></a>取出</h3><h4 id="源码理解-1"><a href="#源码理解-1" class="headerlink" title="源码理解"></a>源码理解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))<span class="comment">//如果不在samllbin大小中</span></span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx); <span class="comment">//找到申请的size对应的largebin链表</span></span><br><span class="line"> </span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;                    <span class="comment">//此时victim为链表的第一个节点</span></span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) <span class="comment">//第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//进入这里时，已经确定链表第一个节点——即最大的chunk大于要申请的size，那么我们就应该从这一条链中取，问题就是取这一条链上的哪一个？</span></span><br><span class="line">              victim = victim-&gt;bk_nextsize; <span class="comment">//本来victim是链中最大的那个，现在我们要从小往遍历，那么victim-&gt;bk_nextsize就循环回了链中最小的那个</span></span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb))) <span class="comment">//第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line">                victim = victim-&gt;bk_nextsize;<span class="comment">//victim取相邻的更大size的chunk</span></span><br><span class="line"> </span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="comment">//第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span></span><br><span class="line">                victim = victim-&gt;fd;            <span class="comment">//出现相同大小时堆头作为次优先申请</span></span><br><span class="line"> </span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd); <span class="comment">//第四步，largebin unlink 操作</span></span><br><span class="line"> </span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE) <span class="comment">//第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户</span></span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb); <span class="comment">//第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中（切割后）。</span></span><br><span class="line"> </span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);<span class="comment">//bck是ub头</span></span><br><span class="line">                  fwd = bck-&gt;fd;                         <span class="comment">//fwd是ub第一个chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                <span class="comment">//以上操作完成后lastremainder被插入ub，成为新的链首元素</span></span><br><span class="line">                <span class="comment">//如果不在smallbin范围，那么nextsize指针置空</span></span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以总结为以下流程:</p>
<p>1.首先读取largebin中最大chunk的大小 与用户申请的大小对比 如果小于则另寻办法申请chunk 如果大于就进入下一步</p>
<p>2.根据bk_nextsize来索引最小的chunk 顺着fd_nextsize来寻找与申请大小最为接近的chunk</p>
<p>3.如果查找到了合适的free chunk 先判断其是否只有单一chunk位于链表头 如果链表中有其他chunk的话 则分配其他chunk 这样是为了节省重新分配fd_nextsize和bk_nextsize的麻烦</p>
<p>4.判断分配完了的free chunk 如果剩余的大小大于MINSIZE 那么就放入到unsortedbin中 如果剩余大小小于MINSIZE 则一并分配给用户</p>
<h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><p>首先是我自己的第一个疑问 如何申请到单位不是MINSIZE的chunk 先来尝试一下手动修改size值 看看会不会按照预期效果分配chunk</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082002468.png" alt="image-20230308200227435"></p>
<p>将这一个chunk的size域从0x461修改为0x466 按照源代码的逻辑 此时申请一个0x410大小的chunk 剩下被分配到unsortedbin的chunk大小应该为0x40</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082004737.png" alt="image-20230308200449709"></p>
<p>失败了 看来是无法单单通过修改size域来实现预期效果 </p>
<p>到这里转念一想 64位构成一个chunk最起码也要0x20字节 毕竟还需要size域和prev_size域 也就是说如果此时largebin中有一个0x460的free chunk 我们申请一个0x450的chunk 显然会剩下0x10字节 小于MINSIZE 那么按照逻辑 就应该一起给了用户申请的chunk</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082017932.png" alt="image-20230308201736899"></p>
<p>可以看到确实是这样</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/03/03/safe-linking/">safe-linking Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>Dr.chen</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Largebin%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">Largebin介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Largebin%E4%B8%ADchunk%E7%9A%84%E6%8F%92%E5%85%A5%E5%8F%96%E5%87%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">Largebin中chunk的插入取出机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.1.</span> <span class="toc-text">源码理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%87%BA"><span class="toc-number">2.2.</span> <span class="toc-text">取出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">源码理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">调试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>