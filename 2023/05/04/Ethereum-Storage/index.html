<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Ethereum Storage | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Ethereum Storage</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-05-04T04:35:00.000Z" id="date"> 2023-05-04</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-05-05T15:00:23.342Z" id="updated"> 2023-05-05</time></div></span><br><span>Word Count: <div class="control">1.1k</div></span><br><span>Read Time: <div class="control">4 min</div></span></div></div><hr><div id="post-content"><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>对于一个智能合约 其采用的是solidity语言 该语言的数据存储不同于c语言</p>
<p>c语言其数据分为局部变量和全局变量 分别存储在栈和bss段 或者是一些字符串 存储在data段</p>
<p>而对于solidity来说 数据都是存储在一个元素庞大(2^256)的一个超级数组</p>
<p>我们称这个数组中的每一个元素为插槽 虽然这个数组的插槽看起来十分庞大 但是实际上和linux内存分页机制类似</p>
<p>只是规划出了插槽 但是只有非零的数据才能存储于其中</p>
<p>同时每个插槽对应着一个标识 用slot来表示 如下图所示</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305041244143.png" alt="image-20230504124407067"></p>
<p>常规的数据类型分为定长和不定长的 区别在于占用数组插槽的方式</p>
<p>定长的数据类型 诸如address unit等 有着固定的字节长度 如下表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address 20字节</span><br><span class="line">unit 默认是32字节 如果后面跟着数字 那就对应着多少位 比如unit8 对应着一个字节</span><br></pre></td></tr></table></figure>

<p>不定长的数据类型 分为两种情况 一种是映射 一种是动态长度</p>
<p>先说映射 变量的定义格式是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(address =&gt; uint) a</span><br></pre></td></tr></table></figure>

<p>上面的意思是 将address类型的变量作为<strong>键</strong> 而uint类型的变量为<strong>值</strong>  </p>
<p>在存储中 其按照值的数据类型占据插槽 但是实际上对应的插槽不会被真正使用 实际的数据例如 a[k] k就是键 存储的地址位于 <strong>slot keccak256(k . p)</strong>  p即上述虚假占据的插槽对应的slot</p>
<p>比如下面定义的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapping(address =&gt; uint) a;</span><br><span class="line">address b;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305041304488.png" alt="image-20230504130412459"></p>
<p>再来说说动态数组 其和映射占用的存储类似 同样会占用一个插槽 不过动调数组占用的插槽用来存储数组的长度</p>
<p>而动调数组实际的内容也需要通过 **keccak256(p)**来计算位置 例如下面的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unit[] a;</span><br><span class="line">unit b;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305041328441.png" alt="image-20230504132805417"></p>
<p>还有一点需要注意的就是 如果是字节数组和字符串数组 那么存储的形式又要转变</p>
<p>因为其长度占用的字节数较小 达不到一个插槽 所以数据和长度会放在同一个插槽中存放 长度位于高字节处(插槽左边) 数据位于低字节处(插槽右边)</p>
<p>但是只要长度占用的字节超过31字节 就跟普通的动态数组一样没有区别</p>
<h1 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h1><h2 id="Balsn-CTF-2019-bank"><a href="#Balsn-CTF-2019-bank" class="headerlink" title="Balsn CTF 2019-bank"></a>Balsn CTF 2019-bank</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract Bank &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint randomNumber = 0;</span><br><span class="line"></span><br><span class="line">    struct SafeBox &#123;</span><br><span class="line">        bool done;</span><br><span class="line">        function(uint, bytes12) internal callback;</span><br><span class="line">        bytes12 hash;</span><br><span class="line">        uint value;</span><br><span class="line">    &#125;</span><br><span class="line">    SafeBox[] safeboxes;</span><br><span class="line"></span><br><span class="line">    struct FailedAttempt &#123;</span><br><span class="line">        uint idx;</span><br><span class="line">        uint time;</span><br><span class="line">        bytes12 triedPass;</span><br><span class="line">        address origin;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address =&gt; FailedAttempt[]) failedLogs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先分析一下此时的插槽占用情况  address和uint定长 owner和randomNumber 占据slot0和slot1两个插槽</p>
<p>safebox是一个动态数组 所以其长度占据slot2插槽 实际的位置位于slot keccak(2)</p>
<p>failedlogs是一个映射 并且值的类型是动态数组 所以其占据slot3插槽 但是实际上没有被利用</p>
<p>而slot keccak(k,3)处存放着动态数组的长度 slot keccak(keccak(k,3))</p>
<p>而对于safebox和failedatttempt这两个结构体 其内部每一个元素所占用的插槽还要单独分析</p>
<p>bool定长为1字节 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(uint, bytes12) internal callback;</span><br></pre></td></tr></table></figure>

<p>这一句是定义了一个内部函数callback 拥有两个参数 internal规定了这个函数只能在合约内部被调用  这一个定义在插槽中占据8字节</p>
<p>bytes12占据12个字节 uint占据32个字节 所以safebox一个元素总计占用2个插槽</p>
<p>failedattempt结构体的成员就比较简单了  两个uint占用两个插槽  bytes12占用12字节 address占用20个字节 刚好三个插槽</p>
<p>至于slot keccak()的计算 可以通过下面的函数来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function read_slot(uint k) public view returns (bytes32 res) &#123;</span><br><span class="line">    assembly &#123; res := sload(k) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cal_addr(uint k, uint p) public pure returns(bytes32 res) &#123;</span><br><span class="line">    res = keccak256(abi.encodePacked(k, p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cal_addr(uint p) public pure returns(bytes32 res) &#123;</span><br><span class="line">    res = keccak256(abi.encodePacked(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个函数是视图函数 通过sload可以读取区块链地址上的指定插槽的数据 并通过bytes字节数组的形式返回</p>
<p>后面两个函数就是计算得到映射和动调数组对应的slot了</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/05/05/Ethereum-Opcodes/">← Next Ethereum Opcodes</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/05/02/%E8%B4%B5%E9%98%B3%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B2%BE%E8%8B%B1%E5%AF%B9%E6%8A%97%E8%B5%9B/">贵阳大数据及网络安全精英对抗赛 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307062245113.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>Dr.chen</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">例题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Balsn-CTF-2019-bank"><span class="toc-number">2.1.</span> <span class="toc-text">Balsn CTF 2019-bank</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>