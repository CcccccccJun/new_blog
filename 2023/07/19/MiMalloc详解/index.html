<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>MiMalloc | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>MiMalloc</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-07-19T06:27:44.000Z" id="date"> 2023-07-19</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-07-29T19:16:54.340Z" id="updated"> 2023-07-30</time></div></span><br><span>Word Count: <div class="control">5.3k</div></span><br><span>Read Time: <div class="control">24 min</div></span></div></div><hr><div id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在今年的HWS中遇到了一道堆 与往常不同的是 c语言标准库中的malloc分配器更换成了mimalloc 于是打算来了解一下这个分配器 查看一下这个分配器要如何利用</p>
<p>同时由于本人水平不足 对于mimalloc源码的分析不到位 很多地方也是一知半解 只能起到一个面向pwn解题的分析</p>
<p>个人认为相比起用ptmalloc锻炼源码分析能力 mimalloc更加轻量化 更能起到练手的一个效果</p>
<h2 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h2><p>本小节用来指引如何在ubuntu中配置c语言调用mimalloc库 如果没有需要自己编译题目来调试的 就不需要看</p>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/mimalloc">Microsoft &#x2F; Mimalloc：Mimalloc是一款紧凑的通用分配器，具有出色的性能。 (github.com)</a></p>
<p>首先git clone库到本地</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/microsoft/mimalloc.git</span><br></pre></td></tr></table></figure>

<p>随后创建一个目录用来存放构建后的项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake ../mimalloc/</span><br><span class="line">make</span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure>

<p>接着是比较麻烦的一步 因为在执行完make install后 官方文档是说会在&#x2F;usr&#x2F;include中安装头文件 但是我实测是没有的 所以我们需要手动把头文件复制到对应目录中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r /home/chen/mimalloc/include/* /usr/include/</span><br></pre></td></tr></table></figure>

<p>随后我们在使用gcc编译的时候 在后面加上-lmimalloc  就可以成功编译了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test ./test.c -lmimalloc</span><br></pre></td></tr></table></figure>

<p>如果需要用到pwndbg进行源码调试的 需要编译.so文件的时候加上-DCMAKE_BUILD_TYPE&#x3D;Debug 参照官方文档</p>
<h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p>对于每一个线程 都有对应的内存用来管理线程 我们称其为TLD</p>
<p>TLD主要由两个部分组成 segment和heap 我们先来介绍segment</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202325016.png" alt="image-20230720232504990"></p>
<p>这里的page就是实际分配给用户的内存 而第一个page的大小会小于其他page  是因为segment头部用来存放了当前segment的信息 占用了page的一部分空间</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202326091.png" alt="image-20230720232605058"></p>
<p>具体的成员我个人认为没有值得关注的 后面如果遇到了再说  这里先暂时记住segment的起始地址就是由于mi_malloc多分配的一块内存地址</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272314016.png" alt="image-20230727230229146"></p>
<p>heap重点的成员有三个 前面两个是用于存放空闲的内存块</p>
<p>pages_free_direct用于小于1024的内存块</p>
<p>thread_delayed_free是用于满页释放的 稍后会提及</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210044239.png" alt="image-20230721004423205"></p>
<p>通过pwndbg直接观察 会发现实际上重要信息存放是位于segment heap就起到了一个索引的功能</p>
<p>索引到的结构我们称之为内存页 其主要的成员就四个 </p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210103575.png" alt="image-20230721010343554"></p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210048592.png" alt="image-20230721004846559"></p>
<p>红框圈起来的就是free链表 蓝框圈起来的是local free链表</p>
<p>你会发现 和常规的malloc不同 并不是被申请过的内存块被释放后才会放入到链表中</p>
<p>当我们申请一个内存块后 当前page剩下的会划分成内存块放入到free链表中</p>
<p>当申请过的内存块释放后 会进入local free链表</p>
<p>随后我们来观察一下实际分配给用户的内存空间</p>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210109604.png" alt="image-20230721010905578"></p>
<p>此时我申请的是0x80大小的内存空间 可以看到此时的free链表就已经成型了</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="mi-malloc"><a href="#mi-malloc" class="headerlink" title="mi_malloc"></a>mi_malloc</h3><p>我们来分析一下mi_malloc函数的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_heap_malloc_zero(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> _mi_heap_malloc_zero_ex(heap, size, zero, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mi_decl_nodiscard <span class="keyword">extern</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_heap_malloc</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> _mi_heap_malloc_zero(heap, size, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mi_decl_nodiscard <span class="keyword">extern</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> mi_heap_malloc(mi_prim_get_default_heap(), size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mimalloc通过多次跳转指向了_mi_heap_malloc_zero_ex函数 我们来分析一下这个函数的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main allocation function</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_heap_malloc_zero_ex(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero, <span class="type">size_t</span> huge_alignment) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(size &lt;= MI_SMALL_SIZE_MAX)</span> &#123;</span><br><span class="line">    mi_assert_internal(huge_alignment == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> mi_heap_malloc_small_zero(heap, size, zero);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    mi_assert(heap!=<span class="literal">NULL</span>);</span><br><span class="line">    mi_assert(heap-&gt;thread_id == <span class="number">0</span> || heap-&gt;thread_id == _mi_thread_id());   <span class="comment">// heaps are thread local</span></span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> p = _mi_malloc_generic(heap, size + MI_PADDING_SIZE, zero, huge_alignment);  <span class="comment">// note: size can overflow but it is detected in malloc_generic</span></span><br><span class="line">    mi_track_malloc(p,size,zero);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_STAT&gt;1</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mi_heap_is_initialized(heap)) &#123; heap = mi_prim_get_default_heap(); &#125;</span><br><span class="line">      mi_heap_stat_increase(heap, <span class="built_in">malloc</span>, mi_usable_size(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; zero) &#123;</span><br><span class="line">      mi_assert_expensive(mi_mem_is_zero(p, size));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是对要申请chunk的大小进行了一个判断 如果小于MI_SMALL_SIZE_MAX 就会跳转到samll chunk的申请 同时进行了一个断言检测</p>
<p>MI_SMALL_SIZE_MAX的值定义在mimalloc.h中 可以看到是1024(64位的情况下 和指针字节大小有关系)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MI_SMALL_WSIZE_MAX (128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_SMALL_SIZE_MAX (MI_SMALL_WSIZE_MAXsizeof(void))</span></span><br></pre></td></tr></table></figure>

<p>我们先来分析大于1024的内存分配逻辑</p>
<p>对于heap指针是否为空和线程id进行了检查</p>
<p>随后跳转到_mi_malloc_generic函数中进行内存分配  mi_track_malloc函数是用来将内存块的信息存储在track跟踪器中 方便调试</p>
<p>接着使用了条件编译语句  根据MI_STAT的值来决定是否记录更新heap的数据 用于调试</p>
<p>mi_heap_stat_increase函数用于更新heap的统计数据 mi_usable_size函数用于计算内存块的实际大小(不是申请的大小)</p>
<p>如果MI_DEBUG的值设置为3 那么就会调用mi_assert_expensive函数检测条件是否成立 这里的条件是调用mi_mem_is_zero来检测分配的内存块的前size个字节是否为0 MI_DEBUG的默认值为0 常规情况下我们并不用担心fake_chunk被检测出来</p>
<h3 id="mi-malloc-generic"><a href="#mi-malloc-generic" class="headerlink" title="_mi_malloc_generic"></a>_mi_malloc_generic</h3><p>随后我们进入_mi_malloc_generic函数 查看一下分析的主要逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* _mi_malloc_generic(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero, <span class="type">size_t</span> huge_alignment) mi_attr_noexcept</span><br><span class="line">&#123;</span><br><span class="line">  mi_assert_internal(heap != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize if necessary</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(!mi_heap_is_initialized(heap))</span> &#123;</span><br><span class="line">    heap = mi_heap_get_default(); <span class="comment">// calls mi_thread_init </span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(!mi_heap_is_initialized(heap))</span> &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(mi_heap_is_initialized(heap));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call potential deferred free routines</span></span><br><span class="line">  _mi_deferred_free(heap, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free delayed frees from other threads (but skip contended ones)</span></span><br><span class="line">  _mi_heap_delayed_free_partial(heap);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find (or allocate) a page of the right size</span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = mi_find_page(heap, size, huge_alignment);</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(page == <span class="literal">NULL</span>)</span> &#123; <span class="comment">// first time out of memory, try to collect and retry the allocation once more</span></span><br><span class="line">    mi_heap_collect(heap, <span class="literal">true</span> <span class="comment">/* force */</span>);</span><br><span class="line">    page = mi_find_page(heap, size, huge_alignment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(page == <span class="literal">NULL</span>)</span> &#123; <span class="comment">// out of memory</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> req_size = size - MI_PADDING_SIZE;  <span class="comment">// correct for padding_size in case of an overflow on `size`</span></span><br><span class="line">    _mi_error_message(ENOMEM, <span class="string">&quot;unable to allocate memory (%zu bytes)\n&quot;</span>, req_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">  mi_assert_internal(mi_page_block_size(page) &gt;= size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and try again, this time succeeding! (i.e. this should never recurse through _mi_page_malloc)</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(zero &amp;&amp; page-&gt;xblock_size == <span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// note: we cannot call _mi_page_malloc with zeroing for huge blocks; we zero it afterwards in that case.</span></span><br><span class="line">    <span class="type">void</span>* p = _mi_page_malloc(heap, page, size, <span class="literal">false</span>);</span><br><span class="line">    mi_assert_internal(p != <span class="literal">NULL</span>);</span><br><span class="line">    _mi_memzero_aligned(p, mi_page_usable_block_size(page));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _mi_page_malloc(heap, page, size, zero);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最开始对于heap是否初始化了进行一个检测 如果没有初始化则进行初始化</p>
<p>随后调用_mi_deferred_free将本线程所有标记释放的内存块加入到延迟释放列表中 随后批量释放 这一操作是为了提高性能</p>
<p>调用_mi_heap_delayed_free_partial函数 释放其他线程已经标记释放的内存块 但跳过正在争用的内存块</p>
<p>接着调用mi_find_page函数寻找可用的page 如果没有找到则将空闲的内存块回收后再次查找</p>
<p>如果最后还是没有找到空闲的page 就说明空间不足 触发断言输出报错</p>
<p>如果找到了可用的page 接着对于page的立即可用性进行检测 以及检测page的大小是否满足size的需求 这里的检测依赖的是page的xblock成员 其存储的是当前page中的内存块大小</p>
<p>接着是性能优化的问题 通过xblock和zero参数来决定用哪种办法来清零内存块的内容</p>
<h3 id="mi-page-malloc"><a href="#mi-page-malloc" class="headerlink" title="_mi_page_malloc"></a>_mi_page_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_page_malloc(<span class="type">mi_heap_t</span>* heap, <span class="type">mi_page_t</span>* page, <span class="type">size_t</span> size, <span class="type">bool</span> zero) mi_attr_noexcept &#123;</span><br><span class="line">  mi_assert_internal(page-&gt;xblock_size==<span class="number">0</span>||mi_page_block_size(page) &gt;= size);</span><br><span class="line">  <span class="type">mi_block_t</span>* <span class="type">const</span> block = page-&gt;<span class="built_in">free</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(block == <span class="literal">NULL</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _mi_malloc_generic(heap, size, zero, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(block != <span class="literal">NULL</span> &amp;&amp; _mi_ptr_page(block) == page);</span><br><span class="line">  <span class="comment">// pop from the free list</span></span><br><span class="line">  page-&gt;used++;</span><br><span class="line">  page-&gt;<span class="built_in">free</span> = mi_block_next(page, block);</span><br><span class="line">  mi_assert_internal(page-&gt;<span class="built_in">free</span> == <span class="literal">NULL</span> || _mi_ptr_page(page-&gt;<span class="built_in">free</span>) == page);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;free_is_zero) &#123;</span><br><span class="line">    mi_assert_expensive(mi_mem_is_zero(block+<span class="number">1</span>,size - <span class="keyword">sizeof</span>(*block)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allow use of the block internally</span></span><br><span class="line">  <span class="comment">// note: when tracking we need to avoid ever touching the MI_PADDING since</span></span><br><span class="line">  <span class="comment">// that is tracked by valgrind etc. as non-accessible (through the red-zone, see `mimalloc/track.h`)</span></span><br><span class="line">  mi_track_mem_undefined(block, mi_page_usable_block_size(page));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// zero the block? note: we need to zero the full block size (issue #63)</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(zero)</span> &#123;</span><br><span class="line">    mi_assert_internal(page-&gt;xblock_size != <span class="number">0</span>); <span class="comment">// do not call with zero&#x27;ing for huge blocks (see _mi_malloc_generic)</span></span><br><span class="line">    mi_assert_internal(page-&gt;xblock_size &gt;= MI_PADDING_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;free_is_zero) &#123;</span><br><span class="line">      block-&gt;next = <span class="number">0</span>;</span><br><span class="line">      mi_track_mem_defined(block, page-&gt;xblock_size - MI_PADDING_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _mi_memzero_aligned(block, page-&gt;xblock_size - MI_PADDING_SIZE);</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN</span></span><br><span class="line">  <span class="keyword">if</span> (!zero &amp;&amp; !mi_page_is_huge(page)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(block, MI_DEBUG_UNINIT, mi_page_usable_block_size(page));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (MI_SECURE!=0)</span></span><br><span class="line">  <span class="keyword">if</span> (!zero) &#123; block-&gt;next = <span class="number">0</span>; &#125; <span class="comment">// don&#x27;t leak internal data</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_STAT&gt;0)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bsize = mi_page_usable_block_size(page);</span><br><span class="line">  <span class="keyword">if</span> (bsize &lt;= MI_MEDIUM_OBJ_SIZE_MAX) &#123;</span><br><span class="line">    mi_heap_stat_increase(heap, normal, bsize);</span><br><span class="line">    mi_heap_stat_counter_increase(heap, normal_count, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_STAT&gt;1)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> bin = _mi_bin(bsize);</span><br><span class="line">    mi_heap_stat_increase(heap, normal_bins[bin], <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MI_PADDING <span class="comment">// &amp;&amp; !MI_TRACK_ENABLED</span></span></span><br><span class="line">  <span class="type">mi_padding_t</span>* <span class="type">const</span> padding = (<span class="type">mi_padding_t</span>*)((<span class="type">uint8_t</span>*)block + mi_page_usable_block_size(page));</span><br><span class="line">  <span class="type">ptrdiff_t</span> delta = ((<span class="type">uint8_t</span>*)padding - (<span class="type">uint8_t</span>*)block - (size - MI_PADDING_SIZE));</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;=2)</span></span><br><span class="line">  mi_assert_internal(delta &gt;= <span class="number">0</span> &amp;&amp; mi_page_usable_block_size(page) &gt;= (size - MI_PADDING_SIZE + delta));</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  mi_track_mem_defined(padding,<span class="keyword">sizeof</span>(<span class="type">mi_padding_t</span>));  <span class="comment">// note: re-enable since mi_page_usable_block_size may set noaccess</span></span><br><span class="line">  padding-&gt;canary = (<span class="type">uint32_t</span>)(mi_ptr_encode(page,block,page-&gt;keys));</span><br><span class="line">  padding-&gt;delta  = (<span class="type">uint32_t</span>)(delta);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_PADDING_CHECK</span></span><br><span class="line">  <span class="keyword">if</span> (!mi_page_is_huge(page)) &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* fill = (<span class="type">uint8_t</span>*)padding - delta;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> maxpad = (delta &gt; MI_MAX_ALIGN_SIZE ? MI_MAX_ALIGN_SIZE : delta); <span class="comment">// set at most N initial padding bytes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; maxpad; i++) &#123; fill[i] = MI_DEBUG_PADDING; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开头对于xblock和page的free链表重新进行了检查</p>
<p>如果block为零 则说明不存在对应大小的page页 就调用_mi_malloc_generic函数来分配</p>
<p>接着自增了page的used成员 同时更新free链表 调用 mi_block_next函数来获取下一个内存块的地址 并且进行了检测 不能为0</p>
<p>随后根据zero来决定是否在内存块中填充数据 方便用来检测内存越界等问题 常规情况下都是\x00 但是如果开启了调试模式 就会被填充成\xd0</p>
<p>下面的一大堆编译优化的都不影响我们内存分配 所以这里忽略 感兴趣的可以自行了解</p>
<h3 id="mi-find-page"><a href="#mi-find-page" class="headerlink" title="mi_find_page"></a>mi_find_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page</span></span><br><span class="line"><span class="comment">// Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed.</span></span><br><span class="line"><span class="type">static</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_find_page</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">size_t</span> huge_alignment)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="comment">// huge allocation?</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> req_size = size - MI_PADDING_SIZE;  <span class="comment">// correct for padding_size in case of an overflow on `size`  </span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(req_size &gt; (MI_MEDIUM_OBJ_SIZE_MAX - MI_PADDING_SIZE) || huge_alignment &gt; <span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(req_size &gt; PTRDIFF_MAX)</span> &#123;  <span class="comment">// we don&#x27;t allocate more than PTRDIFF_MAX (see &lt;https://sourceware.org/ml/libc-announce/2019/msg00001.html&gt;)</span></span><br><span class="line">      _mi_error_message(EOVERFLOW, <span class="string">&quot;allocation request is too large (%zu bytes)\n&quot;</span>, req_size);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mi_large_huge_page_alloc(heap,size,huge_alignment);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// otherwise find a page with free blocks in our size segregated queues</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_PADDING</span></span><br><span class="line">    mi_assert_internal(size &gt;= MI_PADDING_SIZE); </span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> mi_find_free_page(heap, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们留意一下开头的这句话</p>
<p><strong>&#x2F;&#x2F; Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed.</strong></p>
<p>这就是当我们在调试模式下  申请一个0x200的内存块 实际分配到的是0x280的原因 MI_PADDING_SIZE在上一个小节中出现过 其用来计算填充数据的字节 检测是否存在内存溢出等</p>
<p>默认情况下MI_PADDING_SIZE是零</p>
<p>至于第一个if判断也用上了unlikely 因为几乎不会触发 看一下MI_MEDIUM_OBJ_SIZE_MAX的值就知道了 64位的情况下MI_MEDIUM_PAGE_SIZE是128kib 也就是说MI_MEDIUM_OBJ_SIZE_MAX是32*1024字节 一般来说size是肯定小于的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MI_MEDIUM_OBJ_SIZE_MAX (MI_MEDIUM_PAGE_SIZE/4) // 128KiB on 64-bit</span><br></pre></td></tr></table></figure>

<p>接着就是调用mi_find_free_page来查找空闲的page</p>
<h3 id="mi-find-free-page"><a href="#mi-find-free-page" class="headerlink" title="mi_find_free_page"></a>mi_find_free_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a page with free blocks of `size`.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_find_free_page</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="type">mi_page_queue_t</span>* pq = mi_page_queue(heap,size);</span><br><span class="line">  <span class="type">mi_page_t</span>* page = pq-&gt;first;</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="meta">#<span class="keyword">if</span> (MI_SECURE&gt;=3) <span class="comment">// in secure mode, we extend half the time to increase randomness</span></span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;capacity &lt; page-&gt;reserved &amp;&amp; ((_mi_heap_random_next(heap) &amp; <span class="number">1</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">      mi_page_extend_free(heap, page, heap-&gt;tld);</span><br><span class="line">      mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      _mi_page_free_collect(page,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mi_page_immediate_available(page)) &#123;</span><br><span class="line">      page-&gt;retire_expire = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> page; <span class="comment">// fast path</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mi_page_queue_find_free_ex(heap, pq, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过mi_page_queue函数索引到对应大小的队列 如果是首次申请该size 一般来说都是page都是0</p>
<p>申请过的话 会索引到page1的内存页</p>
<p>接下来是debug模式才会触发的随机扩展 目的是为了增加安全性 这里不进行讨论</p>
<p>接着调用_mi_page_free_collect函数获取page</p>
<p>调用mi_page_immediate_available检测page是否可用 如果可用则置零retire_expire 将page标识为不回收 随后返回</p>
<p>如果page为零 那么就调用mi_page_queue_find_free_ex进行下一步的查找</p>
<h3 id="mi-page-queue-find-free-ex"><a href="#mi-page-queue-find-free-ex" class="headerlink" title="mi_page_queue_find_free_ex"></a>mi_page_queue_find_free_ex</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_page_queue_find_free_ex</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">mi_page_queue_t</span>* pq, <span class="type">bool</span> first_try)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// search through the pages in &quot;next fit&quot; order</span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_STAT</span></span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = pq-&gt;first;</span><br><span class="line">  <span class="keyword">while</span> (page != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">mi_page_t</span>* next = page-&gt;next; <span class="comment">// remember next</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_STAT    </span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0. collect freed blocks by us and other threads</span></span><br><span class="line">    _mi_page_free_collect(page, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. if the page contains free blocks, we are done</span></span><br><span class="line">    <span class="keyword">if</span> (mi_page_immediate_available(page)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">// pick this one</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Try to extend</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;capacity &lt; page-&gt;reserved) &#123;</span><br><span class="line">      mi_page_extend_free(heap, page, heap-&gt;tld);</span><br><span class="line">      mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. If the page is completely full, move it to the `mi_pages_full`</span></span><br><span class="line">    <span class="comment">// queue so we don&#x27;t visit long-lived pages too often.</span></span><br><span class="line">    mi_assert_internal(!mi_page_is_in_full(page) &amp;&amp; !mi_page_immediate_available(page));</span><br><span class="line">    mi_page_to_full(page, pq);</span><br><span class="line"></span><br><span class="line">    page = next;</span><br><span class="line">  &#125; <span class="comment">// for each page</span></span><br><span class="line"></span><br><span class="line">  mi_heap_stat_counter_increase(heap, searches, count);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    _mi_heap_collect_retired(heap, <span class="literal">false</span>); <span class="comment">// perhaps make a page available?</span></span><br><span class="line">    page = mi_page_fresh(heap, pq);</span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span> &amp;&amp; first_try) &#123;</span><br><span class="line">      <span class="comment">// out-of-memory _or_ an abandoned page with free blocks was reclaimed, try once again</span></span><br><span class="line">      page = mi_page_queue_find_free_ex(heap, pq, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    mi_assert(pq-&gt;first == page);</span><br><span class="line">    page-&gt;retire_expire = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(page == <span class="literal">NULL</span> || mi_page_immediate_available(page));</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果page为0  那么就会跳过while循环 进入if分支 调用_mi_heap_collect_retired函数</p>
<p>该函数就是遍历heap-&gt;page_retired_min<code>到</code>heap-&gt;page_retired_max之间的所有页面队列 具体的这里先不讲</p>
<p>接着调用mi_page_fresh函数来初始化一个新的内存页面 这里返回的值实际上就是位于segment首地址处的page info信息</p>
<p>如果page还是为0的话 就再次调用mi_page_queue_find_free_ex函数 </p>
<p>如果page在while循环中获取到了 就设置page为不可回收</p>
<p>在最后进行了断言判断 page要么可利用 要么为0</p>
<h3 id="mi-page-free-collect"><a href="#mi-page-free-collect" class="headerlink" title="_mi_page_free_collect"></a>_mi_page_free_collect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _mi_page_free_collect(<span class="type">mi_page_t</span>* page, <span class="type">bool</span> force) &#123;</span><br><span class="line">  mi_assert_internal(page!=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// collect the thread free list</span></span><br><span class="line">  <span class="keyword">if</span> (force || mi_page_thread_free(page) != <span class="literal">NULL</span>) &#123;  <span class="comment">// quick test to avoid an atomic operation</span></span><br><span class="line">    _mi_page_thread_free_collect(page);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and the local free list</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;local_free != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(page-&gt;<span class="built_in">free</span> == <span class="literal">NULL</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// usual case</span></span><br><span class="line">      page-&gt;<span class="built_in">free</span> = page-&gt;local_free;</span><br><span class="line">      page-&gt;local_free = <span class="literal">NULL</span>;</span><br><span class="line">      page-&gt;free_is_zero = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">      <span class="comment">// append -- only on shutdown (force) as this is a linear operation</span></span><br><span class="line">      <span class="type">mi_block_t</span>* tail = page-&gt;local_free;</span><br><span class="line">      <span class="type">mi_block_t</span>* next;</span><br><span class="line">      <span class="keyword">while</span> ((next = mi_block_next(page, tail)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail = next;</span><br><span class="line">      &#125;</span><br><span class="line">      mi_block_set_next(page, tail, page-&gt;<span class="built_in">free</span>);</span><br><span class="line">      page-&gt;<span class="built_in">free</span> = page-&gt;local_free;</span><br><span class="line">      page-&gt;local_free = <span class="literal">NULL</span>;</span><br><span class="line">      page-&gt;free_is_zero = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mi_assert_internal(!force || page-&gt;local_free == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始首先收集thread_free中的内存块 接下来收集free和local_free的内存块 这里来分析一下逻辑</p>
<p>如果loacl_free链表不为空 进入if分支 检测free链表是否为空 如果为空 则将local_free链表移到free链表中 同时没有做任何的检查 也就意味着这里我们可以做到任意地址申请 只需要想办法覆盖local_free链表</p>
<h3 id="mi-heap-malloc-small-zero"><a href="#mi-heap-malloc-small-zero" class="headerlink" title="mi_heap_malloc_small_zero"></a>mi_heap_malloc_small_zero</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_heap_malloc_small_zero</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero)</span> mi_attr_noexcept &#123;</span><br><span class="line">  mi_assert(heap != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uintptr_t</span> tid = _mi_thread_id();</span><br><span class="line">  mi_assert(heap-&gt;thread_id == <span class="number">0</span> || heap-&gt;thread_id == tid); <span class="comment">// heaps are thread local</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  mi_assert(size &lt;= MI_SMALL_SIZE_MAX);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> (MI_PADDING)</span></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123; size = <span class="keyword">sizeof</span>(<span class="type">void</span>*); &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = _mi_heap_get_free_small_page(heap, size + MI_PADDING_SIZE);</span><br><span class="line">  <span class="type">void</span>* <span class="type">const</span> p = _mi_page_malloc(heap, page, size + MI_PADDING_SIZE, zero);  </span><br><span class="line">  mi_track_malloc(p,size,zero);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_STAT&gt;1</span></span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mi_heap_is_initialized(heap)) &#123; heap = mi_prim_get_default_heap(); &#125;</span><br><span class="line">    mi_heap_stat_increase(heap, <span class="built_in">malloc</span>, mi_usable_size(p));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; zero) &#123;</span><br><span class="line">    mi_assert_expensive(mi_mem_is_zero(p, size));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的逻辑还是比较简单的 就是通过_mi_heap_get_free_small_page函数获取到适合small内存块的page 随后调用 _mi_page_malloc来申请内存块 剩余的部分就是一些check和计数信息的更新</p>
<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>那么到这里我们可以做一个大概的总结 首先进入mi_malloc函数 对于要申请的内存块的size进行了判断 如果小于0x400则进入 mi_heap_malloc_small_zero函数 如果大于0x400则进入_mi_malloc_generic函数</p>
<p>如果是进入mi_heap_malloc_small_zero函数 那么会调用 _mi_page_malloc来获取内存块</p>
<p>该函数通过page的free链表来获取相应的内存块</p>
<p>如果是_mi_malloc_generic函数 那么会调用mi_find_page函数来寻找可用的page 该函数继续索引到mi_find_free_page函数来寻找page</p>
<p>根据是否开启了debug模式来调用_mi_page_free_collect函数 如果开启了debug模式 就不会预编译对应的else分支 如果关闭了debug模式 就会进入该函数  一开始先根据force参数或者是mi_page_thread_free函数的返回值来决定是否要调用thread_free  接着检查local_free链表 根据free链表是否为空 来考虑是否要把local_free链表存放到free链表中</p>
<p>两种情况最后都是进入了mi_page_queue_find_free_ex函数 遍历retire链表 如果没有空闲的page就初始化一个新的page 如果初始化失败 就再次调用mi_page_queue_find_free_ex函数</p>
<h3 id="mi-free"><a href="#mi-free" class="headerlink" title="mi_free"></a>mi_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mi_free</span><span class="params">(<span class="type">void</span>* p)</span> mi_attr_noexcept</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(p == <span class="literal">NULL</span>)</span> <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">mi_segment_t</span>* <span class="type">const</span> segment = mi_checked_ptr_segment(p,<span class="string">&quot;mi_free&quot;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span>          is_local= (_mi_prim_thread_id() == mi_atomic_load_relaxed(&amp;segment-&gt;thread_id));</span><br><span class="line">  <span class="type">mi_page_t</span>* <span class="type">const</span>    page    = _mi_segment_page_of(segment, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(is_local)</span> &#123;                       <span class="comment">// thread-local free?</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(page-&gt;flags.full_aligned == <span class="number">0</span>)</span>  <span class="comment">// and it is not a full page (full pages need to move from the full bin), nor has aligned blocks (aligned blocks need to be unaligned)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">mi_block_t</span>* <span class="type">const</span> block = (<span class="type">mi_block_t</span>*)p;</span><br><span class="line">      <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_check_is_double_free(page, block))</span> <span class="keyword">return</span>;</span><br><span class="line">      mi_check_padding(page, block);</span><br><span class="line">      mi_stat_free(page, block);</span><br><span class="line">      <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED  &amp;&amp; !MI_TSAN</span></span><br><span class="line">      <span class="built_in">memset</span>(block, MI_DEBUG_FREED, mi_page_block_size(page));</span><br><span class="line">      <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      mi_track_free_size(p, mi_page_usable_size_of(page,block)); <span class="comment">// faster then mi_usable_size as we already know the page and that p is unaligned</span></span><br><span class="line">      mi_block_set_next(page, block, page-&gt;local_free);</span><br><span class="line">      page-&gt;local_free = block;</span><br><span class="line">      <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(--page-&gt;used == <span class="number">0</span>)</span> &#123;   <span class="comment">// using this expression generates better code than: page-&gt;used--; if (mi_page_all_free(page))</span></span><br><span class="line">        _mi_page_retire(page);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// page is full or contains (inner) aligned blocks; use generic path</span></span><br><span class="line">      _mi_free_generic(segment, page, <span class="literal">true</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// not thread-local; use generic path</span></span><br><span class="line">    _mi_free_generic(segment, page, <span class="literal">false</span>, p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始调用相关函数获取内存块对应的page和segment</p>
<p>接下来对于是否为同线程的内存块进行了判断 如果是其他线程的内存块 直接调用_mi_free_generic函数进行额外的情况</p>
<p>page-&gt;flags.full_aligned成员是用来查看该page是否需要内存对齐的 如果申请的大小刚好等于页的大小 那么内部就不用进行内存对齐 释放也直接调用_mi_free_generic函数来进行</p>
<p>接着检查了是否存在double free的情况(这里吐槽一下 我觉得这个check太仁慈了 就算检测出来 竟然也没有直接终止进程 你说就输出个报错有啥用阿哥 甚至你不开debug模式都不会进行double free检测)</p>
<p>mi_check_padding函数主要是调试模式下 会出申请padding的内存 用来存放字节 供检测是否出现内存越界的情况 没有开启debug模式的话 直接就可以忽略掉这个函数</p>
<p>mi_stat_free是用来统计free内存块的信息</p>
<p>可以看到最后   是更新了page的local_free链表  而非free链表 也就是说释放的内存块会优先进入local_free链表</p>
<p>接着根据page-&gt;used的值来判断page是否都是空闲内存块 如果是 则retire整个page</p>
<h3 id="mi-check-is-double-free"><a href="#mi-check-is-double-free" class="headerlink" title="mi_check_is_double_free"></a>mi_check_is_double_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mi_track_page(page,access)  &#123; size_t psize; void* pstart = _mi_page_start(_mi_page_segment(page),page,&amp;psize); mi_track_mem_##access( pstart, psize); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mi_check_is_double_free</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> is_double_free = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">mi_block_t</span>* n = mi_block_nextx(page, block, page-&gt;keys); <span class="comment">// pretend it is freed, and get the decoded first field</span></span><br><span class="line">  <span class="keyword">if</span> (((<span class="type">uintptr_t</span>)n &amp; (MI_INTPTR_SIZE<span class="number">-1</span>))==<span class="number">0</span> &amp;&amp;  <span class="comment">// quick check: aligned pointer?</span></span><br><span class="line">      (n==<span class="literal">NULL</span> || mi_is_in_same_page(block, n))) <span class="comment">// quick check: in same page or NULL?</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Suspicous: decoded value a in block is in the same page (or NULL) -- maybe a double free?</span></span><br><span class="line">    <span class="comment">// (continue in separate function to improve code generation)</span></span><br><span class="line">    is_double_free = mi_check_is_double_freex(page, block);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is_double_free;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mi_check_is_double_free</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  MI_UNUSED(page);</span><br><span class="line">  MI_UNUSED(block);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过mi_block_nextx函数来获取内存块的next成员 如果为0或者和内存块位于同一个page 那么就会进入mi_check_is_double_freex函数进行更加详细的check 如果不开启debug模式的话 不会进行double free检测</p>
<h3 id="mi-check-is-double-freex"><a href="#mi-check-is-double-freex" class="headerlink" title="mi_check_is_double_freex"></a>mi_check_is_double_freex</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mi_decl_noinline <span class="type">bool</span> <span class="title function_">mi_check_is_double_freex</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  <span class="comment">// The decoded value is in the same page (or NULL).</span></span><br><span class="line">  <span class="comment">// Walk the free lists to verify positively if it is already freed</span></span><br><span class="line">  <span class="keyword">if</span> (mi_list_contains(page, page-&gt;<span class="built_in">free</span>, block) ||</span><br><span class="line">      mi_list_contains(page, page-&gt;local_free, block) ||</span><br><span class="line">      mi_list_contains(page, mi_page_thread_free(page), block))</span><br><span class="line">  &#123;</span><br><span class="line">    _mi_error_message(EAGAIN, <span class="string">&quot;double free detected of block %p with size %zu\n&quot;</span>, block, mi_page_block_size(page));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过遍历page的三个链表来查找内存块是否已经被释放过了</p>
<p>相对来说比较好绕过 只要更改链表头的next成员 就可以让链表索引不到已经被释放过的内存块</p>
<h3 id="mi-free-generic"><a href="#mi-free-generic" class="headerlink" title="_mi_free_generic"></a>_mi_free_generic</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mi_decl_noinline _mi_free_generic(<span class="type">const</span> <span class="type">mi_segment_t</span>* segment, <span class="type">mi_page_t</span>* page, <span class="type">bool</span> is_local, <span class="type">void</span>* p) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="type">mi_block_t</span>* <span class="type">const</span> block = (mi_page_has_aligned(page) ? _mi_page_ptr_unalign(segment, page, p) : (<span class="type">mi_block_t</span>*)p);</span><br><span class="line">  mi_stat_free(page, block);    <span class="comment">// stat_free may access the padding</span></span><br><span class="line">  mi_track_free_size(block, mi_page_usable_size_of(page,block));</span><br><span class="line">  _mi_free_block(page, is_local, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始先进行了内存对齐的检测 随后就是老一套的内存块信息的记录</p>
<p>随后调用_mi_free_block函数释放内存块</p>
<h3 id="mi-free-block"><a href="#mi-free-block" class="headerlink" title="_mi_free_block"></a>_mi_free_block</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _mi_free_block(<span class="type">mi_page_t</span>* page, <span class="type">bool</span> local, <span class="type">mi_block_t</span>* block)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// and push it on the free list</span></span><br><span class="line">  <span class="comment">//const size_t bsize = mi_page_block_size(page);</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(local)</span> &#123;</span><br><span class="line">    <span class="comment">// owning thread can free a block directly</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_check_is_double_free(page, block))</span> <span class="keyword">return</span>;</span><br><span class="line">    mi_check_padding(page, block);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN</span></span><br><span class="line">    <span class="keyword">if</span> (!mi_page_is_huge(page)) &#123;   <span class="comment">// huge page content may be already decommitted</span></span><br><span class="line">      <span class="built_in">memset</span>(block, MI_DEBUG_FREED, mi_page_block_size(page));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    mi_block_set_next(page, block, page-&gt;local_free);</span><br><span class="line">    page-&gt;local_free = block;</span><br><span class="line">    page-&gt;used--;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_page_all_free(page))</span> &#123;</span><br><span class="line">      _mi_page_retire(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> mi_unlikely(mi_page_is_in_full(page)) &#123;</span><br><span class="line">      _mi_page_unfull(page);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _mi_free_block_mt(page,block);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍然是先进行了内存越界和double free的检测 同时根据是否开启了debug模式 来决定是否要调用memset函数清空内存块的内容</p>
<p>随后就是更新local_free链表和used的值 接着检查是否要释放整个page 或者是当前page是否已经成为满页 如果是满页则从满页列表中移除</p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>总结一下释放 实际上就是先进行没啥软用的double free检查 然后根据要释放的内存块是否就是整个page 来决定要不要用_mi_free_generic函数来释放</p>
<p>释放完的话 是加入到local_free链表 并且used的值会减少 相对来说逻辑还是比较简单的</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/07/21/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/">← Next 2023巅峰极客</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/07/16/House-of-Corrosion/">House of Corrosion Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307062245113.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>Dr.chen</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">编译环境配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">结构分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-malloc"><span class="toc-number">4.1.</span> <span class="toc-text">mi_malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-malloc-generic"><span class="toc-number">4.2.</span> <span class="toc-text">_mi_malloc_generic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-page-malloc"><span class="toc-number">4.3.</span> <span class="toc-text">_mi_page_malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-find-page"><span class="toc-number">4.4.</span> <span class="toc-text">mi_find_page</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-find-free-page"><span class="toc-number">4.5.</span> <span class="toc-text">mi_find_free_page</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-page-queue-find-free-ex"><span class="toc-number">4.6.</span> <span class="toc-text">mi_page_queue_find_free_ex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-page-free-collect"><span class="toc-number">4.7.</span> <span class="toc-text">_mi_page_free_collect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-heap-malloc-small-zero"><span class="toc-number">4.8.</span> <span class="toc-text">mi_heap_malloc_small_zero</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D"><span class="toc-number">4.9.</span> <span class="toc-text">分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-free"><span class="toc-number">4.10.</span> <span class="toc-text">mi_free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-check-is-double-free"><span class="toc-number">4.11.</span> <span class="toc-text">mi_check_is_double_free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-check-is-double-freex"><span class="toc-number">4.12.</span> <span class="toc-text">mi_check_is_double_freex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-free-generic"><span class="toc-number">4.13.</span> <span class="toc-text">_mi_free_generic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mi-free-block"><span class="toc-number">4.14.</span> <span class="toc-text">_mi_free_block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE"><span class="toc-number">4.15.</span> <span class="toc-text">释放</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>